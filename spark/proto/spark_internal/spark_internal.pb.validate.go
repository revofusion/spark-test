// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: spark_internal.proto

package spark_internal

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	spark "github.com/lightsparkdev/spark/proto/spark"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = spark.Network(0)
)

// Validate checks the field values on MarkKeysharesAsUsedRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MarkKeysharesAsUsedRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MarkKeysharesAsUsedRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MarkKeysharesAsUsedRequestMultiError, or nil if none found.
func (m *MarkKeysharesAsUsedRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MarkKeysharesAsUsedRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return MarkKeysharesAsUsedRequestMultiError(errors)
	}

	return nil
}

// MarkKeysharesAsUsedRequestMultiError is an error wrapping multiple
// validation errors returned by MarkKeysharesAsUsedRequest.ValidateAll() if
// the designated constraints aren't met.
type MarkKeysharesAsUsedRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MarkKeysharesAsUsedRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MarkKeysharesAsUsedRequestMultiError) AllErrors() []error { return m }

// MarkKeysharesAsUsedRequestValidationError is the validation error returned
// by MarkKeysharesAsUsedRequest.Validate if the designated constraints aren't met.
type MarkKeysharesAsUsedRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MarkKeysharesAsUsedRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MarkKeysharesAsUsedRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MarkKeysharesAsUsedRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MarkKeysharesAsUsedRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MarkKeysharesAsUsedRequestValidationError) ErrorName() string {
	return "MarkKeysharesAsUsedRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MarkKeysharesAsUsedRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMarkKeysharesAsUsedRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MarkKeysharesAsUsedRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MarkKeysharesAsUsedRequestValidationError{}

// Validate checks the field values on MarkKeyshareForDepositAddressRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *MarkKeyshareForDepositAddressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MarkKeyshareForDepositAddressRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// MarkKeyshareForDepositAddressRequestMultiError, or nil if none found.
func (m *MarkKeyshareForDepositAddressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MarkKeyshareForDepositAddressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for KeyshareId

	// no validation rules for Address

	// no validation rules for OwnerIdentityPublicKey

	// no validation rules for OwnerSigningPublicKey

	if m.IsStatic != nil {
		// no validation rules for IsStatic
	}

	if len(errors) > 0 {
		return MarkKeyshareForDepositAddressRequestMultiError(errors)
	}

	return nil
}

// MarkKeyshareForDepositAddressRequestMultiError is an error wrapping multiple
// validation errors returned by
// MarkKeyshareForDepositAddressRequest.ValidateAll() if the designated
// constraints aren't met.
type MarkKeyshareForDepositAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MarkKeyshareForDepositAddressRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MarkKeyshareForDepositAddressRequestMultiError) AllErrors() []error { return m }

// MarkKeyshareForDepositAddressRequestValidationError is the validation error
// returned by MarkKeyshareForDepositAddressRequest.Validate if the designated
// constraints aren't met.
type MarkKeyshareForDepositAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MarkKeyshareForDepositAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MarkKeyshareForDepositAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MarkKeyshareForDepositAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MarkKeyshareForDepositAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MarkKeyshareForDepositAddressRequestValidationError) ErrorName() string {
	return "MarkKeyshareForDepositAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MarkKeyshareForDepositAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMarkKeyshareForDepositAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MarkKeyshareForDepositAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MarkKeyshareForDepositAddressRequestValidationError{}

// Validate checks the field values on MarkKeyshareForDepositAddressResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *MarkKeyshareForDepositAddressResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MarkKeyshareForDepositAddressResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// MarkKeyshareForDepositAddressResponseMultiError, or nil if none found.
func (m *MarkKeyshareForDepositAddressResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MarkKeyshareForDepositAddressResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AddressSignature

	if len(errors) > 0 {
		return MarkKeyshareForDepositAddressResponseMultiError(errors)
	}

	return nil
}

// MarkKeyshareForDepositAddressResponseMultiError is an error wrapping
// multiple validation errors returned by
// MarkKeyshareForDepositAddressResponse.ValidateAll() if the designated
// constraints aren't met.
type MarkKeyshareForDepositAddressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MarkKeyshareForDepositAddressResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MarkKeyshareForDepositAddressResponseMultiError) AllErrors() []error { return m }

// MarkKeyshareForDepositAddressResponseValidationError is the validation error
// returned by MarkKeyshareForDepositAddressResponse.Validate if the
// designated constraints aren't met.
type MarkKeyshareForDepositAddressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MarkKeyshareForDepositAddressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MarkKeyshareForDepositAddressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MarkKeyshareForDepositAddressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MarkKeyshareForDepositAddressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MarkKeyshareForDepositAddressResponseValidationError) ErrorName() string {
	return "MarkKeyshareForDepositAddressResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MarkKeyshareForDepositAddressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMarkKeyshareForDepositAddressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MarkKeyshareForDepositAddressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MarkKeyshareForDepositAddressResponseValidationError{}

// Validate checks the field values on FrostRound1Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FrostRound1Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FrostRound1Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FrostRound1RequestMultiError, or nil if none found.
func (m *FrostRound1Request) ValidateAll() error {
	return m.validate(true)
}

func (m *FrostRound1Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PublicKeys

	// no validation rules for Count

	// no validation rules for RandomNonceCount

	if len(errors) > 0 {
		return FrostRound1RequestMultiError(errors)
	}

	return nil
}

// FrostRound1RequestMultiError is an error wrapping multiple validation errors
// returned by FrostRound1Request.ValidateAll() if the designated constraints
// aren't met.
type FrostRound1RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FrostRound1RequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FrostRound1RequestMultiError) AllErrors() []error { return m }

// FrostRound1RequestValidationError is the validation error returned by
// FrostRound1Request.Validate if the designated constraints aren't met.
type FrostRound1RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FrostRound1RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FrostRound1RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FrostRound1RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FrostRound1RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FrostRound1RequestValidationError) ErrorName() string {
	return "FrostRound1RequestValidationError"
}

// Error satisfies the builtin error interface
func (e FrostRound1RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFrostRound1Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FrostRound1RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FrostRound1RequestValidationError{}

// Validate checks the field values on FrostRound1Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FrostRound1Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FrostRound1Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FrostRound1ResponseMultiError, or nil if none found.
func (m *FrostRound1Response) ValidateAll() error {
	return m.validate(true)
}

func (m *FrostRound1Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSigningCommitments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FrostRound1ResponseValidationError{
						field:  fmt.Sprintf("SigningCommitments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FrostRound1ResponseValidationError{
						field:  fmt.Sprintf("SigningCommitments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FrostRound1ResponseValidationError{
					field:  fmt.Sprintf("SigningCommitments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FrostRound1ResponseMultiError(errors)
	}

	return nil
}

// FrostRound1ResponseMultiError is an error wrapping multiple validation
// errors returned by FrostRound1Response.ValidateAll() if the designated
// constraints aren't met.
type FrostRound1ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FrostRound1ResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FrostRound1ResponseMultiError) AllErrors() []error { return m }

// FrostRound1ResponseValidationError is the validation error returned by
// FrostRound1Response.Validate if the designated constraints aren't met.
type FrostRound1ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FrostRound1ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FrostRound1ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FrostRound1ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FrostRound1ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FrostRound1ResponseValidationError) ErrorName() string {
	return "FrostRound1ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FrostRound1ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFrostRound1Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FrostRound1ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FrostRound1ResponseValidationError{}

// Validate checks the field values on SigningJob with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SigningJob) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SigningJob with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SigningJobMultiError, or
// nil if none found.
func (m *SigningJob) ValidateAll() error {
	return m.validate(true)
}

func (m *SigningJob) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for JobId

	// no validation rules for Message

	// no validation rules for KeyshareId

	// no validation rules for VerifyingKey

	{
		sorted_keys := make([]string, len(m.GetCommitments()))
		i := 0
		for key := range m.GetCommitments() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetCommitments()[key]
			_ = val

			// no validation rules for Commitments[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, SigningJobValidationError{
							field:  fmt.Sprintf("Commitments[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, SigningJobValidationError{
							field:  fmt.Sprintf("Commitments[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return SigningJobValidationError{
						field:  fmt.Sprintf("Commitments[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetUserCommitments()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SigningJobValidationError{
					field:  "UserCommitments",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SigningJobValidationError{
					field:  "UserCommitments",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserCommitments()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SigningJobValidationError{
				field:  "UserCommitments",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AdaptorPublicKey

	if len(errors) > 0 {
		return SigningJobMultiError(errors)
	}

	return nil
}

// SigningJobMultiError is an error wrapping multiple validation errors
// returned by SigningJob.ValidateAll() if the designated constraints aren't met.
type SigningJobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SigningJobMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SigningJobMultiError) AllErrors() []error { return m }

// SigningJobValidationError is the validation error returned by
// SigningJob.Validate if the designated constraints aren't met.
type SigningJobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SigningJobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SigningJobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SigningJobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SigningJobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SigningJobValidationError) ErrorName() string { return "SigningJobValidationError" }

// Error satisfies the builtin error interface
func (e SigningJobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSigningJob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SigningJobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SigningJobValidationError{}

// Validate checks the field values on FrostRound2Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FrostRound2Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FrostRound2Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FrostRound2RequestMultiError, or nil if none found.
func (m *FrostRound2Request) ValidateAll() error {
	return m.validate(true)
}

func (m *FrostRound2Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSigningJobs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FrostRound2RequestValidationError{
						field:  fmt.Sprintf("SigningJobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FrostRound2RequestValidationError{
						field:  fmt.Sprintf("SigningJobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FrostRound2RequestValidationError{
					field:  fmt.Sprintf("SigningJobs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FrostRound2RequestMultiError(errors)
	}

	return nil
}

// FrostRound2RequestMultiError is an error wrapping multiple validation errors
// returned by FrostRound2Request.ValidateAll() if the designated constraints
// aren't met.
type FrostRound2RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FrostRound2RequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FrostRound2RequestMultiError) AllErrors() []error { return m }

// FrostRound2RequestValidationError is the validation error returned by
// FrostRound2Request.Validate if the designated constraints aren't met.
type FrostRound2RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FrostRound2RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FrostRound2RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FrostRound2RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FrostRound2RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FrostRound2RequestValidationError) ErrorName() string {
	return "FrostRound2RequestValidationError"
}

// Error satisfies the builtin error interface
func (e FrostRound2RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFrostRound2Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FrostRound2RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FrostRound2RequestValidationError{}

// Validate checks the field values on FrostRound2Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FrostRound2Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FrostRound2Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FrostRound2ResponseMultiError, or nil if none found.
func (m *FrostRound2Response) ValidateAll() error {
	return m.validate(true)
}

func (m *FrostRound2Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetResults()))
		i := 0
		for key := range m.GetResults() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetResults()[key]
			_ = val

			// no validation rules for Results[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, FrostRound2ResponseValidationError{
							field:  fmt.Sprintf("Results[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, FrostRound2ResponseValidationError{
							field:  fmt.Sprintf("Results[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return FrostRound2ResponseValidationError{
						field:  fmt.Sprintf("Results[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return FrostRound2ResponseMultiError(errors)
	}

	return nil
}

// FrostRound2ResponseMultiError is an error wrapping multiple validation
// errors returned by FrostRound2Response.ValidateAll() if the designated
// constraints aren't met.
type FrostRound2ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FrostRound2ResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FrostRound2ResponseMultiError) AllErrors() []error { return m }

// FrostRound2ResponseValidationError is the validation error returned by
// FrostRound2Response.Validate if the designated constraints aren't met.
type FrostRound2ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FrostRound2ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FrostRound2ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FrostRound2ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FrostRound2ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FrostRound2ResponseValidationError) ErrorName() string {
	return "FrostRound2ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FrostRound2ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFrostRound2Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FrostRound2ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FrostRound2ResponseValidationError{}

// Validate checks the field values on FinalizeTreeCreationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FinalizeTreeCreationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinalizeTreeCreationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FinalizeTreeCreationRequestMultiError, or nil if none found.
func (m *FinalizeTreeCreationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalizeTreeCreationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FinalizeTreeCreationRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FinalizeTreeCreationRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FinalizeTreeCreationRequestValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Network

	if len(errors) > 0 {
		return FinalizeTreeCreationRequestMultiError(errors)
	}

	return nil
}

// FinalizeTreeCreationRequestMultiError is an error wrapping multiple
// validation errors returned by FinalizeTreeCreationRequest.ValidateAll() if
// the designated constraints aren't met.
type FinalizeTreeCreationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalizeTreeCreationRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalizeTreeCreationRequestMultiError) AllErrors() []error { return m }

// FinalizeTreeCreationRequestValidationError is the validation error returned
// by FinalizeTreeCreationRequest.Validate if the designated constraints
// aren't met.
type FinalizeTreeCreationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalizeTreeCreationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalizeTreeCreationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalizeTreeCreationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalizeTreeCreationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalizeTreeCreationRequestValidationError) ErrorName() string {
	return "FinalizeTreeCreationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FinalizeTreeCreationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalizeTreeCreationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalizeTreeCreationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalizeTreeCreationRequestValidationError{}

// Validate checks the field values on FinalizeTransferRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FinalizeTransferRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinalizeTransferRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FinalizeTransferRequestMultiError, or nil if none found.
func (m *FinalizeTransferRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalizeTransferRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FinalizeTransferRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FinalizeTransferRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FinalizeTransferRequestValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FinalizeTransferRequestValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FinalizeTransferRequestValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FinalizeTransferRequestValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FinalizeTransferRequestMultiError(errors)
	}

	return nil
}

// FinalizeTransferRequestMultiError is an error wrapping multiple validation
// errors returned by FinalizeTransferRequest.ValidateAll() if the designated
// constraints aren't met.
type FinalizeTransferRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalizeTransferRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalizeTransferRequestMultiError) AllErrors() []error { return m }

// FinalizeTransferRequestValidationError is the validation error returned by
// FinalizeTransferRequest.Validate if the designated constraints aren't met.
type FinalizeTransferRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalizeTransferRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalizeTransferRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalizeTransferRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalizeTransferRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalizeTransferRequestValidationError) ErrorName() string {
	return "FinalizeTransferRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FinalizeTransferRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalizeTransferRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalizeTransferRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalizeTransferRequestValidationError{}

// Validate checks the field values on FinalizeRefreshTimelockRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FinalizeRefreshTimelockRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinalizeRefreshTimelockRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// FinalizeRefreshTimelockRequestMultiError, or nil if none found.
func (m *FinalizeRefreshTimelockRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalizeRefreshTimelockRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FinalizeRefreshTimelockRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FinalizeRefreshTimelockRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FinalizeRefreshTimelockRequestValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FinalizeRefreshTimelockRequestMultiError(errors)
	}

	return nil
}

// FinalizeRefreshTimelockRequestMultiError is an error wrapping multiple
// validation errors returned by FinalizeRefreshTimelockRequest.ValidateAll()
// if the designated constraints aren't met.
type FinalizeRefreshTimelockRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalizeRefreshTimelockRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalizeRefreshTimelockRequestMultiError) AllErrors() []error { return m }

// FinalizeRefreshTimelockRequestValidationError is the validation error
// returned by FinalizeRefreshTimelockRequest.Validate if the designated
// constraints aren't met.
type FinalizeRefreshTimelockRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalizeRefreshTimelockRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalizeRefreshTimelockRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalizeRefreshTimelockRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalizeRefreshTimelockRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalizeRefreshTimelockRequestValidationError) ErrorName() string {
	return "FinalizeRefreshTimelockRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FinalizeRefreshTimelockRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalizeRefreshTimelockRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalizeRefreshTimelockRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalizeRefreshTimelockRequestValidationError{}

// Validate checks the field values on FinalizeExtendLeafRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FinalizeExtendLeafRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinalizeExtendLeafRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FinalizeExtendLeafRequestMultiError, or nil if none found.
func (m *FinalizeExtendLeafRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalizeExtendLeafRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FinalizeExtendLeafRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FinalizeExtendLeafRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FinalizeExtendLeafRequestValidationError{
				field:  "Node",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FinalizeExtendLeafRequestMultiError(errors)
	}

	return nil
}

// FinalizeExtendLeafRequestMultiError is an error wrapping multiple validation
// errors returned by FinalizeExtendLeafRequest.ValidateAll() if the
// designated constraints aren't met.
type FinalizeExtendLeafRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalizeExtendLeafRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalizeExtendLeafRequestMultiError) AllErrors() []error { return m }

// FinalizeExtendLeafRequestValidationError is the validation error returned by
// FinalizeExtendLeafRequest.Validate if the designated constraints aren't met.
type FinalizeExtendLeafRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalizeExtendLeafRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalizeExtendLeafRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalizeExtendLeafRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalizeExtendLeafRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalizeExtendLeafRequestValidationError) ErrorName() string {
	return "FinalizeExtendLeafRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FinalizeExtendLeafRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalizeExtendLeafRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalizeExtendLeafRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalizeExtendLeafRequestValidationError{}

// Validate checks the field values on FinalizeRenewRefundTimelockRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *FinalizeRenewRefundTimelockRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinalizeRenewRefundTimelockRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// FinalizeRenewRefundTimelockRequestMultiError, or nil if none found.
func (m *FinalizeRenewRefundTimelockRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalizeRenewRefundTimelockRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FinalizeRenewRefundTimelockRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FinalizeRenewRefundTimelockRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FinalizeRenewRefundTimelockRequestValidationError{
				field:  "Node",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FinalizeRenewRefundTimelockRequestMultiError(errors)
	}

	return nil
}

// FinalizeRenewRefundTimelockRequestMultiError is an error wrapping multiple
// validation errors returned by
// FinalizeRenewRefundTimelockRequest.ValidateAll() if the designated
// constraints aren't met.
type FinalizeRenewRefundTimelockRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalizeRenewRefundTimelockRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalizeRenewRefundTimelockRequestMultiError) AllErrors() []error { return m }

// FinalizeRenewRefundTimelockRequestValidationError is the validation error
// returned by FinalizeRenewRefundTimelockRequest.Validate if the designated
// constraints aren't met.
type FinalizeRenewRefundTimelockRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalizeRenewRefundTimelockRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalizeRenewRefundTimelockRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalizeRenewRefundTimelockRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalizeRenewRefundTimelockRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalizeRenewRefundTimelockRequestValidationError) ErrorName() string {
	return "FinalizeRenewRefundTimelockRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FinalizeRenewRefundTimelockRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalizeRenewRefundTimelockRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalizeRenewRefundTimelockRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalizeRenewRefundTimelockRequestValidationError{}

// Validate checks the field values on FinalizeRenewNodeTimelockRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *FinalizeRenewNodeTimelockRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinalizeRenewNodeTimelockRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// FinalizeRenewNodeTimelockRequestMultiError, or nil if none found.
func (m *FinalizeRenewNodeTimelockRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalizeRenewNodeTimelockRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSplitNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FinalizeRenewNodeTimelockRequestValidationError{
					field:  "SplitNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FinalizeRenewNodeTimelockRequestValidationError{
					field:  "SplitNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSplitNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FinalizeRenewNodeTimelockRequestValidationError{
				field:  "SplitNode",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FinalizeRenewNodeTimelockRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FinalizeRenewNodeTimelockRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FinalizeRenewNodeTimelockRequestValidationError{
				field:  "Node",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FinalizeRenewNodeTimelockRequestMultiError(errors)
	}

	return nil
}

// FinalizeRenewNodeTimelockRequestMultiError is an error wrapping multiple
// validation errors returned by
// FinalizeRenewNodeTimelockRequest.ValidateAll() if the designated
// constraints aren't met.
type FinalizeRenewNodeTimelockRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalizeRenewNodeTimelockRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalizeRenewNodeTimelockRequestMultiError) AllErrors() []error { return m }

// FinalizeRenewNodeTimelockRequestValidationError is the validation error
// returned by FinalizeRenewNodeTimelockRequest.Validate if the designated
// constraints aren't met.
type FinalizeRenewNodeTimelockRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalizeRenewNodeTimelockRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalizeRenewNodeTimelockRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalizeRenewNodeTimelockRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalizeRenewNodeTimelockRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalizeRenewNodeTimelockRequestValidationError) ErrorName() string {
	return "FinalizeRenewNodeTimelockRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FinalizeRenewNodeTimelockRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalizeRenewNodeTimelockRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalizeRenewNodeTimelockRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalizeRenewNodeTimelockRequestValidationError{}

// Validate checks the field values on TreeNode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TreeNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TreeNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TreeNodeMultiError, or nil
// if none found.
func (m *TreeNode) ValidateAll() error {
	return m.validate(true)
}

func (m *TreeNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Value

	// no validation rules for VerifyingPubkey

	// no validation rules for OwnerIdentityPubkey

	// no validation rules for OwnerSigningPubkey

	// no validation rules for RawTx

	// no validation rules for RawRefundTx

	// no validation rules for TreeId

	// no validation rules for SigningKeyshareId

	// no validation rules for Vout

	// no validation rules for RefundTimelock

	// no validation rules for DirectTx

	// no validation rules for DirectRefundTx

	// no validation rules for DirectFromCpfpRefundTx

	if m.ParentNodeId != nil {
		// no validation rules for ParentNodeId
	}

	if len(errors) > 0 {
		return TreeNodeMultiError(errors)
	}

	return nil
}

// TreeNodeMultiError is an error wrapping multiple validation errors returned
// by TreeNode.ValidateAll() if the designated constraints aren't met.
type TreeNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TreeNodeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TreeNodeMultiError) AllErrors() []error { return m }

// TreeNodeValidationError is the validation error returned by
// TreeNode.Validate if the designated constraints aren't met.
type TreeNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TreeNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TreeNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TreeNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TreeNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TreeNodeValidationError) ErrorName() string { return "TreeNodeValidationError" }

// Error satisfies the builtin error interface
func (e TreeNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTreeNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TreeNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TreeNodeValidationError{}

// Validate checks the field values on InitiatePreimageSwapRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitiatePreimageSwapRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiatePreimageSwapRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitiatePreimageSwapRequestMultiError, or nil if none found.
func (m *InitiatePreimageSwapRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiatePreimageSwapRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiatePreimageSwapRequestValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiatePreimageSwapRequestValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiatePreimageSwapRequestValidationError{
				field:  "Request",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CpfpRefundSignatures

	// no validation rules for DirectRefundSignatures

	// no validation rules for DirectFromCpfpRefundSignatures

	if len(errors) > 0 {
		return InitiatePreimageSwapRequestMultiError(errors)
	}

	return nil
}

// InitiatePreimageSwapRequestMultiError is an error wrapping multiple
// validation errors returned by InitiatePreimageSwapRequest.ValidateAll() if
// the designated constraints aren't met.
type InitiatePreimageSwapRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiatePreimageSwapRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiatePreimageSwapRequestMultiError) AllErrors() []error { return m }

// InitiatePreimageSwapRequestValidationError is the validation error returned
// by InitiatePreimageSwapRequest.Validate if the designated constraints
// aren't met.
type InitiatePreimageSwapRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiatePreimageSwapRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiatePreimageSwapRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiatePreimageSwapRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiatePreimageSwapRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiatePreimageSwapRequestValidationError) ErrorName() string {
	return "InitiatePreimageSwapRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InitiatePreimageSwapRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiatePreimageSwapRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiatePreimageSwapRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiatePreimageSwapRequestValidationError{}

// Validate checks the field values on InitiatePreimageSwapResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitiatePreimageSwapResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiatePreimageSwapResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitiatePreimageSwapResponseMultiError, or nil if none found.
func (m *InitiatePreimageSwapResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiatePreimageSwapResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PreimageShare

	if len(errors) > 0 {
		return InitiatePreimageSwapResponseMultiError(errors)
	}

	return nil
}

// InitiatePreimageSwapResponseMultiError is an error wrapping multiple
// validation errors returned by InitiatePreimageSwapResponse.ValidateAll() if
// the designated constraints aren't met.
type InitiatePreimageSwapResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiatePreimageSwapResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiatePreimageSwapResponseMultiError) AllErrors() []error { return m }

// InitiatePreimageSwapResponseValidationError is the validation error returned
// by InitiatePreimageSwapResponse.Validate if the designated constraints
// aren't met.
type InitiatePreimageSwapResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiatePreimageSwapResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiatePreimageSwapResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiatePreimageSwapResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiatePreimageSwapResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiatePreimageSwapResponseValidationError) ErrorName() string {
	return "InitiatePreimageSwapResponseValidationError"
}

// Error satisfies the builtin error interface
func (e InitiatePreimageSwapResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiatePreimageSwapResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiatePreimageSwapResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiatePreimageSwapResponseValidationError{}

// Validate checks the field values on PrepareTreeAddressNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PrepareTreeAddressNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PrepareTreeAddressNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PrepareTreeAddressNodeMultiError, or nil if none found.
func (m *PrepareTreeAddressNode) ValidateAll() error {
	return m.validate(true)
}

func (m *PrepareTreeAddressNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SigningKeyshareId

	// no validation rules for UserPublicKey

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PrepareTreeAddressNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PrepareTreeAddressNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PrepareTreeAddressNodeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PrepareTreeAddressNodeMultiError(errors)
	}

	return nil
}

// PrepareTreeAddressNodeMultiError is an error wrapping multiple validation
// errors returned by PrepareTreeAddressNode.ValidateAll() if the designated
// constraints aren't met.
type PrepareTreeAddressNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PrepareTreeAddressNodeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PrepareTreeAddressNodeMultiError) AllErrors() []error { return m }

// PrepareTreeAddressNodeValidationError is the validation error returned by
// PrepareTreeAddressNode.Validate if the designated constraints aren't met.
type PrepareTreeAddressNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PrepareTreeAddressNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PrepareTreeAddressNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PrepareTreeAddressNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PrepareTreeAddressNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PrepareTreeAddressNodeValidationError) ErrorName() string {
	return "PrepareTreeAddressNodeValidationError"
}

// Error satisfies the builtin error interface
func (e PrepareTreeAddressNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrepareTreeAddressNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PrepareTreeAddressNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PrepareTreeAddressNodeValidationError{}

// Validate checks the field values on PrepareTreeAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PrepareTreeAddressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PrepareTreeAddressRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PrepareTreeAddressRequestMultiError, or nil if none found.
func (m *PrepareTreeAddressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PrepareTreeAddressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TargetKeyshareId

	if all {
		switch v := interface{}(m.GetNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PrepareTreeAddressRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PrepareTreeAddressRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PrepareTreeAddressRequestValidationError{
				field:  "Node",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserIdentityPublicKey

	// no validation rules for Network

	if len(errors) > 0 {
		return PrepareTreeAddressRequestMultiError(errors)
	}

	return nil
}

// PrepareTreeAddressRequestMultiError is an error wrapping multiple validation
// errors returned by PrepareTreeAddressRequest.ValidateAll() if the
// designated constraints aren't met.
type PrepareTreeAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PrepareTreeAddressRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PrepareTreeAddressRequestMultiError) AllErrors() []error { return m }

// PrepareTreeAddressRequestValidationError is the validation error returned by
// PrepareTreeAddressRequest.Validate if the designated constraints aren't met.
type PrepareTreeAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PrepareTreeAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PrepareTreeAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PrepareTreeAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PrepareTreeAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PrepareTreeAddressRequestValidationError) ErrorName() string {
	return "PrepareTreeAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PrepareTreeAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrepareTreeAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PrepareTreeAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PrepareTreeAddressRequestValidationError{}

// Validate checks the field values on PrepareTreeAddressResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PrepareTreeAddressResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PrepareTreeAddressResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PrepareTreeAddressResponseMultiError, or nil if none found.
func (m *PrepareTreeAddressResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PrepareTreeAddressResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Signatures

	if len(errors) > 0 {
		return PrepareTreeAddressResponseMultiError(errors)
	}

	return nil
}

// PrepareTreeAddressResponseMultiError is an error wrapping multiple
// validation errors returned by PrepareTreeAddressResponse.ValidateAll() if
// the designated constraints aren't met.
type PrepareTreeAddressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PrepareTreeAddressResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PrepareTreeAddressResponseMultiError) AllErrors() []error { return m }

// PrepareTreeAddressResponseValidationError is the validation error returned
// by PrepareTreeAddressResponse.Validate if the designated constraints aren't met.
type PrepareTreeAddressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PrepareTreeAddressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PrepareTreeAddressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PrepareTreeAddressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PrepareTreeAddressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PrepareTreeAddressResponseValidationError) ErrorName() string {
	return "PrepareTreeAddressResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PrepareTreeAddressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrepareTreeAddressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PrepareTreeAddressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PrepareTreeAddressResponseValidationError{}

// Validate checks the field values on InitiateTransferLeaf with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitiateTransferLeaf) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiateTransferLeaf with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitiateTransferLeafMultiError, or nil if none found.
func (m *InitiateTransferLeaf) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiateTransferLeaf) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LeafId

	// no validation rules for RawRefundTx

	// no validation rules for DirectRefundTx

	// no validation rules for DirectFromCpfpRefundTx

	if len(errors) > 0 {
		return InitiateTransferLeafMultiError(errors)
	}

	return nil
}

// InitiateTransferLeafMultiError is an error wrapping multiple validation
// errors returned by InitiateTransferLeaf.ValidateAll() if the designated
// constraints aren't met.
type InitiateTransferLeafMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiateTransferLeafMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiateTransferLeafMultiError) AllErrors() []error { return m }

// InitiateTransferLeafValidationError is the validation error returned by
// InitiateTransferLeaf.Validate if the designated constraints aren't met.
type InitiateTransferLeafValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiateTransferLeafValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiateTransferLeafValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiateTransferLeafValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiateTransferLeafValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiateTransferLeafValidationError) ErrorName() string {
	return "InitiateTransferLeafValidationError"
}

// Error satisfies the builtin error interface
func (e InitiateTransferLeafValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiateTransferLeaf.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiateTransferLeafValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiateTransferLeafValidationError{}

// Validate checks the field values on InitiateTransferRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitiateTransferRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiateTransferRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitiateTransferRequestMultiError, or nil if none found.
func (m *InitiateTransferRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiateTransferRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	// no validation rules for SenderIdentityPublicKey

	// no validation rules for ReceiverIdentityPublicKey

	if all {
		switch v := interface{}(m.GetExpiryTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiateTransferRequestValidationError{
					field:  "ExpiryTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiateTransferRequestValidationError{
					field:  "ExpiryTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpiryTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiateTransferRequestValidationError{
				field:  "ExpiryTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetLeaves() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InitiateTransferRequestValidationError{
						field:  fmt.Sprintf("Leaves[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InitiateTransferRequestValidationError{
						field:  fmt.Sprintf("Leaves[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InitiateTransferRequestValidationError{
					field:  fmt.Sprintf("Leaves[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	{
		sorted_keys := make([]string, len(m.GetSenderKeyTweakProofs()))
		i := 0
		for key := range m.GetSenderKeyTweakProofs() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetSenderKeyTweakProofs()[key]
			_ = val

			// no validation rules for SenderKeyTweakProofs[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, InitiateTransferRequestValidationError{
							field:  fmt.Sprintf("SenderKeyTweakProofs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, InitiateTransferRequestValidationError{
							field:  fmt.Sprintf("SenderKeyTweakProofs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return InitiateTransferRequestValidationError{
						field:  fmt.Sprintf("SenderKeyTweakProofs[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetTransferPackage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiateTransferRequestValidationError{
					field:  "TransferPackage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiateTransferRequestValidationError{
					field:  "TransferPackage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransferPackage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiateTransferRequestValidationError{
				field:  "TransferPackage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RefundSignatures

	// no validation rules for DirectRefundSignatures

	// no validation rules for DirectFromCpfpRefundSignatures

	// no validation rules for SparkInvoice

	if all {
		switch v := interface{}(m.GetAdaptorPublicKeys()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiateTransferRequestValidationError{
					field:  "AdaptorPublicKeys",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiateTransferRequestValidationError{
					field:  "AdaptorPublicKeys",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAdaptorPublicKeys()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiateTransferRequestValidationError{
				field:  "AdaptorPublicKeys",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InitiateTransferRequestMultiError(errors)
	}

	return nil
}

// InitiateTransferRequestMultiError is an error wrapping multiple validation
// errors returned by InitiateTransferRequest.ValidateAll() if the designated
// constraints aren't met.
type InitiateTransferRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiateTransferRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiateTransferRequestMultiError) AllErrors() []error { return m }

// InitiateTransferRequestValidationError is the validation error returned by
// InitiateTransferRequest.Validate if the designated constraints aren't met.
type InitiateTransferRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiateTransferRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiateTransferRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiateTransferRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiateTransferRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiateTransferRequestValidationError) ErrorName() string {
	return "InitiateTransferRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InitiateTransferRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiateTransferRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiateTransferRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiateTransferRequestValidationError{}

// Validate checks the field values on DeliverSenderKeyTweakRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeliverSenderKeyTweakRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeliverSenderKeyTweakRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeliverSenderKeyTweakRequestMultiError, or nil if none found.
func (m *DeliverSenderKeyTweakRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeliverSenderKeyTweakRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	// no validation rules for SenderIdentityPublicKey

	if all {
		switch v := interface{}(m.GetTransferPackage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliverSenderKeyTweakRequestValidationError{
					field:  "TransferPackage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliverSenderKeyTweakRequestValidationError{
					field:  "TransferPackage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransferPackage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliverSenderKeyTweakRequestValidationError{
				field:  "TransferPackage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeliverSenderKeyTweakRequestMultiError(errors)
	}

	return nil
}

// DeliverSenderKeyTweakRequestMultiError is an error wrapping multiple
// validation errors returned by DeliverSenderKeyTweakRequest.ValidateAll() if
// the designated constraints aren't met.
type DeliverSenderKeyTweakRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeliverSenderKeyTweakRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeliverSenderKeyTweakRequestMultiError) AllErrors() []error { return m }

// DeliverSenderKeyTweakRequestValidationError is the validation error returned
// by DeliverSenderKeyTweakRequest.Validate if the designated constraints
// aren't met.
type DeliverSenderKeyTweakRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeliverSenderKeyTweakRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeliverSenderKeyTweakRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeliverSenderKeyTweakRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeliverSenderKeyTweakRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeliverSenderKeyTweakRequestValidationError) ErrorName() string {
	return "DeliverSenderKeyTweakRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeliverSenderKeyTweakRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeliverSenderKeyTweakRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeliverSenderKeyTweakRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeliverSenderKeyTweakRequestValidationError{}

// Validate checks the field values on InitiateCooperativeExitRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitiateCooperativeExitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiateCooperativeExitRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// InitiateCooperativeExitRequestMultiError, or nil if none found.
func (m *InitiateCooperativeExitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiateCooperativeExitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiateCooperativeExitRequestValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiateCooperativeExitRequestValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiateCooperativeExitRequestValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ExitId

	// no validation rules for ExitTxid

	if len(errors) > 0 {
		return InitiateCooperativeExitRequestMultiError(errors)
	}

	return nil
}

// InitiateCooperativeExitRequestMultiError is an error wrapping multiple
// validation errors returned by InitiateCooperativeExitRequest.ValidateAll()
// if the designated constraints aren't met.
type InitiateCooperativeExitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiateCooperativeExitRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiateCooperativeExitRequestMultiError) AllErrors() []error { return m }

// InitiateCooperativeExitRequestValidationError is the validation error
// returned by InitiateCooperativeExitRequest.Validate if the designated
// constraints aren't met.
type InitiateCooperativeExitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiateCooperativeExitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiateCooperativeExitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiateCooperativeExitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiateCooperativeExitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiateCooperativeExitRequestValidationError) ErrorName() string {
	return "InitiateCooperativeExitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InitiateCooperativeExitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiateCooperativeExitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiateCooperativeExitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiateCooperativeExitRequestValidationError{}

// Validate checks the field values on UpdatePreimageRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePreimageRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePreimageRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePreimageRequestRequestMultiError, or nil if none found.
func (m *UpdatePreimageRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePreimageRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PreimageRequestId

	// no validation rules for Preimage

	// no validation rules for IdentityPublicKey

	if len(errors) > 0 {
		return UpdatePreimageRequestRequestMultiError(errors)
	}

	return nil
}

// UpdatePreimageRequestRequestMultiError is an error wrapping multiple
// validation errors returned by UpdatePreimageRequestRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdatePreimageRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePreimageRequestRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePreimageRequestRequestMultiError) AllErrors() []error { return m }

// UpdatePreimageRequestRequestValidationError is the validation error returned
// by UpdatePreimageRequestRequest.Validate if the designated constraints
// aren't met.
type UpdatePreimageRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePreimageRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePreimageRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePreimageRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePreimageRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePreimageRequestRequestValidationError) ErrorName() string {
	return "UpdatePreimageRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePreimageRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePreimageRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePreimageRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePreimageRequestRequestValidationError{}

// Validate checks the field values on StartTokenTransactionInternalRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *StartTokenTransactionInternalRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartTokenTransactionInternalRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// StartTokenTransactionInternalRequestMultiError, or nil if none found.
func (m *StartTokenTransactionInternalRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StartTokenTransactionInternalRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFinalTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTokenTransactionInternalRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTokenTransactionInternalRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTokenTransactionInternalRequestValidationError{
				field:  "FinalTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTokenTransactionSignatures()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTokenTransactionInternalRequestValidationError{
					field:  "TokenTransactionSignatures",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTokenTransactionInternalRequestValidationError{
					field:  "TokenTransactionSignatures",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTokenTransactionSignatures()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTokenTransactionInternalRequestValidationError{
				field:  "TokenTransactionSignatures",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CoordinatorPublicKey

	if len(errors) > 0 {
		return StartTokenTransactionInternalRequestMultiError(errors)
	}

	return nil
}

// StartTokenTransactionInternalRequestMultiError is an error wrapping multiple
// validation errors returned by
// StartTokenTransactionInternalRequest.ValidateAll() if the designated
// constraints aren't met.
type StartTokenTransactionInternalRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartTokenTransactionInternalRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartTokenTransactionInternalRequestMultiError) AllErrors() []error { return m }

// StartTokenTransactionInternalRequestValidationError is the validation error
// returned by StartTokenTransactionInternalRequest.Validate if the designated
// constraints aren't met.
type StartTokenTransactionInternalRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartTokenTransactionInternalRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartTokenTransactionInternalRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartTokenTransactionInternalRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartTokenTransactionInternalRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartTokenTransactionInternalRequestValidationError) ErrorName() string {
	return "StartTokenTransactionInternalRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StartTokenTransactionInternalRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartTokenTransactionInternalRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartTokenTransactionInternalRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartTokenTransactionInternalRequestValidationError{}

// Validate checks the field values on StartTokenTransactionInternalResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *StartTokenTransactionInternalResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartTokenTransactionInternalResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// StartTokenTransactionInternalResponseMultiError, or nil if none found.
func (m *StartTokenTransactionInternalResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StartTokenTransactionInternalResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFinalTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTokenTransactionInternalResponseValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTokenTransactionInternalResponseValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTokenTransactionInternalResponseValidationError{
				field:  "FinalTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StartTokenTransactionInternalResponseMultiError(errors)
	}

	return nil
}

// StartTokenTransactionInternalResponseMultiError is an error wrapping
// multiple validation errors returned by
// StartTokenTransactionInternalResponse.ValidateAll() if the designated
// constraints aren't met.
type StartTokenTransactionInternalResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartTokenTransactionInternalResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartTokenTransactionInternalResponseMultiError) AllErrors() []error { return m }

// StartTokenTransactionInternalResponseValidationError is the validation error
// returned by StartTokenTransactionInternalResponse.Validate if the
// designated constraints aren't met.
type StartTokenTransactionInternalResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartTokenTransactionInternalResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartTokenTransactionInternalResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartTokenTransactionInternalResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartTokenTransactionInternalResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartTokenTransactionInternalResponseValidationError) ErrorName() string {
	return "StartTokenTransactionInternalResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StartTokenTransactionInternalResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartTokenTransactionInternalResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartTokenTransactionInternalResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartTokenTransactionInternalResponseValidationError{}

// Validate checks the field values on InitiateSettleReceiverKeyTweakRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *InitiateSettleReceiverKeyTweakRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiateSettleReceiverKeyTweakRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// InitiateSettleReceiverKeyTweakRequestMultiError, or nil if none found.
func (m *InitiateSettleReceiverKeyTweakRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiateSettleReceiverKeyTweakRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	{
		sorted_keys := make([]string, len(m.GetKeyTweakProofs()))
		i := 0
		for key := range m.GetKeyTweakProofs() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetKeyTweakProofs()[key]
			_ = val

			// no validation rules for KeyTweakProofs[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, InitiateSettleReceiverKeyTweakRequestValidationError{
							field:  fmt.Sprintf("KeyTweakProofs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, InitiateSettleReceiverKeyTweakRequestValidationError{
							field:  fmt.Sprintf("KeyTweakProofs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return InitiateSettleReceiverKeyTweakRequestValidationError{
						field:  fmt.Sprintf("KeyTweakProofs[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for UserPublicKeys

	if len(errors) > 0 {
		return InitiateSettleReceiverKeyTweakRequestMultiError(errors)
	}

	return nil
}

// InitiateSettleReceiverKeyTweakRequestMultiError is an error wrapping
// multiple validation errors returned by
// InitiateSettleReceiverKeyTweakRequest.ValidateAll() if the designated
// constraints aren't met.
type InitiateSettleReceiverKeyTweakRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiateSettleReceiverKeyTweakRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiateSettleReceiverKeyTweakRequestMultiError) AllErrors() []error { return m }

// InitiateSettleReceiverKeyTweakRequestValidationError is the validation error
// returned by InitiateSettleReceiverKeyTweakRequest.Validate if the
// designated constraints aren't met.
type InitiateSettleReceiverKeyTweakRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiateSettleReceiverKeyTweakRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiateSettleReceiverKeyTweakRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiateSettleReceiverKeyTweakRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiateSettleReceiverKeyTweakRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiateSettleReceiverKeyTweakRequestValidationError) ErrorName() string {
	return "InitiateSettleReceiverKeyTweakRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InitiateSettleReceiverKeyTweakRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiateSettleReceiverKeyTweakRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiateSettleReceiverKeyTweakRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiateSettleReceiverKeyTweakRequestValidationError{}

// Validate checks the field values on SettleReceiverKeyTweakRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SettleReceiverKeyTweakRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SettleReceiverKeyTweakRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SettleReceiverKeyTweakRequestMultiError, or nil if none found.
func (m *SettleReceiverKeyTweakRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SettleReceiverKeyTweakRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	// no validation rules for Action

	if len(errors) > 0 {
		return SettleReceiverKeyTweakRequestMultiError(errors)
	}

	return nil
}

// SettleReceiverKeyTweakRequestMultiError is an error wrapping multiple
// validation errors returned by SettleReceiverKeyTweakRequest.ValidateAll()
// if the designated constraints aren't met.
type SettleReceiverKeyTweakRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SettleReceiverKeyTweakRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SettleReceiverKeyTweakRequestMultiError) AllErrors() []error { return m }

// SettleReceiverKeyTweakRequestValidationError is the validation error
// returned by SettleReceiverKeyTweakRequest.Validate if the designated
// constraints aren't met.
type SettleReceiverKeyTweakRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SettleReceiverKeyTweakRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SettleReceiverKeyTweakRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SettleReceiverKeyTweakRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SettleReceiverKeyTweakRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SettleReceiverKeyTweakRequestValidationError) ErrorName() string {
	return "SettleReceiverKeyTweakRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SettleReceiverKeyTweakRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSettleReceiverKeyTweakRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SettleReceiverKeyTweakRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SettleReceiverKeyTweakRequestValidationError{}

// Validate checks the field values on SettleSenderKeyTweakRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SettleSenderKeyTweakRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SettleSenderKeyTweakRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SettleSenderKeyTweakRequestMultiError, or nil if none found.
func (m *SettleSenderKeyTweakRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SettleSenderKeyTweakRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	// no validation rules for Action

	if len(errors) > 0 {
		return SettleSenderKeyTweakRequestMultiError(errors)
	}

	return nil
}

// SettleSenderKeyTweakRequestMultiError is an error wrapping multiple
// validation errors returned by SettleSenderKeyTweakRequest.ValidateAll() if
// the designated constraints aren't met.
type SettleSenderKeyTweakRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SettleSenderKeyTweakRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SettleSenderKeyTweakRequestMultiError) AllErrors() []error { return m }

// SettleSenderKeyTweakRequestValidationError is the validation error returned
// by SettleSenderKeyTweakRequest.Validate if the designated constraints
// aren't met.
type SettleSenderKeyTweakRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SettleSenderKeyTweakRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SettleSenderKeyTweakRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SettleSenderKeyTweakRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SettleSenderKeyTweakRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SettleSenderKeyTweakRequestValidationError) ErrorName() string {
	return "SettleSenderKeyTweakRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SettleSenderKeyTweakRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSettleSenderKeyTweakRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SettleSenderKeyTweakRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SettleSenderKeyTweakRequestValidationError{}

// Validate checks the field values on CreateUtxoSwapRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateUtxoSwapRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUtxoSwapRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateUtxoSwapRequestMultiError, or nil if none found.
func (m *CreateUtxoSwapRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUtxoSwapRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateUtxoSwapRequestValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateUtxoSwapRequestValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateUtxoSwapRequestValidationError{
				field:  "Request",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Signature

	// no validation rules for CoordinatorPublicKey

	if len(errors) > 0 {
		return CreateUtxoSwapRequestMultiError(errors)
	}

	return nil
}

// CreateUtxoSwapRequestMultiError is an error wrapping multiple validation
// errors returned by CreateUtxoSwapRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateUtxoSwapRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUtxoSwapRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUtxoSwapRequestMultiError) AllErrors() []error { return m }

// CreateUtxoSwapRequestValidationError is the validation error returned by
// CreateUtxoSwapRequest.Validate if the designated constraints aren't met.
type CreateUtxoSwapRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUtxoSwapRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUtxoSwapRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUtxoSwapRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUtxoSwapRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUtxoSwapRequestValidationError) ErrorName() string {
	return "CreateUtxoSwapRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateUtxoSwapRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUtxoSwapRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUtxoSwapRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUtxoSwapRequestValidationError{}

// Validate checks the field values on CreateUtxoSwapResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateUtxoSwapResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUtxoSwapResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateUtxoSwapResponseMultiError, or nil if none found.
func (m *CreateUtxoSwapResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUtxoSwapResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UtxoDepositAddress

	if len(errors) > 0 {
		return CreateUtxoSwapResponseMultiError(errors)
	}

	return nil
}

// CreateUtxoSwapResponseMultiError is an error wrapping multiple validation
// errors returned by CreateUtxoSwapResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateUtxoSwapResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUtxoSwapResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUtxoSwapResponseMultiError) AllErrors() []error { return m }

// CreateUtxoSwapResponseValidationError is the validation error returned by
// CreateUtxoSwapResponse.Validate if the designated constraints aren't met.
type CreateUtxoSwapResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUtxoSwapResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUtxoSwapResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUtxoSwapResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUtxoSwapResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUtxoSwapResponseValidationError) ErrorName() string {
	return "CreateUtxoSwapResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateUtxoSwapResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUtxoSwapResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUtxoSwapResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUtxoSwapResponseValidationError{}

// Validate checks the field values on InitiateStaticDepositUtxoSwapRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *InitiateStaticDepositUtxoSwapRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiateStaticDepositUtxoSwapRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// InitiateStaticDepositUtxoSwapRequestMultiError, or nil if none found.
func (m *InitiateStaticDepositUtxoSwapRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiateStaticDepositUtxoSwapRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOnChainUtxo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiateStaticDepositUtxoSwapRequestValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiateStaticDepositUtxoSwapRequestValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOnChainUtxo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiateStaticDepositUtxoSwapRequestValidationError{
				field:  "OnChainUtxo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SspSignature

	// no validation rules for UserSignature

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiateStaticDepositUtxoSwapRequestValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiateStaticDepositUtxoSwapRequestValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiateStaticDepositUtxoSwapRequestValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSpendTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiateStaticDepositUtxoSwapRequestValidationError{
					field:  "SpendTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiateStaticDepositUtxoSwapRequestValidationError{
					field:  "SpendTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpendTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiateStaticDepositUtxoSwapRequestValidationError{
				field:  "SpendTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InitiateStaticDepositUtxoSwapRequestMultiError(errors)
	}

	return nil
}

// InitiateStaticDepositUtxoSwapRequestMultiError is an error wrapping multiple
// validation errors returned by
// InitiateStaticDepositUtxoSwapRequest.ValidateAll() if the designated
// constraints aren't met.
type InitiateStaticDepositUtxoSwapRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiateStaticDepositUtxoSwapRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiateStaticDepositUtxoSwapRequestMultiError) AllErrors() []error { return m }

// InitiateStaticDepositUtxoSwapRequestValidationError is the validation error
// returned by InitiateStaticDepositUtxoSwapRequest.Validate if the designated
// constraints aren't met.
type InitiateStaticDepositUtxoSwapRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiateStaticDepositUtxoSwapRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiateStaticDepositUtxoSwapRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiateStaticDepositUtxoSwapRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiateStaticDepositUtxoSwapRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiateStaticDepositUtxoSwapRequestValidationError) ErrorName() string {
	return "InitiateStaticDepositUtxoSwapRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InitiateStaticDepositUtxoSwapRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiateStaticDepositUtxoSwapRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiateStaticDepositUtxoSwapRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiateStaticDepositUtxoSwapRequestValidationError{}

// Validate checks the field values on CreateStaticDepositUtxoSwapRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateStaticDepositUtxoSwapRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateStaticDepositUtxoSwapRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateStaticDepositUtxoSwapRequestMultiError, or nil if none found.
func (m *CreateStaticDepositUtxoSwapRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateStaticDepositUtxoSwapRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateStaticDepositUtxoSwapRequestValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateStaticDepositUtxoSwapRequestValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateStaticDepositUtxoSwapRequestValidationError{
				field:  "Request",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Signature

	// no validation rules for CoordinatorPublicKey

	if len(errors) > 0 {
		return CreateStaticDepositUtxoSwapRequestMultiError(errors)
	}

	return nil
}

// CreateStaticDepositUtxoSwapRequestMultiError is an error wrapping multiple
// validation errors returned by
// CreateStaticDepositUtxoSwapRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateStaticDepositUtxoSwapRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateStaticDepositUtxoSwapRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateStaticDepositUtxoSwapRequestMultiError) AllErrors() []error { return m }

// CreateStaticDepositUtxoSwapRequestValidationError is the validation error
// returned by CreateStaticDepositUtxoSwapRequest.Validate if the designated
// constraints aren't met.
type CreateStaticDepositUtxoSwapRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateStaticDepositUtxoSwapRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateStaticDepositUtxoSwapRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateStaticDepositUtxoSwapRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateStaticDepositUtxoSwapRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateStaticDepositUtxoSwapRequestValidationError) ErrorName() string {
	return "CreateStaticDepositUtxoSwapRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateStaticDepositUtxoSwapRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateStaticDepositUtxoSwapRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateStaticDepositUtxoSwapRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateStaticDepositUtxoSwapRequestValidationError{}

// Validate checks the field values on CreateStaticDepositUtxoSwapResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateStaticDepositUtxoSwapResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateStaticDepositUtxoSwapResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateStaticDepositUtxoSwapResponseMultiError, or nil if none found.
func (m *CreateStaticDepositUtxoSwapResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateStaticDepositUtxoSwapResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UtxoDepositAddress

	if len(errors) > 0 {
		return CreateStaticDepositUtxoSwapResponseMultiError(errors)
	}

	return nil
}

// CreateStaticDepositUtxoSwapResponseMultiError is an error wrapping multiple
// validation errors returned by
// CreateStaticDepositUtxoSwapResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateStaticDepositUtxoSwapResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateStaticDepositUtxoSwapResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateStaticDepositUtxoSwapResponseMultiError) AllErrors() []error { return m }

// CreateStaticDepositUtxoSwapResponseValidationError is the validation error
// returned by CreateStaticDepositUtxoSwapResponse.Validate if the designated
// constraints aren't met.
type CreateStaticDepositUtxoSwapResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateStaticDepositUtxoSwapResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateStaticDepositUtxoSwapResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateStaticDepositUtxoSwapResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateStaticDepositUtxoSwapResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateStaticDepositUtxoSwapResponseValidationError) ErrorName() string {
	return "CreateStaticDepositUtxoSwapResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateStaticDepositUtxoSwapResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateStaticDepositUtxoSwapResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateStaticDepositUtxoSwapResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateStaticDepositUtxoSwapResponseValidationError{}

// Validate checks the field values on CreateStaticDepositUtxoRefundRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateStaticDepositUtxoRefundRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateStaticDepositUtxoRefundRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateStaticDepositUtxoRefundRequestMultiError, or nil if none found.
func (m *CreateStaticDepositUtxoRefundRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateStaticDepositUtxoRefundRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateStaticDepositUtxoRefundRequestValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateStaticDepositUtxoRefundRequestValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateStaticDepositUtxoRefundRequestValidationError{
				field:  "Request",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Signature

	// no validation rules for CoordinatorPublicKey

	if len(errors) > 0 {
		return CreateStaticDepositUtxoRefundRequestMultiError(errors)
	}

	return nil
}

// CreateStaticDepositUtxoRefundRequestMultiError is an error wrapping multiple
// validation errors returned by
// CreateStaticDepositUtxoRefundRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateStaticDepositUtxoRefundRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateStaticDepositUtxoRefundRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateStaticDepositUtxoRefundRequestMultiError) AllErrors() []error { return m }

// CreateStaticDepositUtxoRefundRequestValidationError is the validation error
// returned by CreateStaticDepositUtxoRefundRequest.Validate if the designated
// constraints aren't met.
type CreateStaticDepositUtxoRefundRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateStaticDepositUtxoRefundRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateStaticDepositUtxoRefundRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateStaticDepositUtxoRefundRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateStaticDepositUtxoRefundRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateStaticDepositUtxoRefundRequestValidationError) ErrorName() string {
	return "CreateStaticDepositUtxoRefundRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateStaticDepositUtxoRefundRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateStaticDepositUtxoRefundRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateStaticDepositUtxoRefundRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateStaticDepositUtxoRefundRequestValidationError{}

// Validate checks the field values on CreateStaticDepositUtxoRefundResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateStaticDepositUtxoRefundResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateStaticDepositUtxoRefundResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateStaticDepositUtxoRefundResponseMultiError, or nil if none found.
func (m *CreateStaticDepositUtxoRefundResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateStaticDepositUtxoRefundResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UtxoDepositAddress

	if len(errors) > 0 {
		return CreateStaticDepositUtxoRefundResponseMultiError(errors)
	}

	return nil
}

// CreateStaticDepositUtxoRefundResponseMultiError is an error wrapping
// multiple validation errors returned by
// CreateStaticDepositUtxoRefundResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateStaticDepositUtxoRefundResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateStaticDepositUtxoRefundResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateStaticDepositUtxoRefundResponseMultiError) AllErrors() []error { return m }

// CreateStaticDepositUtxoRefundResponseValidationError is the validation error
// returned by CreateStaticDepositUtxoRefundResponse.Validate if the
// designated constraints aren't met.
type CreateStaticDepositUtxoRefundResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateStaticDepositUtxoRefundResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateStaticDepositUtxoRefundResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateStaticDepositUtxoRefundResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateStaticDepositUtxoRefundResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateStaticDepositUtxoRefundResponseValidationError) ErrorName() string {
	return "CreateStaticDepositUtxoRefundResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateStaticDepositUtxoRefundResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateStaticDepositUtxoRefundResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateStaticDepositUtxoRefundResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateStaticDepositUtxoRefundResponseValidationError{}

// Validate checks the field values on RollbackUtxoSwapRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RollbackUtxoSwapRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RollbackUtxoSwapRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RollbackUtxoSwapRequestMultiError, or nil if none found.
func (m *RollbackUtxoSwapRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RollbackUtxoSwapRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOnChainUtxo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RollbackUtxoSwapRequestValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RollbackUtxoSwapRequestValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOnChainUtxo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RollbackUtxoSwapRequestValidationError{
				field:  "OnChainUtxo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Signature

	// no validation rules for CoordinatorPublicKey

	if len(errors) > 0 {
		return RollbackUtxoSwapRequestMultiError(errors)
	}

	return nil
}

// RollbackUtxoSwapRequestMultiError is an error wrapping multiple validation
// errors returned by RollbackUtxoSwapRequest.ValidateAll() if the designated
// constraints aren't met.
type RollbackUtxoSwapRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RollbackUtxoSwapRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RollbackUtxoSwapRequestMultiError) AllErrors() []error { return m }

// RollbackUtxoSwapRequestValidationError is the validation error returned by
// RollbackUtxoSwapRequest.Validate if the designated constraints aren't met.
type RollbackUtxoSwapRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RollbackUtxoSwapRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RollbackUtxoSwapRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RollbackUtxoSwapRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RollbackUtxoSwapRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RollbackUtxoSwapRequestValidationError) ErrorName() string {
	return "RollbackUtxoSwapRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RollbackUtxoSwapRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRollbackUtxoSwapRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RollbackUtxoSwapRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RollbackUtxoSwapRequestValidationError{}

// Validate checks the field values on RollbackUtxoSwapResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RollbackUtxoSwapResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RollbackUtxoSwapResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RollbackUtxoSwapResponseMultiError, or nil if none found.
func (m *RollbackUtxoSwapResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RollbackUtxoSwapResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RollbackUtxoSwapResponseMultiError(errors)
	}

	return nil
}

// RollbackUtxoSwapResponseMultiError is an error wrapping multiple validation
// errors returned by RollbackUtxoSwapResponse.ValidateAll() if the designated
// constraints aren't met.
type RollbackUtxoSwapResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RollbackUtxoSwapResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RollbackUtxoSwapResponseMultiError) AllErrors() []error { return m }

// RollbackUtxoSwapResponseValidationError is the validation error returned by
// RollbackUtxoSwapResponse.Validate if the designated constraints aren't met.
type RollbackUtxoSwapResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RollbackUtxoSwapResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RollbackUtxoSwapResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RollbackUtxoSwapResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RollbackUtxoSwapResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RollbackUtxoSwapResponseValidationError) ErrorName() string {
	return "RollbackUtxoSwapResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RollbackUtxoSwapResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRollbackUtxoSwapResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RollbackUtxoSwapResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RollbackUtxoSwapResponseValidationError{}

// Validate checks the field values on UtxoSwapCompletedRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UtxoSwapCompletedRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UtxoSwapCompletedRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UtxoSwapCompletedRequestMultiError, or nil if none found.
func (m *UtxoSwapCompletedRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UtxoSwapCompletedRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOnChainUtxo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UtxoSwapCompletedRequestValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UtxoSwapCompletedRequestValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOnChainUtxo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UtxoSwapCompletedRequestValidationError{
				field:  "OnChainUtxo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Signature

	// no validation rules for CoordinatorPublicKey

	if len(errors) > 0 {
		return UtxoSwapCompletedRequestMultiError(errors)
	}

	return nil
}

// UtxoSwapCompletedRequestMultiError is an error wrapping multiple validation
// errors returned by UtxoSwapCompletedRequest.ValidateAll() if the designated
// constraints aren't met.
type UtxoSwapCompletedRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UtxoSwapCompletedRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UtxoSwapCompletedRequestMultiError) AllErrors() []error { return m }

// UtxoSwapCompletedRequestValidationError is the validation error returned by
// UtxoSwapCompletedRequest.Validate if the designated constraints aren't met.
type UtxoSwapCompletedRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UtxoSwapCompletedRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UtxoSwapCompletedRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UtxoSwapCompletedRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UtxoSwapCompletedRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UtxoSwapCompletedRequestValidationError) ErrorName() string {
	return "UtxoSwapCompletedRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UtxoSwapCompletedRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUtxoSwapCompletedRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UtxoSwapCompletedRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UtxoSwapCompletedRequestValidationError{}

// Validate checks the field values on UtxoSwapCompletedResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UtxoSwapCompletedResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UtxoSwapCompletedResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UtxoSwapCompletedResponseMultiError, or nil if none found.
func (m *UtxoSwapCompletedResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UtxoSwapCompletedResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UtxoSwapCompletedResponseMultiError(errors)
	}

	return nil
}

// UtxoSwapCompletedResponseMultiError is an error wrapping multiple validation
// errors returned by UtxoSwapCompletedResponse.ValidateAll() if the
// designated constraints aren't met.
type UtxoSwapCompletedResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UtxoSwapCompletedResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UtxoSwapCompletedResponseMultiError) AllErrors() []error { return m }

// UtxoSwapCompletedResponseValidationError is the validation error returned by
// UtxoSwapCompletedResponse.Validate if the designated constraints aren't met.
type UtxoSwapCompletedResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UtxoSwapCompletedResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UtxoSwapCompletedResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UtxoSwapCompletedResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UtxoSwapCompletedResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UtxoSwapCompletedResponseValidationError) ErrorName() string {
	return "UtxoSwapCompletedResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UtxoSwapCompletedResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUtxoSwapCompletedResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UtxoSwapCompletedResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UtxoSwapCompletedResponseValidationError{}

// Validate checks the field values on
// CancelOrFinalizeExpiredTokenTransactionRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CancelOrFinalizeExpiredTokenTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CancelOrFinalizeExpiredTokenTransactionRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// CancelOrFinalizeExpiredTokenTransactionRequestMultiError, or nil if none found.
func (m *CancelOrFinalizeExpiredTokenTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelOrFinalizeExpiredTokenTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFinalTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CancelOrFinalizeExpiredTokenTransactionRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CancelOrFinalizeExpiredTokenTransactionRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CancelOrFinalizeExpiredTokenTransactionRequestValidationError{
				field:  "FinalTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CancelOrFinalizeExpiredTokenTransactionRequestMultiError(errors)
	}

	return nil
}

// CancelOrFinalizeExpiredTokenTransactionRequestMultiError is an error
// wrapping multiple validation errors returned by
// CancelOrFinalizeExpiredTokenTransactionRequest.ValidateAll() if the
// designated constraints aren't met.
type CancelOrFinalizeExpiredTokenTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelOrFinalizeExpiredTokenTransactionRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelOrFinalizeExpiredTokenTransactionRequestMultiError) AllErrors() []error { return m }

// CancelOrFinalizeExpiredTokenTransactionRequestValidationError is the
// validation error returned by
// CancelOrFinalizeExpiredTokenTransactionRequest.Validate if the designated
// constraints aren't met.
type CancelOrFinalizeExpiredTokenTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelOrFinalizeExpiredTokenTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelOrFinalizeExpiredTokenTransactionRequestValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CancelOrFinalizeExpiredTokenTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelOrFinalizeExpiredTokenTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelOrFinalizeExpiredTokenTransactionRequestValidationError) ErrorName() string {
	return "CancelOrFinalizeExpiredTokenTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CancelOrFinalizeExpiredTokenTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelOrFinalizeExpiredTokenTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelOrFinalizeExpiredTokenTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelOrFinalizeExpiredTokenTransactionRequestValidationError{}

// Validate checks the field values on QueryLeafSigningPubkeysRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryLeafSigningPubkeysRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryLeafSigningPubkeysRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// QueryLeafSigningPubkeysRequestMultiError, or nil if none found.
func (m *QueryLeafSigningPubkeysRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryLeafSigningPubkeysRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return QueryLeafSigningPubkeysRequestMultiError(errors)
	}

	return nil
}

// QueryLeafSigningPubkeysRequestMultiError is an error wrapping multiple
// validation errors returned by QueryLeafSigningPubkeysRequest.ValidateAll()
// if the designated constraints aren't met.
type QueryLeafSigningPubkeysRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryLeafSigningPubkeysRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryLeafSigningPubkeysRequestMultiError) AllErrors() []error { return m }

// QueryLeafSigningPubkeysRequestValidationError is the validation error
// returned by QueryLeafSigningPubkeysRequest.Validate if the designated
// constraints aren't met.
type QueryLeafSigningPubkeysRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryLeafSigningPubkeysRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryLeafSigningPubkeysRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryLeafSigningPubkeysRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryLeafSigningPubkeysRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryLeafSigningPubkeysRequestValidationError) ErrorName() string {
	return "QueryLeafSigningPubkeysRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryLeafSigningPubkeysRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryLeafSigningPubkeysRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryLeafSigningPubkeysRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryLeafSigningPubkeysRequestValidationError{}

// Validate checks the field values on QueryLeafSigningPubkeysResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryLeafSigningPubkeysResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryLeafSigningPubkeysResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// QueryLeafSigningPubkeysResponseMultiError, or nil if none found.
func (m *QueryLeafSigningPubkeysResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryLeafSigningPubkeysResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SigningPubkeys

	if len(errors) > 0 {
		return QueryLeafSigningPubkeysResponseMultiError(errors)
	}

	return nil
}

// QueryLeafSigningPubkeysResponseMultiError is an error wrapping multiple
// validation errors returned by QueryLeafSigningPubkeysResponse.ValidateAll()
// if the designated constraints aren't met.
type QueryLeafSigningPubkeysResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryLeafSigningPubkeysResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryLeafSigningPubkeysResponseMultiError) AllErrors() []error { return m }

// QueryLeafSigningPubkeysResponseValidationError is the validation error
// returned by QueryLeafSigningPubkeysResponse.Validate if the designated
// constraints aren't met.
type QueryLeafSigningPubkeysResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryLeafSigningPubkeysResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryLeafSigningPubkeysResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryLeafSigningPubkeysResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryLeafSigningPubkeysResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryLeafSigningPubkeysResponseValidationError) ErrorName() string {
	return "QueryLeafSigningPubkeysResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryLeafSigningPubkeysResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryLeafSigningPubkeysResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryLeafSigningPubkeysResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryLeafSigningPubkeysResponseValidationError{}

// Validate checks the field values on ResolveLeafInvestigationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResolveLeafInvestigationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResolveLeafInvestigationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ResolveLeafInvestigationRequestMultiError, or nil if none found.
func (m *ResolveLeafInvestigationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ResolveLeafInvestigationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ResolveLeafInvestigationRequestMultiError(errors)
	}

	return nil
}

// ResolveLeafInvestigationRequestMultiError is an error wrapping multiple
// validation errors returned by ResolveLeafInvestigationRequest.ValidateAll()
// if the designated constraints aren't met.
type ResolveLeafInvestigationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResolveLeafInvestigationRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResolveLeafInvestigationRequestMultiError) AllErrors() []error { return m }

// ResolveLeafInvestigationRequestValidationError is the validation error
// returned by ResolveLeafInvestigationRequest.Validate if the designated
// constraints aren't met.
type ResolveLeafInvestigationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResolveLeafInvestigationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResolveLeafInvestigationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResolveLeafInvestigationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResolveLeafInvestigationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResolveLeafInvestigationRequestValidationError) ErrorName() string {
	return "ResolveLeafInvestigationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ResolveLeafInvestigationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResolveLeafInvestigationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResolveLeafInvestigationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResolveLeafInvestigationRequestValidationError{}

// Validate checks the field values on ProvidePreimageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProvidePreimageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProvidePreimageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProvidePreimageRequestMultiError, or nil if none found.
func (m *ProvidePreimageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProvidePreimageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaymentHash

	// no validation rules for Preimage

	// no validation rules for IdentityPublicKey

	{
		sorted_keys := make([]string, len(m.GetKeyTweakProofs()))
		i := 0
		for key := range m.GetKeyTweakProofs() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetKeyTweakProofs()[key]
			_ = val

			// no validation rules for KeyTweakProofs[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ProvidePreimageRequestValidationError{
							field:  fmt.Sprintf("KeyTweakProofs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ProvidePreimageRequestValidationError{
							field:  fmt.Sprintf("KeyTweakProofs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ProvidePreimageRequestValidationError{
						field:  fmt.Sprintf("KeyTweakProofs[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return ProvidePreimageRequestMultiError(errors)
	}

	return nil
}

// ProvidePreimageRequestMultiError is an error wrapping multiple validation
// errors returned by ProvidePreimageRequest.ValidateAll() if the designated
// constraints aren't met.
type ProvidePreimageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProvidePreimageRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProvidePreimageRequestMultiError) AllErrors() []error { return m }

// ProvidePreimageRequestValidationError is the validation error returned by
// ProvidePreimageRequest.Validate if the designated constraints aren't met.
type ProvidePreimageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProvidePreimageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProvidePreimageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProvidePreimageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProvidePreimageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProvidePreimageRequestValidationError) ErrorName() string {
	return "ProvidePreimageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProvidePreimageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProvidePreimageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProvidePreimageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProvidePreimageRequestValidationError{}

// Validate checks the field values on ReserveEntityDkgKeyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReserveEntityDkgKeyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReserveEntityDkgKeyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReserveEntityDkgKeyRequestMultiError, or nil if none found.
func (m *ReserveEntityDkgKeyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReserveEntityDkgKeyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for KeyshareId

	if len(errors) > 0 {
		return ReserveEntityDkgKeyRequestMultiError(errors)
	}

	return nil
}

// ReserveEntityDkgKeyRequestMultiError is an error wrapping multiple
// validation errors returned by ReserveEntityDkgKeyRequest.ValidateAll() if
// the designated constraints aren't met.
type ReserveEntityDkgKeyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReserveEntityDkgKeyRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReserveEntityDkgKeyRequestMultiError) AllErrors() []error { return m }

// ReserveEntityDkgKeyRequestValidationError is the validation error returned
// by ReserveEntityDkgKeyRequest.Validate if the designated constraints aren't met.
type ReserveEntityDkgKeyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReserveEntityDkgKeyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReserveEntityDkgKeyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReserveEntityDkgKeyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReserveEntityDkgKeyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReserveEntityDkgKeyRequestValidationError) ErrorName() string {
	return "ReserveEntityDkgKeyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReserveEntityDkgKeyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReserveEntityDkgKeyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReserveEntityDkgKeyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReserveEntityDkgKeyRequestValidationError{}

// Validate checks the field values on FixKeyshareRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FixKeyshareRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FixKeyshareRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FixKeyshareRequestMultiError, or nil if none found.
func (m *FixKeyshareRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FixKeyshareRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BadKeyshareId

	// no validation rules for BadOperatorId

	if len(errors) > 0 {
		return FixKeyshareRequestMultiError(errors)
	}

	return nil
}

// FixKeyshareRequestMultiError is an error wrapping multiple validation errors
// returned by FixKeyshareRequest.ValidateAll() if the designated constraints
// aren't met.
type FixKeyshareRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FixKeyshareRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FixKeyshareRequestMultiError) AllErrors() []error { return m }

// FixKeyshareRequestValidationError is the validation error returned by
// FixKeyshareRequest.Validate if the designated constraints aren't met.
type FixKeyshareRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FixKeyshareRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FixKeyshareRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FixKeyshareRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FixKeyshareRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FixKeyshareRequestValidationError) ErrorName() string {
	return "FixKeyshareRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FixKeyshareRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFixKeyshareRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FixKeyshareRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FixKeyshareRequestValidationError{}

// Validate checks the field values on FixKeyshareRound1Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FixKeyshareRound1Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FixKeyshareRound1Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FixKeyshareRound1RequestMultiError, or nil if none found.
func (m *FixKeyshareRound1Request) ValidateAll() error {
	return m.validate(true)
}

func (m *FixKeyshareRound1Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BadKeyshareId

	// no validation rules for BadOperatorId

	if len(errors) > 0 {
		return FixKeyshareRound1RequestMultiError(errors)
	}

	return nil
}

// FixKeyshareRound1RequestMultiError is an error wrapping multiple validation
// errors returned by FixKeyshareRound1Request.ValidateAll() if the designated
// constraints aren't met.
type FixKeyshareRound1RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FixKeyshareRound1RequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FixKeyshareRound1RequestMultiError) AllErrors() []error { return m }

// FixKeyshareRound1RequestValidationError is the validation error returned by
// FixKeyshareRound1Request.Validate if the designated constraints aren't met.
type FixKeyshareRound1RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FixKeyshareRound1RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FixKeyshareRound1RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FixKeyshareRound1RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FixKeyshareRound1RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FixKeyshareRound1RequestValidationError) ErrorName() string {
	return "FixKeyshareRound1RequestValidationError"
}

// Error satisfies the builtin error interface
func (e FixKeyshareRound1RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFixKeyshareRound1Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FixKeyshareRound1RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FixKeyshareRound1RequestValidationError{}

// Validate checks the field values on FixKeyshareRound1Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FixKeyshareRound1Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FixKeyshareRound1Response with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FixKeyshareRound1ResponseMultiError, or nil if none found.
func (m *FixKeyshareRound1Response) ValidateAll() error {
	return m.validate(true)
}

func (m *FixKeyshareRound1Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return FixKeyshareRound1ResponseMultiError(errors)
	}

	return nil
}

// FixKeyshareRound1ResponseMultiError is an error wrapping multiple validation
// errors returned by FixKeyshareRound1Response.ValidateAll() if the
// designated constraints aren't met.
type FixKeyshareRound1ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FixKeyshareRound1ResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FixKeyshareRound1ResponseMultiError) AllErrors() []error { return m }

// FixKeyshareRound1ResponseValidationError is the validation error returned by
// FixKeyshareRound1Response.Validate if the designated constraints aren't met.
type FixKeyshareRound1ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FixKeyshareRound1ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FixKeyshareRound1ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FixKeyshareRound1ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FixKeyshareRound1ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FixKeyshareRound1ResponseValidationError) ErrorName() string {
	return "FixKeyshareRound1ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FixKeyshareRound1ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFixKeyshareRound1Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FixKeyshareRound1ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FixKeyshareRound1ResponseValidationError{}

// Validate checks the field values on FixKeyshareRound2Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FixKeyshareRound2Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FixKeyshareRound2Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FixKeyshareRound2RequestMultiError, or nil if none found.
func (m *FixKeyshareRound2Request) ValidateAll() error {
	return m.validate(true)
}

func (m *FixKeyshareRound2Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BadKeyshareId

	// no validation rules for BadOperatorId

	if len(errors) > 0 {
		return FixKeyshareRound2RequestMultiError(errors)
	}

	return nil
}

// FixKeyshareRound2RequestMultiError is an error wrapping multiple validation
// errors returned by FixKeyshareRound2Request.ValidateAll() if the designated
// constraints aren't met.
type FixKeyshareRound2RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FixKeyshareRound2RequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FixKeyshareRound2RequestMultiError) AllErrors() []error { return m }

// FixKeyshareRound2RequestValidationError is the validation error returned by
// FixKeyshareRound2Request.Validate if the designated constraints aren't met.
type FixKeyshareRound2RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FixKeyshareRound2RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FixKeyshareRound2RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FixKeyshareRound2RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FixKeyshareRound2RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FixKeyshareRound2RequestValidationError) ErrorName() string {
	return "FixKeyshareRound2RequestValidationError"
}

// Error satisfies the builtin error interface
func (e FixKeyshareRound2RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFixKeyshareRound2Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FixKeyshareRound2RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FixKeyshareRound2RequestValidationError{}

// Validate checks the field values on FixKeyshareRound2Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FixKeyshareRound2Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FixKeyshareRound2Response with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FixKeyshareRound2ResponseMultiError, or nil if none found.
func (m *FixKeyshareRound2Response) ValidateAll() error {
	return m.validate(true)
}

func (m *FixKeyshareRound2Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return FixKeyshareRound2ResponseMultiError(errors)
	}

	return nil
}

// FixKeyshareRound2ResponseMultiError is an error wrapping multiple validation
// errors returned by FixKeyshareRound2Response.ValidateAll() if the
// designated constraints aren't met.
type FixKeyshareRound2ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FixKeyshareRound2ResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FixKeyshareRound2ResponseMultiError) AllErrors() []error { return m }

// FixKeyshareRound2ResponseValidationError is the validation error returned by
// FixKeyshareRound2Response.Validate if the designated constraints aren't met.
type FixKeyshareRound2ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FixKeyshareRound2ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FixKeyshareRound2ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FixKeyshareRound2ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FixKeyshareRound2ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FixKeyshareRound2ResponseValidationError) ErrorName() string {
	return "FixKeyshareRound2ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FixKeyshareRound2ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFixKeyshareRound2Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FixKeyshareRound2ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FixKeyshareRound2ResponseValidationError{}

// Validate checks the field values on GetTransfersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransfersRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransfersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransfersRequestMultiError, or nil if none found.
func (m *GetTransfersRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransfersRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetTransfersRequestMultiError(errors)
	}

	return nil
}

// GetTransfersRequestMultiError is an error wrapping multiple validation
// errors returned by GetTransfersRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTransfersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransfersRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransfersRequestMultiError) AllErrors() []error { return m }

// GetTransfersRequestValidationError is the validation error returned by
// GetTransfersRequest.Validate if the designated constraints aren't met.
type GetTransfersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransfersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransfersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransfersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransfersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransfersRequestValidationError) ErrorName() string {
	return "GetTransfersRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransfersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransfersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransfersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransfersRequestValidationError{}

// Validate checks the field values on GetTransfersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransfersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransfersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransfersResponseMultiError, or nil if none found.
func (m *GetTransfersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransfersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransfers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTransfersResponseValidationError{
						field:  fmt.Sprintf("Transfers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTransfersResponseValidationError{
						field:  fmt.Sprintf("Transfers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTransfersResponseValidationError{
					field:  fmt.Sprintf("Transfers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetTransfersResponseMultiError(errors)
	}

	return nil
}

// GetTransfersResponseMultiError is an error wrapping multiple validation
// errors returned by GetTransfersResponse.ValidateAll() if the designated
// constraints aren't met.
type GetTransfersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransfersResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransfersResponseMultiError) AllErrors() []error { return m }

// GetTransfersResponseValidationError is the validation error returned by
// GetTransfersResponse.Validate if the designated constraints aren't met.
type GetTransfersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransfersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransfersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransfersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransfersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransfersResponseValidationError) ErrorName() string {
	return "GetTransfersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransfersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransfersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransfersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransfersResponseValidationError{}

// Validate checks the field values on
// GenerateStaticDepositAddressProofsRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GenerateStaticDepositAddressProofsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GenerateStaticDepositAddressProofsRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GenerateStaticDepositAddressProofsRequestMultiError, or nil if none found.
func (m *GenerateStaticDepositAddressProofsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateStaticDepositAddressProofsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for KeyshareId

	// no validation rules for Address

	// no validation rules for OwnerIdentityPublicKey

	if len(errors) > 0 {
		return GenerateStaticDepositAddressProofsRequestMultiError(errors)
	}

	return nil
}

// GenerateStaticDepositAddressProofsRequestMultiError is an error wrapping
// multiple validation errors returned by
// GenerateStaticDepositAddressProofsRequest.ValidateAll() if the designated
// constraints aren't met.
type GenerateStaticDepositAddressProofsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateStaticDepositAddressProofsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateStaticDepositAddressProofsRequestMultiError) AllErrors() []error { return m }

// GenerateStaticDepositAddressProofsRequestValidationError is the validation
// error returned by GenerateStaticDepositAddressProofsRequest.Validate if the
// designated constraints aren't met.
type GenerateStaticDepositAddressProofsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateStaticDepositAddressProofsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateStaticDepositAddressProofsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateStaticDepositAddressProofsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateStaticDepositAddressProofsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateStaticDepositAddressProofsRequestValidationError) ErrorName() string {
	return "GenerateStaticDepositAddressProofsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateStaticDepositAddressProofsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateStaticDepositAddressProofsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateStaticDepositAddressProofsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateStaticDepositAddressProofsRequestValidationError{}

// Validate checks the field values on
// GenerateStaticDepositAddressProofsResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GenerateStaticDepositAddressProofsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GenerateStaticDepositAddressProofsResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GenerateStaticDepositAddressProofsResponseMultiError, or nil if none found.
func (m *GenerateStaticDepositAddressProofsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateStaticDepositAddressProofsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AddressSignature

	if len(errors) > 0 {
		return GenerateStaticDepositAddressProofsResponseMultiError(errors)
	}

	return nil
}

// GenerateStaticDepositAddressProofsResponseMultiError is an error wrapping
// multiple validation errors returned by
// GenerateStaticDepositAddressProofsResponse.ValidateAll() if the designated
// constraints aren't met.
type GenerateStaticDepositAddressProofsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateStaticDepositAddressProofsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateStaticDepositAddressProofsResponseMultiError) AllErrors() []error { return m }

// GenerateStaticDepositAddressProofsResponseValidationError is the validation
// error returned by GenerateStaticDepositAddressProofsResponse.Validate if
// the designated constraints aren't met.
type GenerateStaticDepositAddressProofsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateStaticDepositAddressProofsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateStaticDepositAddressProofsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateStaticDepositAddressProofsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateStaticDepositAddressProofsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateStaticDepositAddressProofsResponseValidationError) ErrorName() string {
	return "GenerateStaticDepositAddressProofsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateStaticDepositAddressProofsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateStaticDepositAddressProofsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateStaticDepositAddressProofsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateStaticDepositAddressProofsResponseValidationError{}
