// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: spark.proto

package spark

import (
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	common "github.com/lightsparkdev/spark/proto/common"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// *
// Network is the network type of the bitcoin network.
type Network int32

const (
	Network_UNSPECIFIED Network = 0
	Network_MAINNET     Network = 1
	Network_REGTEST     Network = 2
	Network_TESTNET     Network = 3
	Network_SIGNET      Network = 4
)

// Enum value maps for Network.
var (
	Network_name = map[int32]string{
		0: "UNSPECIFIED",
		1: "MAINNET",
		2: "REGTEST",
		3: "TESTNET",
		4: "SIGNET",
	}
	Network_value = map[string]int32{
		"UNSPECIFIED": 0,
		"MAINNET":     1,
		"REGTEST":     2,
		"TESTNET":     3,
		"SIGNET":      4,
	}
)

func (x Network) Enum() *Network {
	p := new(Network)
	*p = x
	return p
}

func (x Network) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Network) Descriptor() protoreflect.EnumDescriptor {
	return file_spark_proto_enumTypes[0].Descriptor()
}

func (Network) Type() protoreflect.EnumType {
	return &file_spark_proto_enumTypes[0]
}

func (x Network) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Network.Descriptor instead.
func (Network) EnumDescriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{0}
}

type Direction int32

const (
	Direction_NEXT     Direction = 0
	Direction_PREVIOUS Direction = 1
)

// Enum value maps for Direction.
var (
	Direction_name = map[int32]string{
		0: "NEXT",
		1: "PREVIOUS",
	}
	Direction_value = map[string]int32{
		"NEXT":     0,
		"PREVIOUS": 1,
	}
)

func (x Direction) Enum() *Direction {
	p := new(Direction)
	*p = x
	return p
}

func (x Direction) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Direction) Descriptor() protoreflect.EnumDescriptor {
	return file_spark_proto_enumTypes[1].Descriptor()
}

func (Direction) Type() protoreflect.EnumType {
	return &file_spark_proto_enumTypes[1]
}

func (x Direction) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Direction.Descriptor instead.
func (Direction) EnumDescriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{1}
}

type TokenTransactionStatus int32

const (
	TokenTransactionStatus_TOKEN_TRANSACTION_STARTED           TokenTransactionStatus = 0
	TokenTransactionStatus_TOKEN_TRANSACTION_SIGNED            TokenTransactionStatus = 1
	TokenTransactionStatus_TOKEN_TRANSACTION_REVEALED          TokenTransactionStatus = 5
	TokenTransactionStatus_TOKEN_TRANSACTION_FINALIZED         TokenTransactionStatus = 2
	TokenTransactionStatus_TOKEN_TRANSACTION_STARTED_CANCELLED TokenTransactionStatus = 3
	TokenTransactionStatus_TOKEN_TRANSACTION_SIGNED_CANCELLED  TokenTransactionStatus = 4
	TokenTransactionStatus_TOKEN_TRANSACTION_UNKNOWN           TokenTransactionStatus = 10
)

// Enum value maps for TokenTransactionStatus.
var (
	TokenTransactionStatus_name = map[int32]string{
		0:  "TOKEN_TRANSACTION_STARTED",
		1:  "TOKEN_TRANSACTION_SIGNED",
		5:  "TOKEN_TRANSACTION_REVEALED",
		2:  "TOKEN_TRANSACTION_FINALIZED",
		3:  "TOKEN_TRANSACTION_STARTED_CANCELLED",
		4:  "TOKEN_TRANSACTION_SIGNED_CANCELLED",
		10: "TOKEN_TRANSACTION_UNKNOWN",
	}
	TokenTransactionStatus_value = map[string]int32{
		"TOKEN_TRANSACTION_STARTED":           0,
		"TOKEN_TRANSACTION_SIGNED":            1,
		"TOKEN_TRANSACTION_REVEALED":          5,
		"TOKEN_TRANSACTION_FINALIZED":         2,
		"TOKEN_TRANSACTION_STARTED_CANCELLED": 3,
		"TOKEN_TRANSACTION_SIGNED_CANCELLED":  4,
		"TOKEN_TRANSACTION_UNKNOWN":           10,
	}
)

func (x TokenTransactionStatus) Enum() *TokenTransactionStatus {
	p := new(TokenTransactionStatus)
	*p = x
	return p
}

func (x TokenTransactionStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TokenTransactionStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_spark_proto_enumTypes[2].Descriptor()
}

func (TokenTransactionStatus) Type() protoreflect.EnumType {
	return &file_spark_proto_enumTypes[2]
}

func (x TokenTransactionStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TokenTransactionStatus.Descriptor instead.
func (TokenTransactionStatus) EnumDescriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{2}
}

type TransferStatus int32

const (
	TransferStatus_TRANSFER_STATUS_SENDER_INITIATED             TransferStatus = 0
	TransferStatus_TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING     TransferStatus = 1
	TransferStatus_TRANSFER_STATUS_SENDER_KEY_TWEAKED           TransferStatus = 2
	TransferStatus_TRANSFER_STATUS_RECEIVER_KEY_TWEAKED         TransferStatus = 3
	TransferStatus_TRANSFER_STATUS_RECEIVER_REFUND_SIGNED       TransferStatus = 4
	TransferStatus_TRANSFER_STATUS_COMPLETED                    TransferStatus = 5
	TransferStatus_TRANSFER_STATUS_EXPIRED                      TransferStatus = 6
	TransferStatus_TRANSFER_STATUS_RETURNED                     TransferStatus = 7
	TransferStatus_TRANSFER_STATUS_SENDER_INITIATED_COORDINATOR TransferStatus = 8
	TransferStatus_TRANSFER_STATUS_RECEIVER_KEY_TWEAK_LOCKED    TransferStatus = 9
	TransferStatus_TRANSFER_STATUS_RECEIVER_KEY_TWEAK_APPLIED   TransferStatus = 10
)

// Enum value maps for TransferStatus.
var (
	TransferStatus_name = map[int32]string{
		0:  "TRANSFER_STATUS_SENDER_INITIATED",
		1:  "TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING",
		2:  "TRANSFER_STATUS_SENDER_KEY_TWEAKED",
		3:  "TRANSFER_STATUS_RECEIVER_KEY_TWEAKED",
		4:  "TRANSFER_STATUS_RECEIVER_REFUND_SIGNED",
		5:  "TRANSFER_STATUS_COMPLETED",
		6:  "TRANSFER_STATUS_EXPIRED",
		7:  "TRANSFER_STATUS_RETURNED",
		8:  "TRANSFER_STATUS_SENDER_INITIATED_COORDINATOR",
		9:  "TRANSFER_STATUS_RECEIVER_KEY_TWEAK_LOCKED",
		10: "TRANSFER_STATUS_RECEIVER_KEY_TWEAK_APPLIED",
	}
	TransferStatus_value = map[string]int32{
		"TRANSFER_STATUS_SENDER_INITIATED":             0,
		"TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING":     1,
		"TRANSFER_STATUS_SENDER_KEY_TWEAKED":           2,
		"TRANSFER_STATUS_RECEIVER_KEY_TWEAKED":         3,
		"TRANSFER_STATUS_RECEIVER_REFUND_SIGNED":       4,
		"TRANSFER_STATUS_COMPLETED":                    5,
		"TRANSFER_STATUS_EXPIRED":                      6,
		"TRANSFER_STATUS_RETURNED":                     7,
		"TRANSFER_STATUS_SENDER_INITIATED_COORDINATOR": 8,
		"TRANSFER_STATUS_RECEIVER_KEY_TWEAK_LOCKED":    9,
		"TRANSFER_STATUS_RECEIVER_KEY_TWEAK_APPLIED":   10,
	}
)

func (x TransferStatus) Enum() *TransferStatus {
	p := new(TransferStatus)
	*p = x
	return p
}

func (x TransferStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TransferStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_spark_proto_enumTypes[3].Descriptor()
}

func (TransferStatus) Type() protoreflect.EnumType {
	return &file_spark_proto_enumTypes[3]
}

func (x TransferStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TransferStatus.Descriptor instead.
func (TransferStatus) EnumDescriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{3}
}

type TransferType int32

const (
	TransferType_PREIMAGE_SWAP    TransferType = 0
	TransferType_COOPERATIVE_EXIT TransferType = 1
	TransferType_TRANSFER         TransferType = 2
	TransferType_UTXO_SWAP        TransferType = 3
	TransferType_SWAP             TransferType = 30
	TransferType_COUNTER_SWAP     TransferType = 40
)

// Enum value maps for TransferType.
var (
	TransferType_name = map[int32]string{
		0:  "PREIMAGE_SWAP",
		1:  "COOPERATIVE_EXIT",
		2:  "TRANSFER",
		3:  "UTXO_SWAP",
		30: "SWAP",
		40: "COUNTER_SWAP",
	}
	TransferType_value = map[string]int32{
		"PREIMAGE_SWAP":    0,
		"COOPERATIVE_EXIT": 1,
		"TRANSFER":         2,
		"UTXO_SWAP":        3,
		"SWAP":             30,
		"COUNTER_SWAP":     40,
	}
)

func (x TransferType) Enum() *TransferType {
	p := new(TransferType)
	*p = x
	return p
}

func (x TransferType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TransferType) Descriptor() protoreflect.EnumDescriptor {
	return file_spark_proto_enumTypes[4].Descriptor()
}

func (TransferType) Type() protoreflect.EnumType {
	return &file_spark_proto_enumTypes[4]
}

func (x TransferType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TransferType.Descriptor instead.
func (TransferType) EnumDescriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{4}
}

type Order int32

const (
	Order_DESCENDING Order = 0
	Order_ASCENDING  Order = 1
)

// Enum value maps for Order.
var (
	Order_name = map[int32]string{
		0: "DESCENDING",
		1: "ASCENDING",
	}
	Order_value = map[string]int32{
		"DESCENDING": 0,
		"ASCENDING":  1,
	}
)

func (x Order) Enum() *Order {
	p := new(Order)
	*p = x
	return p
}

func (x Order) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Order) Descriptor() protoreflect.EnumDescriptor {
	return file_spark_proto_enumTypes[5].Descriptor()
}

func (Order) Type() protoreflect.EnumType {
	return &file_spark_proto_enumTypes[5]
}

func (x Order) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Order.Descriptor instead.
func (Order) EnumDescriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{5}
}

type PreimageRequestStatus int32

const (
	PreimageRequestStatus_PREIMAGE_REQUEST_STATUS_WAITING_FOR_PREIMAGE PreimageRequestStatus = 0
	PreimageRequestStatus_PREIMAGE_REQUEST_STATUS_PREIMAGE_SHARED      PreimageRequestStatus = 1
	PreimageRequestStatus_PREIMAGE_REQUEST_STATUS_RETURNED             PreimageRequestStatus = 2
)

// Enum value maps for PreimageRequestStatus.
var (
	PreimageRequestStatus_name = map[int32]string{
		0: "PREIMAGE_REQUEST_STATUS_WAITING_FOR_PREIMAGE",
		1: "PREIMAGE_REQUEST_STATUS_PREIMAGE_SHARED",
		2: "PREIMAGE_REQUEST_STATUS_RETURNED",
	}
	PreimageRequestStatus_value = map[string]int32{
		"PREIMAGE_REQUEST_STATUS_WAITING_FOR_PREIMAGE": 0,
		"PREIMAGE_REQUEST_STATUS_PREIMAGE_SHARED":      1,
		"PREIMAGE_REQUEST_STATUS_RETURNED":             2,
	}
)

func (x PreimageRequestStatus) Enum() *PreimageRequestStatus {
	p := new(PreimageRequestStatus)
	*p = x
	return p
}

func (x PreimageRequestStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PreimageRequestStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_spark_proto_enumTypes[6].Descriptor()
}

func (PreimageRequestStatus) Type() protoreflect.EnumType {
	return &file_spark_proto_enumTypes[6]
}

func (x PreimageRequestStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PreimageRequestStatus.Descriptor instead.
func (PreimageRequestStatus) EnumDescriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{6}
}

// *
// Static deposit address flow messages
type UtxoSwapRequestType int32

const (
	UtxoSwapRequestType_Fixed  UtxoSwapRequestType = 0
	UtxoSwapRequestType_MaxFee UtxoSwapRequestType = 1
	UtxoSwapRequestType_Refund UtxoSwapRequestType = 2
)

// Enum value maps for UtxoSwapRequestType.
var (
	UtxoSwapRequestType_name = map[int32]string{
		0: "Fixed",
		1: "MaxFee",
		2: "Refund",
	}
	UtxoSwapRequestType_value = map[string]int32{
		"Fixed":  0,
		"MaxFee": 1,
		"Refund": 2,
	}
)

func (x UtxoSwapRequestType) Enum() *UtxoSwapRequestType {
	p := new(UtxoSwapRequestType)
	*p = x
	return p
}

func (x UtxoSwapRequestType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (UtxoSwapRequestType) Descriptor() protoreflect.EnumDescriptor {
	return file_spark_proto_enumTypes[7].Descriptor()
}

func (UtxoSwapRequestType) Type() protoreflect.EnumType {
	return &file_spark_proto_enumTypes[7]
}

func (x UtxoSwapRequestType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use UtxoSwapRequestType.Descriptor instead.
func (UtxoSwapRequestType) EnumDescriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{7}
}

type InvoiceStatus int32

const (
	InvoiceStatus_NOT_FOUND InvoiceStatus = 0
	InvoiceStatus_PENDING   InvoiceStatus = 1
	InvoiceStatus_FINALIZED InvoiceStatus = 2
	InvoiceStatus_RETURNED  InvoiceStatus = 4
)

// Enum value maps for InvoiceStatus.
var (
	InvoiceStatus_name = map[int32]string{
		0: "NOT_FOUND",
		1: "PENDING",
		2: "FINALIZED",
		4: "RETURNED",
	}
	InvoiceStatus_value = map[string]int32{
		"NOT_FOUND": 0,
		"PENDING":   1,
		"FINALIZED": 2,
		"RETURNED":  4,
	}
)

func (x InvoiceStatus) Enum() *InvoiceStatus {
	p := new(InvoiceStatus)
	*p = x
	return p
}

func (x InvoiceStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (InvoiceStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_spark_proto_enumTypes[8].Descriptor()
}

func (InvoiceStatus) Type() protoreflect.EnumType {
	return &file_spark_proto_enumTypes[8]
}

func (x InvoiceStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use InvoiceStatus.Descriptor instead.
func (InvoiceStatus) EnumDescriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{8}
}

type InitiatePreimageSwapRequest_Reason int32

const (
	// The associated lightning service is sending the payment.
	InitiatePreimageSwapRequest_REASON_SEND InitiatePreimageSwapRequest_Reason = 0
	// The associated lightning service is receiving the payment.
	InitiatePreimageSwapRequest_REASON_RECEIVE InitiatePreimageSwapRequest_Reason = 1
)

// Enum value maps for InitiatePreimageSwapRequest_Reason.
var (
	InitiatePreimageSwapRequest_Reason_name = map[int32]string{
		0: "REASON_SEND",
		1: "REASON_RECEIVE",
	}
	InitiatePreimageSwapRequest_Reason_value = map[string]int32{
		"REASON_SEND":    0,
		"REASON_RECEIVE": 1,
	}
)

func (x InitiatePreimageSwapRequest_Reason) Enum() *InitiatePreimageSwapRequest_Reason {
	p := new(InitiatePreimageSwapRequest_Reason)
	*p = x
	return p
}

func (x InitiatePreimageSwapRequest_Reason) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (InitiatePreimageSwapRequest_Reason) Descriptor() protoreflect.EnumDescriptor {
	return file_spark_proto_enumTypes[9].Descriptor()
}

func (InitiatePreimageSwapRequest_Reason) Type() protoreflect.EnumType {
	return &file_spark_proto_enumTypes[9]
}

func (x InitiatePreimageSwapRequest_Reason) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use InitiatePreimageSwapRequest_Reason.Descriptor instead.
func (InitiatePreimageSwapRequest_Reason) EnumDescriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{93, 0}
}

type SubscribeToEventsRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	IdentityPublicKey []byte                 `protobuf:"bytes,10,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *SubscribeToEventsRequest) Reset() {
	*x = SubscribeToEventsRequest{}
	mi := &file_spark_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscribeToEventsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscribeToEventsRequest) ProtoMessage() {}

func (x *SubscribeToEventsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscribeToEventsRequest.ProtoReflect.Descriptor instead.
func (*SubscribeToEventsRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{0}
}

func (x *SubscribeToEventsRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

type SubscribeToEventsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Event:
	//
	//	*SubscribeToEventsResponse_Transfer
	//	*SubscribeToEventsResponse_Deposit
	//	*SubscribeToEventsResponse_Connected
	Event         isSubscribeToEventsResponse_Event `protobuf_oneof:"event"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubscribeToEventsResponse) Reset() {
	*x = SubscribeToEventsResponse{}
	mi := &file_spark_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscribeToEventsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscribeToEventsResponse) ProtoMessage() {}

func (x *SubscribeToEventsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscribeToEventsResponse.ProtoReflect.Descriptor instead.
func (*SubscribeToEventsResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{1}
}

func (x *SubscribeToEventsResponse) GetEvent() isSubscribeToEventsResponse_Event {
	if x != nil {
		return x.Event
	}
	return nil
}

func (x *SubscribeToEventsResponse) GetTransfer() *TransferEvent {
	if x != nil {
		if x, ok := x.Event.(*SubscribeToEventsResponse_Transfer); ok {
			return x.Transfer
		}
	}
	return nil
}

func (x *SubscribeToEventsResponse) GetDeposit() *DepositEvent {
	if x != nil {
		if x, ok := x.Event.(*SubscribeToEventsResponse_Deposit); ok {
			return x.Deposit
		}
	}
	return nil
}

func (x *SubscribeToEventsResponse) GetConnected() *ConnectedEvent {
	if x != nil {
		if x, ok := x.Event.(*SubscribeToEventsResponse_Connected); ok {
			return x.Connected
		}
	}
	return nil
}

type isSubscribeToEventsResponse_Event interface {
	isSubscribeToEventsResponse_Event()
}

type SubscribeToEventsResponse_Transfer struct {
	Transfer *TransferEvent `protobuf:"bytes,1,opt,name=transfer,proto3,oneof"`
}

type SubscribeToEventsResponse_Deposit struct {
	Deposit *DepositEvent `protobuf:"bytes,2,opt,name=deposit,proto3,oneof"`
}

type SubscribeToEventsResponse_Connected struct {
	Connected *ConnectedEvent `protobuf:"bytes,3,opt,name=connected,proto3,oneof"`
}

func (*SubscribeToEventsResponse_Transfer) isSubscribeToEventsResponse_Event() {}

func (*SubscribeToEventsResponse_Deposit) isSubscribeToEventsResponse_Event() {}

func (*SubscribeToEventsResponse_Connected) isSubscribeToEventsResponse_Event() {}

type ConnectedEvent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectedEvent) Reset() {
	*x = ConnectedEvent{}
	mi := &file_spark_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectedEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectedEvent) ProtoMessage() {}

func (x *ConnectedEvent) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectedEvent.ProtoReflect.Descriptor instead.
func (*ConnectedEvent) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{2}
}

type TransferEvent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Transfer      *Transfer              `protobuf:"bytes,10,opt,name=transfer,proto3" json:"transfer,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransferEvent) Reset() {
	*x = TransferEvent{}
	mi := &file_spark_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransferEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransferEvent) ProtoMessage() {}

func (x *TransferEvent) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransferEvent.ProtoReflect.Descriptor instead.
func (*TransferEvent) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{3}
}

func (x *TransferEvent) GetTransfer() *Transfer {
	if x != nil {
		return x.Transfer
	}
	return nil
}

type DepositEvent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Deposit       *TreeNode              `protobuf:"bytes,10,opt,name=deposit,proto3" json:"deposit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DepositEvent) Reset() {
	*x = DepositEvent{}
	mi := &file_spark_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DepositEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DepositEvent) ProtoMessage() {}

func (x *DepositEvent) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DepositEvent.ProtoReflect.Descriptor instead.
func (*DepositEvent) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{4}
}

func (x *DepositEvent) GetDeposit() *TreeNode {
	if x != nil {
		return x.Deposit
	}
	return nil
}

type PageRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PageSize      int32                  `protobuf:"varint,1,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	Cursor        string                 `protobuf:"bytes,2,opt,name=cursor,proto3" json:"cursor,omitempty"`
	Direction     Direction              `protobuf:"varint,3,opt,name=direction,proto3,enum=spark.Direction" json:"direction,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PageRequest) Reset() {
	*x = PageRequest{}
	mi := &file_spark_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PageRequest) ProtoMessage() {}

func (x *PageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PageRequest.ProtoReflect.Descriptor instead.
func (*PageRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{5}
}

func (x *PageRequest) GetPageSize() int32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *PageRequest) GetCursor() string {
	if x != nil {
		return x.Cursor
	}
	return ""
}

func (x *PageRequest) GetDirection() Direction {
	if x != nil {
		return x.Direction
	}
	return Direction_NEXT
}

type PageResponse struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	HasNextPage     bool                   `protobuf:"varint,1,opt,name=has_next_page,json=hasNextPage,proto3" json:"has_next_page,omitempty"`
	HasPreviousPage bool                   `protobuf:"varint,2,opt,name=has_previous_page,json=hasPreviousPage,proto3" json:"has_previous_page,omitempty"`
	NextCursor      string                 `protobuf:"bytes,3,opt,name=next_cursor,json=nextCursor,proto3" json:"next_cursor,omitempty"`
	PreviousCursor  string                 `protobuf:"bytes,4,opt,name=previous_cursor,json=previousCursor,proto3" json:"previous_cursor,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PageResponse) Reset() {
	*x = PageResponse{}
	mi := &file_spark_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PageResponse) ProtoMessage() {}

func (x *PageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PageResponse.ProtoReflect.Descriptor instead.
func (*PageResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{6}
}

func (x *PageResponse) GetHasNextPage() bool {
	if x != nil {
		return x.HasNextPage
	}
	return false
}

func (x *PageResponse) GetHasPreviousPage() bool {
	if x != nil {
		return x.HasPreviousPage
	}
	return false
}

func (x *PageResponse) GetNextCursor() string {
	if x != nil {
		return x.NextCursor
	}
	return ""
}

func (x *PageResponse) GetPreviousCursor() string {
	if x != nil {
		return x.PreviousCursor
	}
	return ""
}

// *
// DepositAddressProof is the proof of possession of the deposit address.
// When a user wants to generate a deposit address, they are sending their public key to the SE,
// and the SE will respond with an address of user's public key + SE's public key.
//
// In the trusty deposit flow, user will need to know that this address is valid, and no single SE
// can generate this address.
//
// The SE will need to sign the address with their identity keys, and have a proof of possession of
// the signing key piece that the SE holds.
type DepositAddressProof struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The signatures of the address by the SE's identity keys.
	AddressSignatures map[string][]byte `protobuf:"bytes,1,rep,name=address_signatures,json=addressSignatures,proto3" json:"address_signatures,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The proof of possession of the signing key piece by the SE.
	ProofOfPossessionSignature []byte `protobuf:"bytes,2,opt,name=proof_of_possession_signature,json=proofOfPossessionSignature,proto3" json:"proof_of_possession_signature,omitempty"`
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *DepositAddressProof) Reset() {
	*x = DepositAddressProof{}
	mi := &file_spark_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DepositAddressProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DepositAddressProof) ProtoMessage() {}

func (x *DepositAddressProof) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DepositAddressProof.ProtoReflect.Descriptor instead.
func (*DepositAddressProof) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{7}
}

func (x *DepositAddressProof) GetAddressSignatures() map[string][]byte {
	if x != nil {
		return x.AddressSignatures
	}
	return nil
}

func (x *DepositAddressProof) GetProofOfPossessionSignature() []byte {
	if x != nil {
		return x.ProofOfPossessionSignature
	}
	return nil
}

// *
// GenerateDepositAddressRequest is the request to generate a deposit address.
// The user will send their public key to the SE, and the SE will respond with an address of user's
// public key + SE's public key.
type GenerateDepositAddressRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The signing public key of the user.
	SigningPublicKey []byte `protobuf:"bytes,1,opt,name=signing_public_key,json=signingPublicKey,proto3" json:"signing_public_key,omitempty"`
	// The identity public key of the user.
	IdentityPublicKey []byte `protobuf:"bytes,2,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	// The network of the bitcoin network.
	Network Network `protobuf:"varint,3,opt,name=network,proto3,enum=spark.Network" json:"network,omitempty"`
	// The UUID to use for the created TreeNode
	LeafId *string `protobuf:"bytes,4,opt,name=leaf_id,json=leafId,proto3,oneof" json:"leaf_id,omitempty"`
	// Generate static deposit address
	IsStatic      *bool `protobuf:"varint,5,opt,name=is_static,json=isStatic,proto3,oneof" json:"is_static,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GenerateDepositAddressRequest) Reset() {
	*x = GenerateDepositAddressRequest{}
	mi := &file_spark_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GenerateDepositAddressRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GenerateDepositAddressRequest) ProtoMessage() {}

func (x *GenerateDepositAddressRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GenerateDepositAddressRequest.ProtoReflect.Descriptor instead.
func (*GenerateDepositAddressRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{8}
}

func (x *GenerateDepositAddressRequest) GetSigningPublicKey() []byte {
	if x != nil {
		return x.SigningPublicKey
	}
	return nil
}

func (x *GenerateDepositAddressRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

func (x *GenerateDepositAddressRequest) GetNetwork() Network {
	if x != nil {
		return x.Network
	}
	return Network_UNSPECIFIED
}

func (x *GenerateDepositAddressRequest) GetLeafId() string {
	if x != nil && x.LeafId != nil {
		return *x.LeafId
	}
	return ""
}

func (x *GenerateDepositAddressRequest) GetIsStatic() bool {
	if x != nil && x.IsStatic != nil {
		return *x.IsStatic
	}
	return false
}

// *
// Address is the address of the user's public key + SE's public key.
type Address struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The p2tr address of the user's public key + SE's public key.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// The verifying key of the address, which is user's public key + SE's public key.
	VerifyingKey []byte `protobuf:"bytes,2,opt,name=verifying_key,json=verifyingKey,proto3" json:"verifying_key,omitempty"`
	// The proof of possession of the address by the SE.
	DepositAddressProof *DepositAddressProof `protobuf:"bytes,3,opt,name=deposit_address_proof,json=depositAddressProof,proto3" json:"deposit_address_proof,omitempty"`
	// Is it a static deposit address
	IsStatic      bool `protobuf:"varint,5,opt,name=is_static,json=isStatic,proto3" json:"is_static,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Address) Reset() {
	*x = Address{}
	mi := &file_spark_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Address) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Address) ProtoMessage() {}

func (x *Address) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Address.ProtoReflect.Descriptor instead.
func (*Address) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{9}
}

func (x *Address) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *Address) GetVerifyingKey() []byte {
	if x != nil {
		return x.VerifyingKey
	}
	return nil
}

func (x *Address) GetDepositAddressProof() *DepositAddressProof {
	if x != nil {
		return x.DepositAddressProof
	}
	return nil
}

func (x *Address) GetIsStatic() bool {
	if x != nil {
		return x.IsStatic
	}
	return false
}

// *
// GenerateDepositAddressResponse is the response to the request to generate a deposit address.
type GenerateDepositAddressResponse struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	DepositAddress *Address               `protobuf:"bytes,1,opt,name=deposit_address,json=depositAddress,proto3" json:"deposit_address,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *GenerateDepositAddressResponse) Reset() {
	*x = GenerateDepositAddressResponse{}
	mi := &file_spark_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GenerateDepositAddressResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GenerateDepositAddressResponse) ProtoMessage() {}

func (x *GenerateDepositAddressResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GenerateDepositAddressResponse.ProtoReflect.Descriptor instead.
func (*GenerateDepositAddressResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{10}
}

func (x *GenerateDepositAddressResponse) GetDepositAddress() *Address {
	if x != nil {
		return x.DepositAddress
	}
	return nil
}

// *
// GenerateStaticDepositAddressRequest is the request to generate a static deposit address.
type GenerateStaticDepositAddressRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The signing public key of the user.
	SigningPublicKey []byte `protobuf:"bytes,1,opt,name=signing_public_key,json=signingPublicKey,proto3" json:"signing_public_key,omitempty"`
	// The identity public key of the user.
	IdentityPublicKey []byte `protobuf:"bytes,2,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	// The network of the bitcoin network.
	Network       Network `protobuf:"varint,3,opt,name=network,proto3,enum=spark.Network" json:"network,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GenerateStaticDepositAddressRequest) Reset() {
	*x = GenerateStaticDepositAddressRequest{}
	mi := &file_spark_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GenerateStaticDepositAddressRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GenerateStaticDepositAddressRequest) ProtoMessage() {}

func (x *GenerateStaticDepositAddressRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GenerateStaticDepositAddressRequest.ProtoReflect.Descriptor instead.
func (*GenerateStaticDepositAddressRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{11}
}

func (x *GenerateStaticDepositAddressRequest) GetSigningPublicKey() []byte {
	if x != nil {
		return x.SigningPublicKey
	}
	return nil
}

func (x *GenerateStaticDepositAddressRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

func (x *GenerateStaticDepositAddressRequest) GetNetwork() Network {
	if x != nil {
		return x.Network
	}
	return Network_UNSPECIFIED
}

// *
// GenerateStaticDepositAddressResponse is the response to the request to generate a static deposit address.
type GenerateStaticDepositAddressResponse struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	DepositAddress *Address               `protobuf:"bytes,1,opt,name=deposit_address,json=depositAddress,proto3" json:"deposit_address,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *GenerateStaticDepositAddressResponse) Reset() {
	*x = GenerateStaticDepositAddressResponse{}
	mi := &file_spark_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GenerateStaticDepositAddressResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GenerateStaticDepositAddressResponse) ProtoMessage() {}

func (x *GenerateStaticDepositAddressResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GenerateStaticDepositAddressResponse.ProtoReflect.Descriptor instead.
func (*GenerateStaticDepositAddressResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{12}
}

func (x *GenerateStaticDepositAddressResponse) GetDepositAddress() *Address {
	if x != nil {
		return x.DepositAddress
	}
	return nil
}

// *
// UTXO represents a utxo on the bitcoin network.
// The UTXO is used to create a tree on Spark, it can also be an off-chain utxo so that the user
// can create the tree first and the broadcast the transaction.
type UTXO struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The raw transaction of the utxo (optional).
	RawTx []byte `protobuf:"bytes,1,opt,name=raw_tx,json=rawTx,proto3" json:"raw_tx,omitempty"`
	// The vout of the raw transaction for the utxo, which will be used to create the tree. Required.
	Vout uint32 `protobuf:"varint,2,opt,name=vout,proto3" json:"vout,omitempty"`
	// The network of the bitcoin network. Required.
	Network Network `protobuf:"varint,3,opt,name=network,proto3,enum=spark.Network" json:"network,omitempty"`
	// Transaction ID. Required, but older code may not provide it.
	Txid          []byte `protobuf:"bytes,4,opt,name=txid,proto3" json:"txid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UTXO) Reset() {
	*x = UTXO{}
	mi := &file_spark_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UTXO) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UTXO) ProtoMessage() {}

func (x *UTXO) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UTXO.ProtoReflect.Descriptor instead.
func (*UTXO) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{13}
}

func (x *UTXO) GetRawTx() []byte {
	if x != nil {
		return x.RawTx
	}
	return nil
}

func (x *UTXO) GetVout() uint32 {
	if x != nil {
		return x.Vout
	}
	return 0
}

func (x *UTXO) GetNetwork() Network {
	if x != nil {
		return x.Network
	}
	return Network_UNSPECIFIED
}

func (x *UTXO) GetTxid() []byte {
	if x != nil {
		return x.Txid
	}
	return nil
}

// *
// NodeOutput represents a node on the tree.
// This is similar to a UTXO, which is used to create a subtree on Spark. But instead of using
// a utxo, a existing node on the tree is used as the utxo.
type NodeOutput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The id of the node.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// The vout of the raw transaction for the node, which will be used to create the tree.
	Vout          uint32 `protobuf:"varint,2,opt,name=vout,proto3" json:"vout,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeOutput) Reset() {
	*x = NodeOutput{}
	mi := &file_spark_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeOutput) ProtoMessage() {}

func (x *NodeOutput) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeOutput.ProtoReflect.Descriptor instead.
func (*NodeOutput) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{14}
}

func (x *NodeOutput) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *NodeOutput) GetVout() uint32 {
	if x != nil {
		return x.Vout
	}
	return 0
}

// *
// SigningJob is the job for signing a transaction.
// The signing job is used to sign a bitcoin transaction using Spark FROST.
type SigningJob struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The signing public key of the user.
	SigningPublicKey []byte `protobuf:"bytes,1,opt,name=signing_public_key,json=signingPublicKey,proto3" json:"signing_public_key,omitempty"`
	// The unsigned raw transaction to be signed.
	RawTx []byte `protobuf:"bytes,2,opt,name=raw_tx,json=rawTx,proto3" json:"raw_tx,omitempty"`
	// The signing nonce commitment of the user.
	SigningNonceCommitment *common.SigningCommitment `protobuf:"bytes,3,opt,name=signing_nonce_commitment,json=signingNonceCommitment,proto3" json:"signing_nonce_commitment,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *SigningJob) Reset() {
	*x = SigningJob{}
	mi := &file_spark_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SigningJob) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SigningJob) ProtoMessage() {}

func (x *SigningJob) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SigningJob.ProtoReflect.Descriptor instead.
func (*SigningJob) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{15}
}

func (x *SigningJob) GetSigningPublicKey() []byte {
	if x != nil {
		return x.SigningPublicKey
	}
	return nil
}

func (x *SigningJob) GetRawTx() []byte {
	if x != nil {
		return x.RawTx
	}
	return nil
}

func (x *SigningJob) GetSigningNonceCommitment() *common.SigningCommitment {
	if x != nil {
		return x.SigningNonceCommitment
	}
	return nil
}

// *
// SigningKeyshare is the keyshare information of the SE keyshare group.
type SigningKeyshare struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The identifiers of the owners of the keyshare.
	OwnerIdentifiers []string `protobuf:"bytes,1,rep,name=owner_identifiers,json=ownerIdentifiers,proto3" json:"owner_identifiers,omitempty"`
	// The threshold of the keyshare.
	Threshold uint32 `protobuf:"varint,2,opt,name=threshold,proto3" json:"threshold,omitempty"`
	// The public key of the keyshare.
	PublicKey []byte `protobuf:"bytes,3,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// The public shares of the keyshare.
	PublicShares map[string][]byte `protobuf:"bytes,4,rep,name=public_shares,json=publicShares,proto3" json:"public_shares,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The latest update time of the keyshare.
	UpdatedTime   *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=updated_time,json=updatedTime,proto3" json:"updated_time,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SigningKeyshare) Reset() {
	*x = SigningKeyshare{}
	mi := &file_spark_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SigningKeyshare) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SigningKeyshare) ProtoMessage() {}

func (x *SigningKeyshare) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SigningKeyshare.ProtoReflect.Descriptor instead.
func (*SigningKeyshare) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{16}
}

func (x *SigningKeyshare) GetOwnerIdentifiers() []string {
	if x != nil {
		return x.OwnerIdentifiers
	}
	return nil
}

func (x *SigningKeyshare) GetThreshold() uint32 {
	if x != nil {
		return x.Threshold
	}
	return 0
}

func (x *SigningKeyshare) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *SigningKeyshare) GetPublicShares() map[string][]byte {
	if x != nil {
		return x.PublicShares
	}
	return nil
}

func (x *SigningKeyshare) GetUpdatedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedTime
	}
	return nil
}

// *
// SigningResult is the result of the signing job from the SE keyshare group.
// It contains all the information for user to sign their part. After user signs, the signature
// can be aggregated to form the final signature.
type SigningResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The public keys of the SE keyshare group.
	PublicKeys map[string][]byte `protobuf:"bytes,1,rep,name=public_keys,json=publicKeys,proto3" json:"public_keys,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The signing nonce commitments of the SE keyshare group.
	SigningNonceCommitments map[string]*common.SigningCommitment `protobuf:"bytes,2,rep,name=signing_nonce_commitments,json=signingNonceCommitments,proto3" json:"signing_nonce_commitments,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The signature shares of the SE keyshare group.
	SignatureShares map[string][]byte `protobuf:"bytes,3,rep,name=signature_shares,json=signatureShares,proto3" json:"signature_shares,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The keyshare information of the SE keyshare group.
	SigningKeyshare *SigningKeyshare `protobuf:"bytes,4,opt,name=signing_keyshare,json=signingKeyshare,proto3" json:"signing_keyshare,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SigningResult) Reset() {
	*x = SigningResult{}
	mi := &file_spark_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SigningResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SigningResult) ProtoMessage() {}

func (x *SigningResult) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SigningResult.ProtoReflect.Descriptor instead.
func (*SigningResult) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{17}
}

func (x *SigningResult) GetPublicKeys() map[string][]byte {
	if x != nil {
		return x.PublicKeys
	}
	return nil
}

func (x *SigningResult) GetSigningNonceCommitments() map[string]*common.SigningCommitment {
	if x != nil {
		return x.SigningNonceCommitments
	}
	return nil
}

func (x *SigningResult) GetSignatureShares() map[string][]byte {
	if x != nil {
		return x.SignatureShares
	}
	return nil
}

func (x *SigningResult) GetSigningKeyshare() *SigningKeyshare {
	if x != nil {
		return x.SigningKeyshare
	}
	return nil
}

type RenewLeafRequest struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	LeafId string                 `protobuf:"bytes,1,opt,name=leaf_id,json=leafId,proto3" json:"leaf_id,omitempty"`
	// Types that are valid to be assigned to SigningJobs:
	//
	//	*RenewLeafRequest_RenewNodeTimelockSigningJob
	//	*RenewLeafRequest_RenewRefundTimelockSigningJob
	//	*RenewLeafRequest_RenewNodeZeroTimelockSigningJob
	SigningJobs   isRenewLeafRequest_SigningJobs `protobuf_oneof:"signing_jobs"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RenewLeafRequest) Reset() {
	*x = RenewLeafRequest{}
	mi := &file_spark_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RenewLeafRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RenewLeafRequest) ProtoMessage() {}

func (x *RenewLeafRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RenewLeafRequest.ProtoReflect.Descriptor instead.
func (*RenewLeafRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{18}
}

func (x *RenewLeafRequest) GetLeafId() string {
	if x != nil {
		return x.LeafId
	}
	return ""
}

func (x *RenewLeafRequest) GetSigningJobs() isRenewLeafRequest_SigningJobs {
	if x != nil {
		return x.SigningJobs
	}
	return nil
}

func (x *RenewLeafRequest) GetRenewNodeTimelockSigningJob() *RenewNodeTimelockSigningJob {
	if x != nil {
		if x, ok := x.SigningJobs.(*RenewLeafRequest_RenewNodeTimelockSigningJob); ok {
			return x.RenewNodeTimelockSigningJob
		}
	}
	return nil
}

func (x *RenewLeafRequest) GetRenewRefundTimelockSigningJob() *RenewRefundTimelockSigningJob {
	if x != nil {
		if x, ok := x.SigningJobs.(*RenewLeafRequest_RenewRefundTimelockSigningJob); ok {
			return x.RenewRefundTimelockSigningJob
		}
	}
	return nil
}

func (x *RenewLeafRequest) GetRenewNodeZeroTimelockSigningJob() *RenewNodeZeroTimelockSigningJob {
	if x != nil {
		if x, ok := x.SigningJobs.(*RenewLeafRequest_RenewNodeZeroTimelockSigningJob); ok {
			return x.RenewNodeZeroTimelockSigningJob
		}
	}
	return nil
}

type isRenewLeafRequest_SigningJobs interface {
	isRenewLeafRequest_SigningJobs()
}

type RenewLeafRequest_RenewNodeTimelockSigningJob struct {
	// Resets the node transaction timelock and refund transaction timelock
	// for a leaf to 2000. The old node transaction is invalidated by
	// introducing a "split node" with zero timelock that spends to a new
	// node transaction. Takes in the signing jobs for the updated
	// node, refund, and split node transactions with the new timelocks.
	// Requires that the existing node transaction timelock is <= 300
	// at the time this function is called. Returns an error if these
	// conditions are not met.
	RenewNodeTimelockSigningJob *RenewNodeTimelockSigningJob `protobuf:"bytes,2,opt,name=renew_node_timelock_signing_job,json=renewNodeTimelockSigningJob,proto3,oneof"`
}

type RenewLeafRequest_RenewRefundTimelockSigningJob struct {
	// Resets the refund transaction timelock for a leaf to 2000. Takes in
	// the signing jobs for the updated transactions with the new timelocks.
	// Requires that the existing refund transaction timelock is <= 300 and
	// the node transaction timelock > 300 at the time this function is
	// called. Returns an error if these conditions are not met.
	RenewRefundTimelockSigningJob *RenewRefundTimelockSigningJob `protobuf:"bytes,3,opt,name=renew_refund_timelock_signing_job,json=renewRefundTimelockSigningJob,proto3,oneof"`
}

type RenewLeafRequest_RenewNodeZeroTimelockSigningJob struct {
	// A special case of refresh for when the node transaction is at 0 and
	// cannot be decremented further. This operation resets the refund
	// transaction's timelock and, similar to renew node, adds an additional
	// node transaction to the transaction chain with zero timelock as well.
	// This case is mostly used for user-created trees from L1 deposits.
	RenewNodeZeroTimelockSigningJob *RenewNodeZeroTimelockSigningJob `protobuf:"bytes,4,opt,name=renew_node_zero_timelock_signing_job,json=renewNodeZeroTimelockSigningJob,proto3,oneof"`
}

func (*RenewLeafRequest_RenewNodeTimelockSigningJob) isRenewLeafRequest_SigningJobs() {}

func (*RenewLeafRequest_RenewRefundTimelockSigningJob) isRenewLeafRequest_SigningJobs() {}

func (*RenewLeafRequest_RenewNodeZeroTimelockSigningJob) isRenewLeafRequest_SigningJobs() {}

type RenewNodeTimelockSigningJob struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Signing job with the new "split node" transaction. This spends the
	// inputs of the old node transaction and its outputs are spent by the new
	// node transaction. Timelock of split node transaction must be 0.
	SplitNodeTxSigningJob       *UserSignedTxSigningJob `protobuf:"bytes,1,opt,name=split_node_tx_signing_job,json=splitNodeTxSigningJob,proto3" json:"split_node_tx_signing_job,omitempty"`
	SplitNodeDirectTxSigningJob *UserSignedTxSigningJob `protobuf:"bytes,2,opt,name=split_node_direct_tx_signing_job,json=splitNodeDirectTxSigningJob,proto3" json:"split_node_direct_tx_signing_job,omitempty"`
	// Signing job with the updated node transaction. The updated transaction is
	// expected to have a timelock of 2000.
	NodeTxSigningJob                 *UserSignedTxSigningJob `protobuf:"bytes,3,opt,name=node_tx_signing_job,json=nodeTxSigningJob,proto3" json:"node_tx_signing_job,omitempty"`
	RefundTxSigningJob               *UserSignedTxSigningJob `protobuf:"bytes,4,opt,name=refund_tx_signing_job,json=refundTxSigningJob,proto3" json:"refund_tx_signing_job,omitempty"`
	DirectNodeTxSigningJob           *UserSignedTxSigningJob `protobuf:"bytes,5,opt,name=direct_node_tx_signing_job,json=directNodeTxSigningJob,proto3" json:"direct_node_tx_signing_job,omitempty"`
	DirectRefundTxSigningJob         *UserSignedTxSigningJob `protobuf:"bytes,6,opt,name=direct_refund_tx_signing_job,json=directRefundTxSigningJob,proto3" json:"direct_refund_tx_signing_job,omitempty"`
	DirectFromCpfpRefundTxSigningJob *UserSignedTxSigningJob `protobuf:"bytes,7,opt,name=direct_from_cpfp_refund_tx_signing_job,json=directFromCpfpRefundTxSigningJob,proto3" json:"direct_from_cpfp_refund_tx_signing_job,omitempty"`
	unknownFields                    protoimpl.UnknownFields
	sizeCache                        protoimpl.SizeCache
}

func (x *RenewNodeTimelockSigningJob) Reset() {
	*x = RenewNodeTimelockSigningJob{}
	mi := &file_spark_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RenewNodeTimelockSigningJob) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RenewNodeTimelockSigningJob) ProtoMessage() {}

func (x *RenewNodeTimelockSigningJob) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RenewNodeTimelockSigningJob.ProtoReflect.Descriptor instead.
func (*RenewNodeTimelockSigningJob) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{19}
}

func (x *RenewNodeTimelockSigningJob) GetSplitNodeTxSigningJob() *UserSignedTxSigningJob {
	if x != nil {
		return x.SplitNodeTxSigningJob
	}
	return nil
}

func (x *RenewNodeTimelockSigningJob) GetSplitNodeDirectTxSigningJob() *UserSignedTxSigningJob {
	if x != nil {
		return x.SplitNodeDirectTxSigningJob
	}
	return nil
}

func (x *RenewNodeTimelockSigningJob) GetNodeTxSigningJob() *UserSignedTxSigningJob {
	if x != nil {
		return x.NodeTxSigningJob
	}
	return nil
}

func (x *RenewNodeTimelockSigningJob) GetRefundTxSigningJob() *UserSignedTxSigningJob {
	if x != nil {
		return x.RefundTxSigningJob
	}
	return nil
}

func (x *RenewNodeTimelockSigningJob) GetDirectNodeTxSigningJob() *UserSignedTxSigningJob {
	if x != nil {
		return x.DirectNodeTxSigningJob
	}
	return nil
}

func (x *RenewNodeTimelockSigningJob) GetDirectRefundTxSigningJob() *UserSignedTxSigningJob {
	if x != nil {
		return x.DirectRefundTxSigningJob
	}
	return nil
}

func (x *RenewNodeTimelockSigningJob) GetDirectFromCpfpRefundTxSigningJob() *UserSignedTxSigningJob {
	if x != nil {
		return x.DirectFromCpfpRefundTxSigningJob
	}
	return nil
}

type RenewRefundTimelockSigningJob struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Signing job with the updated node transaction. The updated transaction is
	// expected to have a timelock of 100 less than the existing node transaction.
	NodeTxSigningJob *UserSignedTxSigningJob `protobuf:"bytes,1,opt,name=node_tx_signing_job,json=nodeTxSigningJob,proto3" json:"node_tx_signing_job,omitempty"`
	// Signing job with the updated refund transaction. This updated transaction
	// must have a timelock of 2000.
	RefundTxSigningJob               *UserSignedTxSigningJob `protobuf:"bytes,2,opt,name=refund_tx_signing_job,json=refundTxSigningJob,proto3" json:"refund_tx_signing_job,omitempty"`
	DirectNodeTxSigningJob           *UserSignedTxSigningJob `protobuf:"bytes,3,opt,name=direct_node_tx_signing_job,json=directNodeTxSigningJob,proto3" json:"direct_node_tx_signing_job,omitempty"`
	DirectRefundTxSigningJob         *UserSignedTxSigningJob `protobuf:"bytes,4,opt,name=direct_refund_tx_signing_job,json=directRefundTxSigningJob,proto3" json:"direct_refund_tx_signing_job,omitempty"`
	DirectFromCpfpRefundTxSigningJob *UserSignedTxSigningJob `protobuf:"bytes,5,opt,name=direct_from_cpfp_refund_tx_signing_job,json=directFromCpfpRefundTxSigningJob,proto3" json:"direct_from_cpfp_refund_tx_signing_job,omitempty"`
	unknownFields                    protoimpl.UnknownFields
	sizeCache                        protoimpl.SizeCache
}

func (x *RenewRefundTimelockSigningJob) Reset() {
	*x = RenewRefundTimelockSigningJob{}
	mi := &file_spark_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RenewRefundTimelockSigningJob) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RenewRefundTimelockSigningJob) ProtoMessage() {}

func (x *RenewRefundTimelockSigningJob) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RenewRefundTimelockSigningJob.ProtoReflect.Descriptor instead.
func (*RenewRefundTimelockSigningJob) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{20}
}

func (x *RenewRefundTimelockSigningJob) GetNodeTxSigningJob() *UserSignedTxSigningJob {
	if x != nil {
		return x.NodeTxSigningJob
	}
	return nil
}

func (x *RenewRefundTimelockSigningJob) GetRefundTxSigningJob() *UserSignedTxSigningJob {
	if x != nil {
		return x.RefundTxSigningJob
	}
	return nil
}

func (x *RenewRefundTimelockSigningJob) GetDirectNodeTxSigningJob() *UserSignedTxSigningJob {
	if x != nil {
		return x.DirectNodeTxSigningJob
	}
	return nil
}

func (x *RenewRefundTimelockSigningJob) GetDirectRefundTxSigningJob() *UserSignedTxSigningJob {
	if x != nil {
		return x.DirectRefundTxSigningJob
	}
	return nil
}

func (x *RenewRefundTimelockSigningJob) GetDirectFromCpfpRefundTxSigningJob() *UserSignedTxSigningJob {
	if x != nil {
		return x.DirectFromCpfpRefundTxSigningJob
	}
	return nil
}

type RenewNodeZeroTimelockSigningJob struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Signing job with the new node transaction. The updated transaction is
	// expected to have a timelock of 0.
	NodeTxSigningJob *UserSignedTxSigningJob `protobuf:"bytes,1,opt,name=node_tx_signing_job,json=nodeTxSigningJob,proto3" json:"node_tx_signing_job,omitempty"`
	// Signing job with the updated refund transaction. This updated transaction
	// must have a timelock of 2000.
	RefundTxSigningJob               *UserSignedTxSigningJob `protobuf:"bytes,2,opt,name=refund_tx_signing_job,json=refundTxSigningJob,proto3" json:"refund_tx_signing_job,omitempty"`
	DirectNodeTxSigningJob           *UserSignedTxSigningJob `protobuf:"bytes,3,opt,name=direct_node_tx_signing_job,json=directNodeTxSigningJob,proto3" json:"direct_node_tx_signing_job,omitempty"`
	DirectFromCpfpRefundTxSigningJob *UserSignedTxSigningJob `protobuf:"bytes,5,opt,name=direct_from_cpfp_refund_tx_signing_job,json=directFromCpfpRefundTxSigningJob,proto3" json:"direct_from_cpfp_refund_tx_signing_job,omitempty"`
	unknownFields                    protoimpl.UnknownFields
	sizeCache                        protoimpl.SizeCache
}

func (x *RenewNodeZeroTimelockSigningJob) Reset() {
	*x = RenewNodeZeroTimelockSigningJob{}
	mi := &file_spark_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RenewNodeZeroTimelockSigningJob) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RenewNodeZeroTimelockSigningJob) ProtoMessage() {}

func (x *RenewNodeZeroTimelockSigningJob) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RenewNodeZeroTimelockSigningJob.ProtoReflect.Descriptor instead.
func (*RenewNodeZeroTimelockSigningJob) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{21}
}

func (x *RenewNodeZeroTimelockSigningJob) GetNodeTxSigningJob() *UserSignedTxSigningJob {
	if x != nil {
		return x.NodeTxSigningJob
	}
	return nil
}

func (x *RenewNodeZeroTimelockSigningJob) GetRefundTxSigningJob() *UserSignedTxSigningJob {
	if x != nil {
		return x.RefundTxSigningJob
	}
	return nil
}

func (x *RenewNodeZeroTimelockSigningJob) GetDirectNodeTxSigningJob() *UserSignedTxSigningJob {
	if x != nil {
		return x.DirectNodeTxSigningJob
	}
	return nil
}

func (x *RenewNodeZeroTimelockSigningJob) GetDirectFromCpfpRefundTxSigningJob() *UserSignedTxSigningJob {
	if x != nil {
		return x.DirectFromCpfpRefundTxSigningJob
	}
	return nil
}

type RenewLeafResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to RenewResult:
	//
	//	*RenewLeafResponse_RenewNodeTimelockResult
	//	*RenewLeafResponse_RenewRefundTimelockResult
	//	*RenewLeafResponse_RenewNodeZeroTimelockResult
	RenewResult   isRenewLeafResponse_RenewResult `protobuf_oneof:"renew_result"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RenewLeafResponse) Reset() {
	*x = RenewLeafResponse{}
	mi := &file_spark_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RenewLeafResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RenewLeafResponse) ProtoMessage() {}

func (x *RenewLeafResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RenewLeafResponse.ProtoReflect.Descriptor instead.
func (*RenewLeafResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{22}
}

func (x *RenewLeafResponse) GetRenewResult() isRenewLeafResponse_RenewResult {
	if x != nil {
		return x.RenewResult
	}
	return nil
}

func (x *RenewLeafResponse) GetRenewNodeTimelockResult() *RenewNodeTimelockResult {
	if x != nil {
		if x, ok := x.RenewResult.(*RenewLeafResponse_RenewNodeTimelockResult); ok {
			return x.RenewNodeTimelockResult
		}
	}
	return nil
}

func (x *RenewLeafResponse) GetRenewRefundTimelockResult() *RenewRefundTimelockResult {
	if x != nil {
		if x, ok := x.RenewResult.(*RenewLeafResponse_RenewRefundTimelockResult); ok {
			return x.RenewRefundTimelockResult
		}
	}
	return nil
}

func (x *RenewLeafResponse) GetRenewNodeZeroTimelockResult() *RenewNodeZeroTimelockResult {
	if x != nil {
		if x, ok := x.RenewResult.(*RenewLeafResponse_RenewNodeZeroTimelockResult); ok {
			return x.RenewNodeZeroTimelockResult
		}
	}
	return nil
}

type isRenewLeafResponse_RenewResult interface {
	isRenewLeafResponse_RenewResult()
}

type RenewLeafResponse_RenewNodeTimelockResult struct {
	RenewNodeTimelockResult *RenewNodeTimelockResult `protobuf:"bytes,1,opt,name=renew_node_timelock_result,json=renewNodeTimelockResult,proto3,oneof"`
}

type RenewLeafResponse_RenewRefundTimelockResult struct {
	RenewRefundTimelockResult *RenewRefundTimelockResult `protobuf:"bytes,2,opt,name=renew_refund_timelock_result,json=renewRefundTimelockResult,proto3,oneof"`
}

type RenewLeafResponse_RenewNodeZeroTimelockResult struct {
	RenewNodeZeroTimelockResult *RenewNodeZeroTimelockResult `protobuf:"bytes,3,opt,name=renew_node_zero_timelock_result,json=renewNodeZeroTimelockResult,proto3,oneof"`
}

func (*RenewLeafResponse_RenewNodeTimelockResult) isRenewLeafResponse_RenewResult() {}

func (*RenewLeafResponse_RenewRefundTimelockResult) isRenewLeafResponse_RenewResult() {}

func (*RenewLeafResponse_RenewNodeZeroTimelockResult) isRenewLeafResponse_RenewResult() {}

type RenewNodeTimelockResult struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SplitNode     *TreeNode              `protobuf:"bytes,1,opt,name=split_node,json=splitNode,proto3" json:"split_node,omitempty"`
	Node          *TreeNode              `protobuf:"bytes,2,opt,name=node,proto3" json:"node,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RenewNodeTimelockResult) Reset() {
	*x = RenewNodeTimelockResult{}
	mi := &file_spark_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RenewNodeTimelockResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RenewNodeTimelockResult) ProtoMessage() {}

func (x *RenewNodeTimelockResult) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RenewNodeTimelockResult.ProtoReflect.Descriptor instead.
func (*RenewNodeTimelockResult) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{23}
}

func (x *RenewNodeTimelockResult) GetSplitNode() *TreeNode {
	if x != nil {
		return x.SplitNode
	}
	return nil
}

func (x *RenewNodeTimelockResult) GetNode() *TreeNode {
	if x != nil {
		return x.Node
	}
	return nil
}

type RenewRefundTimelockResult struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Node          *TreeNode              `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RenewRefundTimelockResult) Reset() {
	*x = RenewRefundTimelockResult{}
	mi := &file_spark_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RenewRefundTimelockResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RenewRefundTimelockResult) ProtoMessage() {}

func (x *RenewRefundTimelockResult) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RenewRefundTimelockResult.ProtoReflect.Descriptor instead.
func (*RenewRefundTimelockResult) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{24}
}

func (x *RenewRefundTimelockResult) GetNode() *TreeNode {
	if x != nil {
		return x.Node
	}
	return nil
}

type RenewNodeZeroTimelockResult struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SplitNode     *TreeNode              `protobuf:"bytes,1,opt,name=split_node,json=splitNode,proto3" json:"split_node,omitempty"`
	Node          *TreeNode              `protobuf:"bytes,2,opt,name=node,proto3" json:"node,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RenewNodeZeroTimelockResult) Reset() {
	*x = RenewNodeZeroTimelockResult{}
	mi := &file_spark_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RenewNodeZeroTimelockResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RenewNodeZeroTimelockResult) ProtoMessage() {}

func (x *RenewNodeZeroTimelockResult) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RenewNodeZeroTimelockResult.ProtoReflect.Descriptor instead.
func (*RenewNodeZeroTimelockResult) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{25}
}

func (x *RenewNodeZeroTimelockResult) GetSplitNode() *TreeNode {
	if x != nil {
		return x.SplitNode
	}
	return nil
}

func (x *RenewNodeZeroTimelockResult) GetNode() *TreeNode {
	if x != nil {
		return x.Node
	}
	return nil
}

// *
// NodeSignatureShares is the signature shares for a node on the tree.
// For each tree node, the verifying key stays the same for both transactions.
type NodeSignatureShares struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The id of the node.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// The signing result of the node's transaction. This transaction is to pay to self.
	NodeTxSigningResult *SigningResult `protobuf:"bytes,2,opt,name=node_tx_signing_result,json=nodeTxSigningResult,proto3" json:"node_tx_signing_result,omitempty"`
	// The signing result of the node's refund transaction. This transaction is to pay to the user.
	RefundTxSigningResult *SigningResult `protobuf:"bytes,3,opt,name=refund_tx_signing_result,json=refundTxSigningResult,proto3" json:"refund_tx_signing_result,omitempty"`
	// The verifying key of the node.
	VerifyingKey []byte `protobuf:"bytes,4,opt,name=verifying_key,json=verifyingKey,proto3" json:"verifying_key,omitempty"`
	// The signing result of the node's transaction. This transaction is to pay to self.
	DirectNodeTxSigningResult *SigningResult `protobuf:"bytes,5,opt,name=direct_node_tx_signing_result,json=directNodeTxSigningResult,proto3" json:"direct_node_tx_signing_result,omitempty"`
	// The signing result of the node's direct refund transaction. This transaction is to broadcast for the SO.
	DirectRefundTxSigningResult *SigningResult `protobuf:"bytes,6,opt,name=direct_refund_tx_signing_result,json=directRefundTxSigningResult,proto3" json:"direct_refund_tx_signing_result,omitempty"`
	// The signing result of the node's direct from cpfp refund transaction. This transaction is to broadcast for the SO.
	DirectFromCpfpRefundTxSigningResult *SigningResult `protobuf:"bytes,7,opt,name=direct_from_cpfp_refund_tx_signing_result,json=directFromCpfpRefundTxSigningResult,proto3" json:"direct_from_cpfp_refund_tx_signing_result,omitempty"`
	unknownFields                       protoimpl.UnknownFields
	sizeCache                           protoimpl.SizeCache
}

func (x *NodeSignatureShares) Reset() {
	*x = NodeSignatureShares{}
	mi := &file_spark_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeSignatureShares) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeSignatureShares) ProtoMessage() {}

func (x *NodeSignatureShares) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeSignatureShares.ProtoReflect.Descriptor instead.
func (*NodeSignatureShares) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{26}
}

func (x *NodeSignatureShares) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *NodeSignatureShares) GetNodeTxSigningResult() *SigningResult {
	if x != nil {
		return x.NodeTxSigningResult
	}
	return nil
}

func (x *NodeSignatureShares) GetRefundTxSigningResult() *SigningResult {
	if x != nil {
		return x.RefundTxSigningResult
	}
	return nil
}

func (x *NodeSignatureShares) GetVerifyingKey() []byte {
	if x != nil {
		return x.VerifyingKey
	}
	return nil
}

func (x *NodeSignatureShares) GetDirectNodeTxSigningResult() *SigningResult {
	if x != nil {
		return x.DirectNodeTxSigningResult
	}
	return nil
}

func (x *NodeSignatureShares) GetDirectRefundTxSigningResult() *SigningResult {
	if x != nil {
		return x.DirectRefundTxSigningResult
	}
	return nil
}

func (x *NodeSignatureShares) GetDirectFromCpfpRefundTxSigningResult() *SigningResult {
	if x != nil {
		return x.DirectFromCpfpRefundTxSigningResult
	}
	return nil
}

// *
// NodeSignatures is the final signatures for a node on the tree.
// It contains the signature for the node's transaction and refund transaction.
type NodeSignatures struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The id of the node.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// The final signature of the node's cpfp transaction. This transaction is to pay to self.
	NodeTxSignature []byte `protobuf:"bytes,2,opt,name=node_tx_signature,json=nodeTxSignature,proto3" json:"node_tx_signature,omitempty"`
	// The final signature of the node's cpfp refund transaction. This transaction is to pay to the user.
	RefundTxSignature []byte `protobuf:"bytes,3,opt,name=refund_tx_signature,json=refundTxSignature,proto3" json:"refund_tx_signature,omitempty"`
	// The final signature of the node's direct transaction. This transaction is to pay for the watchtower.
	DirectNodeTxSignature []byte `protobuf:"bytes,4,opt,name=direct_node_tx_signature,json=directNodeTxSignature,proto3" json:"direct_node_tx_signature,omitempty"`
	// The final signature of the node's direct refund transaction. This transaction is to pay for the watchtower.
	DirectRefundTxSignature []byte `protobuf:"bytes,5,opt,name=direct_refund_tx_signature,json=directRefundTxSignature,proto3" json:"direct_refund_tx_signature,omitempty"`
	// The final signature of the node's direct from cpfp refund transaction. This transaction is to pay for the watchtower.
	DirectFromCpfpRefundTxSignature []byte `protobuf:"bytes,6,opt,name=direct_from_cpfp_refund_tx_signature,json=directFromCpfpRefundTxSignature,proto3" json:"direct_from_cpfp_refund_tx_signature,omitempty"`
	unknownFields                   protoimpl.UnknownFields
	sizeCache                       protoimpl.SizeCache
}

func (x *NodeSignatures) Reset() {
	*x = NodeSignatures{}
	mi := &file_spark_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeSignatures) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeSignatures) ProtoMessage() {}

func (x *NodeSignatures) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeSignatures.ProtoReflect.Descriptor instead.
func (*NodeSignatures) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{27}
}

func (x *NodeSignatures) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *NodeSignatures) GetNodeTxSignature() []byte {
	if x != nil {
		return x.NodeTxSignature
	}
	return nil
}

func (x *NodeSignatures) GetRefundTxSignature() []byte {
	if x != nil {
		return x.RefundTxSignature
	}
	return nil
}

func (x *NodeSignatures) GetDirectNodeTxSignature() []byte {
	if x != nil {
		return x.DirectNodeTxSignature
	}
	return nil
}

func (x *NodeSignatures) GetDirectRefundTxSignature() []byte {
	if x != nil {
		return x.DirectRefundTxSignature
	}
	return nil
}

func (x *NodeSignatures) GetDirectFromCpfpRefundTxSignature() []byte {
	if x != nil {
		return x.DirectFromCpfpRefundTxSignature
	}
	return nil
}

// *
// StartTreeCreationRequest is the request to start the tree creation for a tree root node.
type StartTreeCreationRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The identity public key of the user.
	IdentityPublicKey []byte `protobuf:"bytes,1,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	// The on-chain utxo to be used to be spent by the root node.
	OnChainUtxo *UTXO `protobuf:"bytes,2,opt,name=on_chain_utxo,json=onChainUtxo,proto3" json:"on_chain_utxo,omitempty"`
	// The signing job for the root node's cpfp transaction.
	RootTxSigningJob *SigningJob `protobuf:"bytes,3,opt,name=root_tx_signing_job,json=rootTxSigningJob,proto3" json:"root_tx_signing_job,omitempty"`
	// The signing job for the root node's cpfp refund transaction.
	RefundTxSigningJob *SigningJob `protobuf:"bytes,4,opt,name=refund_tx_signing_job,json=refundTxSigningJob,proto3" json:"refund_tx_signing_job,omitempty"`
	// The signing job for the root node's direct transaction.
	DirectRootTxSigningJob *SigningJob `protobuf:"bytes,5,opt,name=direct_root_tx_signing_job,json=directRootTxSigningJob,proto3" json:"direct_root_tx_signing_job,omitempty"`
	// The signing job for the root node's direct refund transaction
	DirectRefundTxSigningJob *SigningJob `protobuf:"bytes,6,opt,name=direct_refund_tx_signing_job,json=directRefundTxSigningJob,proto3" json:"direct_refund_tx_signing_job,omitempty"`
	// The signing job for the root node's direct refund transaction
	DirectFromCpfpRefundTxSigningJob *SigningJob `protobuf:"bytes,7,opt,name=direct_from_cpfp_refund_tx_signing_job,json=directFromCpfpRefundTxSigningJob,proto3" json:"direct_from_cpfp_refund_tx_signing_job,omitempty"`
	unknownFields                    protoimpl.UnknownFields
	sizeCache                        protoimpl.SizeCache
}

func (x *StartTreeCreationRequest) Reset() {
	*x = StartTreeCreationRequest{}
	mi := &file_spark_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartTreeCreationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartTreeCreationRequest) ProtoMessage() {}

func (x *StartTreeCreationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartTreeCreationRequest.ProtoReflect.Descriptor instead.
func (*StartTreeCreationRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{28}
}

func (x *StartTreeCreationRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

func (x *StartTreeCreationRequest) GetOnChainUtxo() *UTXO {
	if x != nil {
		return x.OnChainUtxo
	}
	return nil
}

func (x *StartTreeCreationRequest) GetRootTxSigningJob() *SigningJob {
	if x != nil {
		return x.RootTxSigningJob
	}
	return nil
}

func (x *StartTreeCreationRequest) GetRefundTxSigningJob() *SigningJob {
	if x != nil {
		return x.RefundTxSigningJob
	}
	return nil
}

func (x *StartTreeCreationRequest) GetDirectRootTxSigningJob() *SigningJob {
	if x != nil {
		return x.DirectRootTxSigningJob
	}
	return nil
}

func (x *StartTreeCreationRequest) GetDirectRefundTxSigningJob() *SigningJob {
	if x != nil {
		return x.DirectRefundTxSigningJob
	}
	return nil
}

func (x *StartTreeCreationRequest) GetDirectFromCpfpRefundTxSigningJob() *SigningJob {
	if x != nil {
		return x.DirectFromCpfpRefundTxSigningJob
	}
	return nil
}

// *
// StartTreeCreationResponse is the response to the request to start the tree creation for a tree root node.
type StartTreeCreationResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The id of the tree.
	TreeId string `protobuf:"bytes,1,opt,name=tree_id,json=treeId,proto3" json:"tree_id,omitempty"`
	// The signature shares for the root node.
	RootNodeSignatureShares *NodeSignatureShares `protobuf:"bytes,2,opt,name=root_node_signature_shares,json=rootNodeSignatureShares,proto3" json:"root_node_signature_shares,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *StartTreeCreationResponse) Reset() {
	*x = StartTreeCreationResponse{}
	mi := &file_spark_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartTreeCreationResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartTreeCreationResponse) ProtoMessage() {}

func (x *StartTreeCreationResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartTreeCreationResponse.ProtoReflect.Descriptor instead.
func (*StartTreeCreationResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{29}
}

func (x *StartTreeCreationResponse) GetTreeId() string {
	if x != nil {
		return x.TreeId
	}
	return ""
}

func (x *StartTreeCreationResponse) GetRootNodeSignatureShares() *NodeSignatureShares {
	if x != nil {
		return x.RootNodeSignatureShares
	}
	return nil
}

// *
// StartDepositTreeCreationRequest is the request to start the tree creation for a tree root node.
type StartDepositTreeCreationRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The identity public key of the user.
	IdentityPublicKey []byte `protobuf:"bytes,1,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	// The on-chain utxo to be used to be spent by the root node.
	OnChainUtxo *UTXO `protobuf:"bytes,2,opt,name=on_chain_utxo,json=onChainUtxo,proto3" json:"on_chain_utxo,omitempty"`
	// The signing job for the root node's transaction.
	RootTxSigningJob *SigningJob `protobuf:"bytes,3,opt,name=root_tx_signing_job,json=rootTxSigningJob,proto3" json:"root_tx_signing_job,omitempty"`
	// The signing job for the root node's refund transaction.
	RefundTxSigningJob *SigningJob `protobuf:"bytes,4,opt,name=refund_tx_signing_job,json=refundTxSigningJob,proto3" json:"refund_tx_signing_job,omitempty"`
	// The direct signing job for the root node's transaction.
	DirectRootTxSigningJob *SigningJob `protobuf:"bytes,5,opt,name=direct_root_tx_signing_job,json=directRootTxSigningJob,proto3" json:"direct_root_tx_signing_job,omitempty"`
	// The signing job for the root node's direct refund transaction.
	DirectRefundTxSigningJob *SigningJob `protobuf:"bytes,6,opt,name=direct_refund_tx_signing_job,json=directRefundTxSigningJob,proto3" json:"direct_refund_tx_signing_job,omitempty"`
	// The signing job for the root node's direct from cpfp refund transaction.
	DirectFromCpfpRefundTxSigningJob *SigningJob `protobuf:"bytes,7,opt,name=direct_from_cpfp_refund_tx_signing_job,json=directFromCpfpRefundTxSigningJob,proto3" json:"direct_from_cpfp_refund_tx_signing_job,omitempty"`
	unknownFields                    protoimpl.UnknownFields
	sizeCache                        protoimpl.SizeCache
}

func (x *StartDepositTreeCreationRequest) Reset() {
	*x = StartDepositTreeCreationRequest{}
	mi := &file_spark_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartDepositTreeCreationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartDepositTreeCreationRequest) ProtoMessage() {}

func (x *StartDepositTreeCreationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartDepositTreeCreationRequest.ProtoReflect.Descriptor instead.
func (*StartDepositTreeCreationRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{30}
}

func (x *StartDepositTreeCreationRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

func (x *StartDepositTreeCreationRequest) GetOnChainUtxo() *UTXO {
	if x != nil {
		return x.OnChainUtxo
	}
	return nil
}

func (x *StartDepositTreeCreationRequest) GetRootTxSigningJob() *SigningJob {
	if x != nil {
		return x.RootTxSigningJob
	}
	return nil
}

func (x *StartDepositTreeCreationRequest) GetRefundTxSigningJob() *SigningJob {
	if x != nil {
		return x.RefundTxSigningJob
	}
	return nil
}

func (x *StartDepositTreeCreationRequest) GetDirectRootTxSigningJob() *SigningJob {
	if x != nil {
		return x.DirectRootTxSigningJob
	}
	return nil
}

func (x *StartDepositTreeCreationRequest) GetDirectRefundTxSigningJob() *SigningJob {
	if x != nil {
		return x.DirectRefundTxSigningJob
	}
	return nil
}

func (x *StartDepositTreeCreationRequest) GetDirectFromCpfpRefundTxSigningJob() *SigningJob {
	if x != nil {
		return x.DirectFromCpfpRefundTxSigningJob
	}
	return nil
}

// *
// StartDepositTreeCreationResponse is the response to the request to start the tree creation for a tree root node.
type StartDepositTreeCreationResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The id of the tree.
	TreeId string `protobuf:"bytes,1,opt,name=tree_id,json=treeId,proto3" json:"tree_id,omitempty"`
	// The signature shares for the root node.
	RootNodeSignatureShares *NodeSignatureShares `protobuf:"bytes,2,opt,name=root_node_signature_shares,json=rootNodeSignatureShares,proto3" json:"root_node_signature_shares,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *StartDepositTreeCreationResponse) Reset() {
	*x = StartDepositTreeCreationResponse{}
	mi := &file_spark_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartDepositTreeCreationResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartDepositTreeCreationResponse) ProtoMessage() {}

func (x *StartDepositTreeCreationResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartDepositTreeCreationResponse.ProtoReflect.Descriptor instead.
func (*StartDepositTreeCreationResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{31}
}

func (x *StartDepositTreeCreationResponse) GetTreeId() string {
	if x != nil {
		return x.TreeId
	}
	return ""
}

func (x *StartDepositTreeCreationResponse) GetRootNodeSignatureShares() *NodeSignatureShares {
	if x != nil {
		return x.RootNodeSignatureShares
	}
	return nil
}

// This proto is constructed by the wallet to specify leaves it wants to spend as
// part of the token transaction.
type TokenOutputToSpend struct {
	state                    protoimpl.MessageState `protogen:"open.v1"`
	PrevTokenTransactionHash []byte                 `protobuf:"bytes,1,opt,name=prev_token_transaction_hash,json=prevTokenTransactionHash,proto3" json:"prev_token_transaction_hash,omitempty"`
	PrevTokenTransactionVout uint32                 `protobuf:"varint,2,opt,name=prev_token_transaction_vout,json=prevTokenTransactionVout,proto3" json:"prev_token_transaction_vout,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *TokenOutputToSpend) Reset() {
	*x = TokenOutputToSpend{}
	mi := &file_spark_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenOutputToSpend) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenOutputToSpend) ProtoMessage() {}

func (x *TokenOutputToSpend) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenOutputToSpend.ProtoReflect.Descriptor instead.
func (*TokenOutputToSpend) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{32}
}

func (x *TokenOutputToSpend) GetPrevTokenTransactionHash() []byte {
	if x != nil {
		return x.PrevTokenTransactionHash
	}
	return nil
}

func (x *TokenOutputToSpend) GetPrevTokenTransactionVout() uint32 {
	if x != nil {
		return x.PrevTokenTransactionVout
	}
	return 0
}

type TokenTransferInput struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	OutputsToSpend []*TokenOutputToSpend  `protobuf:"bytes,1,rep,name=outputs_to_spend,json=outputsToSpend,proto3" json:"outputs_to_spend,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *TokenTransferInput) Reset() {
	*x = TokenTransferInput{}
	mi := &file_spark_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenTransferInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenTransferInput) ProtoMessage() {}

func (x *TokenTransferInput) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenTransferInput.ProtoReflect.Descriptor instead.
func (*TokenTransferInput) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{33}
}

func (x *TokenTransferInput) GetOutputsToSpend() []*TokenOutputToSpend {
	if x != nil {
		return x.OutputsToSpend
	}
	return nil
}

type TokenMintInput struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	IssuerPublicKey []byte                 `protobuf:"bytes,1,opt,name=issuer_public_key,json=issuerPublicKey,proto3" json:"issuer_public_key,omitempty"`
	// Issuer provided timestamp of when the transaction was signed/constructed.
	// Helps provide idempotency and ensures that each mint input signature is unique
	// as long as multiple mint signatures are not happening at the same time. Also gives a
	// potentially useful data point for when the issuer authorized from their
	// perspective.  Note that we have no way of proving this is accurate.
	// TODO: Consider whether implementing generic idempotency controls and/or a
	// random nonce would be favorable to populating this field.
	IssuerProvidedTimestamp uint64 `protobuf:"varint,2,opt,name=issuer_provided_timestamp,json=issuerProvidedTimestamp,proto3" json:"issuer_provided_timestamp,omitempty"`
	TokenIdentifier         []byte `protobuf:"bytes,3,opt,name=token_identifier,json=tokenIdentifier,proto3,oneof" json:"token_identifier,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *TokenMintInput) Reset() {
	*x = TokenMintInput{}
	mi := &file_spark_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenMintInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenMintInput) ProtoMessage() {}

func (x *TokenMintInput) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenMintInput.ProtoReflect.Descriptor instead.
func (*TokenMintInput) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{34}
}

func (x *TokenMintInput) GetIssuerPublicKey() []byte {
	if x != nil {
		return x.IssuerPublicKey
	}
	return nil
}

func (x *TokenMintInput) GetIssuerProvidedTimestamp() uint64 {
	if x != nil {
		return x.IssuerProvidedTimestamp
	}
	return 0
}

func (x *TokenMintInput) GetTokenIdentifier() []byte {
	if x != nil {
		return x.TokenIdentifier
	}
	return nil
}

type TokenCreateInput struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	IssuerPublicKey         []byte                 `protobuf:"bytes,1,opt,name=issuer_public_key,json=issuerPublicKey,proto3" json:"issuer_public_key,omitempty"`
	TokenName               string                 `protobuf:"bytes,2,opt,name=token_name,json=tokenName,proto3" json:"token_name,omitempty"`       // No minimum length because a single utf-8 character can be 3 bytes.
	TokenTicker             string                 `protobuf:"bytes,3,opt,name=token_ticker,json=tokenTicker,proto3" json:"token_ticker,omitempty"` // No minimum length because a single utf-8 character can be 3 bytes.
	Decimals                uint32                 `protobuf:"varint,4,opt,name=decimals,proto3" json:"decimals,omitempty"`
	MaxSupply               []byte                 `protobuf:"bytes,5,opt,name=max_supply,json=maxSupply,proto3" json:"max_supply,omitempty"` // Decoded uint128
	IsFreezable             bool                   `protobuf:"varint,6,opt,name=is_freezable,json=isFreezable,proto3" json:"is_freezable,omitempty"`
	CreationEntityPublicKey []byte                 `protobuf:"bytes,7,opt,name=creation_entity_public_key,json=creationEntityPublicKey,proto3,oneof" json:"creation_entity_public_key,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *TokenCreateInput) Reset() {
	*x = TokenCreateInput{}
	mi := &file_spark_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenCreateInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenCreateInput) ProtoMessage() {}

func (x *TokenCreateInput) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenCreateInput.ProtoReflect.Descriptor instead.
func (*TokenCreateInput) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{35}
}

func (x *TokenCreateInput) GetIssuerPublicKey() []byte {
	if x != nil {
		return x.IssuerPublicKey
	}
	return nil
}

func (x *TokenCreateInput) GetTokenName() string {
	if x != nil {
		return x.TokenName
	}
	return ""
}

func (x *TokenCreateInput) GetTokenTicker() string {
	if x != nil {
		return x.TokenTicker
	}
	return ""
}

func (x *TokenCreateInput) GetDecimals() uint32 {
	if x != nil {
		return x.Decimals
	}
	return 0
}

func (x *TokenCreateInput) GetMaxSupply() []byte {
	if x != nil {
		return x.MaxSupply
	}
	return nil
}

func (x *TokenCreateInput) GetIsFreezable() bool {
	if x != nil {
		return x.IsFreezable
	}
	return false
}

func (x *TokenCreateInput) GetCreationEntityPublicKey() []byte {
	if x != nil {
		return x.CreationEntityPublicKey
	}
	return nil
}

// This proto is constructed by the wallet to specify outputs it wants to create
// as part of a token transaction. Output id and revocation public key should remain unfilled
// so that the SE can fill them as part of the StartTokenTransaction() call.
type TokenOutput struct {
	state                         protoimpl.MessageState `protogen:"open.v1"`
	Id                            *string                `protobuf:"bytes,1,opt,name=id,proto3,oneof" json:"id,omitempty"`
	OwnerPublicKey                []byte                 `protobuf:"bytes,2,opt,name=owner_public_key,json=ownerPublicKey,proto3" json:"owner_public_key,omitempty"`
	RevocationCommitment          []byte                 `protobuf:"bytes,3,opt,name=revocation_commitment,json=revocationCommitment,proto3,oneof" json:"revocation_commitment,omitempty"`
	WithdrawBondSats              *uint64                `protobuf:"varint,4,opt,name=withdraw_bond_sats,json=withdrawBondSats,proto3,oneof" json:"withdraw_bond_sats,omitempty"`
	WithdrawRelativeBlockLocktime *uint64                `protobuf:"varint,5,opt,name=withdraw_relative_block_locktime,json=withdrawRelativeBlockLocktime,proto3,oneof" json:"withdraw_relative_block_locktime,omitempty"`
	TokenPublicKey                []byte                 `protobuf:"bytes,6,opt,name=token_public_key,json=tokenPublicKey,proto3,oneof" json:"token_public_key,omitempty"`
	TokenIdentifier               []byte                 `protobuf:"bytes,8,opt,name=token_identifier,json=tokenIdentifier,proto3,oneof" json:"token_identifier,omitempty"`
	TokenAmount                   []byte                 `protobuf:"bytes,7,opt,name=token_amount,json=tokenAmount,proto3" json:"token_amount,omitempty"` // Decoded uint128
	unknownFields                 protoimpl.UnknownFields
	sizeCache                     protoimpl.SizeCache
}

func (x *TokenOutput) Reset() {
	*x = TokenOutput{}
	mi := &file_spark_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenOutput) ProtoMessage() {}

func (x *TokenOutput) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenOutput.ProtoReflect.Descriptor instead.
func (*TokenOutput) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{36}
}

func (x *TokenOutput) GetId() string {
	if x != nil && x.Id != nil {
		return *x.Id
	}
	return ""
}

func (x *TokenOutput) GetOwnerPublicKey() []byte {
	if x != nil {
		return x.OwnerPublicKey
	}
	return nil
}

func (x *TokenOutput) GetRevocationCommitment() []byte {
	if x != nil {
		return x.RevocationCommitment
	}
	return nil
}

func (x *TokenOutput) GetWithdrawBondSats() uint64 {
	if x != nil && x.WithdrawBondSats != nil {
		return *x.WithdrawBondSats
	}
	return 0
}

func (x *TokenOutput) GetWithdrawRelativeBlockLocktime() uint64 {
	if x != nil && x.WithdrawRelativeBlockLocktime != nil {
		return *x.WithdrawRelativeBlockLocktime
	}
	return 0
}

func (x *TokenOutput) GetTokenPublicKey() []byte {
	if x != nil {
		return x.TokenPublicKey
	}
	return nil
}

func (x *TokenOutput) GetTokenIdentifier() []byte {
	if x != nil {
		return x.TokenIdentifier
	}
	return nil
}

func (x *TokenOutput) GetTokenAmount() []byte {
	if x != nil {
		return x.TokenAmount
	}
	return nil
}

// This proto is constructed by the wallet and is the core transaction data structure.
// This proto is deterministically hashed to generate the token_transaction_hash that
// is cooperatively signed by the SO group to confirm a token transaction.
type TokenTransaction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to TokenInputs:
	//
	//	*TokenTransaction_MintInput
	//	*TokenTransaction_TransferInput
	//	*TokenTransaction_CreateInput
	TokenInputs                     isTokenTransaction_TokenInputs `protobuf_oneof:"token_inputs"`
	TokenOutputs                    []*TokenOutput                 `protobuf:"bytes,3,rep,name=token_outputs,json=tokenOutputs,proto3" json:"token_outputs,omitempty"`
	SparkOperatorIdentityPublicKeys [][]byte                       `protobuf:"bytes,4,rep,name=spark_operator_identity_public_keys,json=sparkOperatorIdentityPublicKeys,proto3" json:"spark_operator_identity_public_keys,omitempty"`
	Network                         Network                        `protobuf:"varint,10,opt,name=network,proto3,enum=spark.Network" json:"network,omitempty"`
	unknownFields                   protoimpl.UnknownFields
	sizeCache                       protoimpl.SizeCache
}

func (x *TokenTransaction) Reset() {
	*x = TokenTransaction{}
	mi := &file_spark_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenTransaction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenTransaction) ProtoMessage() {}

func (x *TokenTransaction) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenTransaction.ProtoReflect.Descriptor instead.
func (*TokenTransaction) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{37}
}

func (x *TokenTransaction) GetTokenInputs() isTokenTransaction_TokenInputs {
	if x != nil {
		return x.TokenInputs
	}
	return nil
}

func (x *TokenTransaction) GetMintInput() *TokenMintInput {
	if x != nil {
		if x, ok := x.TokenInputs.(*TokenTransaction_MintInput); ok {
			return x.MintInput
		}
	}
	return nil
}

func (x *TokenTransaction) GetTransferInput() *TokenTransferInput {
	if x != nil {
		if x, ok := x.TokenInputs.(*TokenTransaction_TransferInput); ok {
			return x.TransferInput
		}
	}
	return nil
}

func (x *TokenTransaction) GetCreateInput() *TokenCreateInput {
	if x != nil {
		if x, ok := x.TokenInputs.(*TokenTransaction_CreateInput); ok {
			return x.CreateInput
		}
	}
	return nil
}

func (x *TokenTransaction) GetTokenOutputs() []*TokenOutput {
	if x != nil {
		return x.TokenOutputs
	}
	return nil
}

func (x *TokenTransaction) GetSparkOperatorIdentityPublicKeys() [][]byte {
	if x != nil {
		return x.SparkOperatorIdentityPublicKeys
	}
	return nil
}

func (x *TokenTransaction) GetNetwork() Network {
	if x != nil {
		return x.Network
	}
	return Network_UNSPECIFIED
}

type isTokenTransaction_TokenInputs interface {
	isTokenTransaction_TokenInputs()
}

type TokenTransaction_MintInput struct {
	MintInput *TokenMintInput `protobuf:"bytes,1,opt,name=mint_input,json=mintInput,proto3,oneof"`
}

type TokenTransaction_TransferInput struct {
	TransferInput *TokenTransferInput `protobuf:"bytes,2,opt,name=transfer_input,json=transferInput,proto3,oneof"`
}

type TokenTransaction_CreateInput struct {
	CreateInput *TokenCreateInput `protobuf:"bytes,5,opt,name=create_input,json=createInput,proto3,oneof"`
}

func (*TokenTransaction_MintInput) isTokenTransaction_TokenInputs() {}

func (*TokenTransaction_TransferInput) isTokenTransaction_TokenInputs() {}

func (*TokenTransaction_CreateInput) isTokenTransaction_TokenInputs() {}

type SpentTokenOutputMetadata struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	OutputId         string                 `protobuf:"bytes,1,opt,name=output_id,json=outputId,proto3" json:"output_id,omitempty"`
	RevocationSecret []byte                 `protobuf:"bytes,2,opt,name=revocation_secret,json=revocationSecret,proto3" json:"revocation_secret,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *SpentTokenOutputMetadata) Reset() {
	*x = SpentTokenOutputMetadata{}
	mi := &file_spark_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SpentTokenOutputMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SpentTokenOutputMetadata) ProtoMessage() {}

func (x *SpentTokenOutputMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SpentTokenOutputMetadata.ProtoReflect.Descriptor instead.
func (*SpentTokenOutputMetadata) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{38}
}

func (x *SpentTokenOutputMetadata) GetOutputId() string {
	if x != nil {
		return x.OutputId
	}
	return ""
}

func (x *SpentTokenOutputMetadata) GetRevocationSecret() []byte {
	if x != nil {
		return x.RevocationSecret
	}
	return nil
}

type TokenTransactionConfirmationMetadata struct {
	state                     protoimpl.MessageState      `protogen:"open.v1"`
	SpentTokenOutputsMetadata []*SpentTokenOutputMetadata `protobuf:"bytes,1,rep,name=spent_token_outputs_metadata,json=spentTokenOutputsMetadata,proto3" json:"spent_token_outputs_metadata,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *TokenTransactionConfirmationMetadata) Reset() {
	*x = TokenTransactionConfirmationMetadata{}
	mi := &file_spark_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenTransactionConfirmationMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenTransactionConfirmationMetadata) ProtoMessage() {}

func (x *TokenTransactionConfirmationMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenTransactionConfirmationMetadata.ProtoReflect.Descriptor instead.
func (*TokenTransactionConfirmationMetadata) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{39}
}

func (x *TokenTransactionConfirmationMetadata) GetSpentTokenOutputsMetadata() []*SpentTokenOutputMetadata {
	if x != nil {
		return x.SpentTokenOutputsMetadata
	}
	return nil
}

type TokenTransactionWithStatus struct {
	state                protoimpl.MessageState                `protogen:"open.v1"`
	TokenTransaction     *TokenTransaction                     `protobuf:"bytes,1,opt,name=token_transaction,json=tokenTransaction,proto3" json:"token_transaction,omitempty"`
	Status               TokenTransactionStatus                `protobuf:"varint,2,opt,name=status,proto3,enum=spark.TokenTransactionStatus" json:"status,omitempty"`
	ConfirmationMetadata *TokenTransactionConfirmationMetadata `protobuf:"bytes,3,opt,name=confirmation_metadata,json=confirmationMetadata,proto3" json:"confirmation_metadata,omitempty"`
	TokenTransactionHash []byte                                `protobuf:"bytes,4,opt,name=token_transaction_hash,json=tokenTransactionHash,proto3" json:"token_transaction_hash,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *TokenTransactionWithStatus) Reset() {
	*x = TokenTransactionWithStatus{}
	mi := &file_spark_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenTransactionWithStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenTransactionWithStatus) ProtoMessage() {}

func (x *TokenTransactionWithStatus) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenTransactionWithStatus.ProtoReflect.Descriptor instead.
func (*TokenTransactionWithStatus) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{40}
}

func (x *TokenTransactionWithStatus) GetTokenTransaction() *TokenTransaction {
	if x != nil {
		return x.TokenTransaction
	}
	return nil
}

func (x *TokenTransactionWithStatus) GetStatus() TokenTransactionStatus {
	if x != nil {
		return x.Status
	}
	return TokenTransactionStatus_TOKEN_TRANSACTION_STARTED
}

func (x *TokenTransactionWithStatus) GetConfirmationMetadata() *TokenTransactionConfirmationMetadata {
	if x != nil {
		return x.ConfirmationMetadata
	}
	return nil
}

func (x *TokenTransactionWithStatus) GetTokenTransactionHash() []byte {
	if x != nil {
		return x.TokenTransactionHash
	}
	return nil
}

type SignatureWithIndex struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This is a Schnorr or ECDSA DER signature which can be between 64 and 73 bytes.
	Signature []byte `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
	// The index of the TTXO associated with this signature.
	InputIndex    uint32 `protobuf:"varint,2,opt,name=input_index,json=inputIndex,proto3" json:"input_index,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SignatureWithIndex) Reset() {
	*x = SignatureWithIndex{}
	mi := &file_spark_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignatureWithIndex) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignatureWithIndex) ProtoMessage() {}

func (x *SignatureWithIndex) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignatureWithIndex.ProtoReflect.Descriptor instead.
func (*SignatureWithIndex) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{41}
}

func (x *SignatureWithIndex) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *SignatureWithIndex) GetInputIndex() uint32 {
	if x != nil {
		return x.InputIndex
	}
	return 0
}

type TokenTransactionSignatures struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Filled by signing the partial token transaction hash with the owner/issuer private key.
	// For mint transactions this will be one signature for the input token_public_key
	// For transfer transactions this will be one for each output for the output owner_public_key
	OwnerSignatures []*SignatureWithIndex `protobuf:"bytes,1,rep,name=owner_signatures,json=ownerSignatures,proto3" json:"owner_signatures,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TokenTransactionSignatures) Reset() {
	*x = TokenTransactionSignatures{}
	mi := &file_spark_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenTransactionSignatures) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenTransactionSignatures) ProtoMessage() {}

func (x *TokenTransactionSignatures) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenTransactionSignatures.ProtoReflect.Descriptor instead.
func (*TokenTransactionSignatures) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{42}
}

func (x *TokenTransactionSignatures) GetOwnerSignatures() []*SignatureWithIndex {
	if x != nil {
		return x.OwnerSignatures
	}
	return nil
}

type StartTokenTransactionRequest struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	IdentityPublicKey       []byte                 `protobuf:"bytes,1,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	PartialTokenTransaction *TokenTransaction      `protobuf:"bytes,2,opt,name=partial_token_transaction,json=partialTokenTransaction,proto3" json:"partial_token_transaction,omitempty"`
	// List of ecdsa signatures authorizing movement of tokens from the token input.
	TokenTransactionSignatures *TokenTransactionSignatures `protobuf:"bytes,3,opt,name=token_transaction_signatures,json=tokenTransactionSignatures,proto3" json:"token_transaction_signatures,omitempty"`
	SparkPaymentIntent         string                      `protobuf:"bytes,4,opt,name=spark_payment_intent,json=sparkPaymentIntent,proto3" json:"spark_payment_intent,omitempty"`
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *StartTokenTransactionRequest) Reset() {
	*x = StartTokenTransactionRequest{}
	mi := &file_spark_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartTokenTransactionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartTokenTransactionRequest) ProtoMessage() {}

func (x *StartTokenTransactionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartTokenTransactionRequest.ProtoReflect.Descriptor instead.
func (*StartTokenTransactionRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{43}
}

func (x *StartTokenTransactionRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

func (x *StartTokenTransactionRequest) GetPartialTokenTransaction() *TokenTransaction {
	if x != nil {
		return x.PartialTokenTransaction
	}
	return nil
}

func (x *StartTokenTransactionRequest) GetTokenTransactionSignatures() *TokenTransactionSignatures {
	if x != nil {
		return x.TokenTransactionSignatures
	}
	return nil
}

func (x *StartTokenTransactionRequest) GetSparkPaymentIntent() string {
	if x != nil {
		return x.SparkPaymentIntent
	}
	return ""
}

type StartTokenTransactionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This is the same token transaction sent by the wallet with output revocation public keys
	// filled. This is the final transaction that is published and gossiped among LRC20 nodes.
	FinalTokenTransaction *TokenTransaction `protobuf:"bytes,1,opt,name=final_token_transaction,json=finalTokenTransaction,proto3" json:"final_token_transaction,omitempty"`
	// Information for fetching and resolving the revocation keyshare on a transfer operation.
	// Contains the threshold of keyshares needed and the SO owners of those keyshares.
	KeyshareInfo  *SigningKeyshare `protobuf:"bytes,2,opt,name=keyshare_info,json=keyshareInfo,proto3" json:"keyshare_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StartTokenTransactionResponse) Reset() {
	*x = StartTokenTransactionResponse{}
	mi := &file_spark_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartTokenTransactionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartTokenTransactionResponse) ProtoMessage() {}

func (x *StartTokenTransactionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartTokenTransactionResponse.ProtoReflect.Descriptor instead.
func (*StartTokenTransactionResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{44}
}

func (x *StartTokenTransactionResponse) GetFinalTokenTransaction() *TokenTransaction {
	if x != nil {
		return x.FinalTokenTransaction
	}
	return nil
}

func (x *StartTokenTransactionResponse) GetKeyshareInfo() *SigningKeyshare {
	if x != nil {
		return x.KeyshareInfo
	}
	return nil
}

type OperatorSpecificTokenTransactionSignablePayload struct {
	state                     protoimpl.MessageState `protogen:"open.v1"`
	FinalTokenTransactionHash []byte                 `protobuf:"bytes,1,opt,name=final_token_transaction_hash,json=finalTokenTransactionHash,proto3" json:"final_token_transaction_hash,omitempty"`
	OperatorIdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=operator_identity_public_key,json=operatorIdentityPublicKey,proto3" json:"operator_identity_public_key,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *OperatorSpecificTokenTransactionSignablePayload) Reset() {
	*x = OperatorSpecificTokenTransactionSignablePayload{}
	mi := &file_spark_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OperatorSpecificTokenTransactionSignablePayload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperatorSpecificTokenTransactionSignablePayload) ProtoMessage() {}

func (x *OperatorSpecificTokenTransactionSignablePayload) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperatorSpecificTokenTransactionSignablePayload.ProtoReflect.Descriptor instead.
func (*OperatorSpecificTokenTransactionSignablePayload) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{45}
}

func (x *OperatorSpecificTokenTransactionSignablePayload) GetFinalTokenTransactionHash() []byte {
	if x != nil {
		return x.FinalTokenTransactionHash
	}
	return nil
}

func (x *OperatorSpecificTokenTransactionSignablePayload) GetOperatorIdentityPublicKey() []byte {
	if x != nil {
		return x.OperatorIdentityPublicKey
	}
	return nil
}

// This message allows the sender of a output being spent to provide final evidence
// that it owns a output to an SO when requesting signing and release of the  revocation keyshare.
type OperatorSpecificOwnerSignature struct {
	state          protoimpl.MessageState                           `protogen:"open.v1"`
	OwnerSignature *SignatureWithIndex                              `protobuf:"bytes,1,opt,name=owner_signature,json=ownerSignature,proto3" json:"owner_signature,omitempty"`
	Payload        *OperatorSpecificTokenTransactionSignablePayload `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *OperatorSpecificOwnerSignature) Reset() {
	*x = OperatorSpecificOwnerSignature{}
	mi := &file_spark_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OperatorSpecificOwnerSignature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperatorSpecificOwnerSignature) ProtoMessage() {}

func (x *OperatorSpecificOwnerSignature) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperatorSpecificOwnerSignature.ProtoReflect.Descriptor instead.
func (*OperatorSpecificOwnerSignature) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{46}
}

func (x *OperatorSpecificOwnerSignature) GetOwnerSignature() *SignatureWithIndex {
	if x != nil {
		return x.OwnerSignature
	}
	return nil
}

func (x *OperatorSpecificOwnerSignature) GetPayload() *OperatorSpecificTokenTransactionSignablePayload {
	if x != nil {
		return x.Payload
	}
	return nil
}

type SignTokenTransactionRequest struct {
	state                      protoimpl.MessageState            `protogen:"open.v1"`
	FinalTokenTransaction      *TokenTransaction                 `protobuf:"bytes,1,opt,name=final_token_transaction,json=finalTokenTransaction,proto3" json:"final_token_transaction,omitempty"`
	OperatorSpecificSignatures []*OperatorSpecificOwnerSignature `protobuf:"bytes,2,rep,name=operator_specific_signatures,json=operatorSpecificSignatures,proto3" json:"operator_specific_signatures,omitempty"`
	IdentityPublicKey          []byte                            `protobuf:"bytes,3,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *SignTokenTransactionRequest) Reset() {
	*x = SignTokenTransactionRequest{}
	mi := &file_spark_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignTokenTransactionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignTokenTransactionRequest) ProtoMessage() {}

func (x *SignTokenTransactionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignTokenTransactionRequest.ProtoReflect.Descriptor instead.
func (*SignTokenTransactionRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{47}
}

func (x *SignTokenTransactionRequest) GetFinalTokenTransaction() *TokenTransaction {
	if x != nil {
		return x.FinalTokenTransaction
	}
	return nil
}

func (x *SignTokenTransactionRequest) GetOperatorSpecificSignatures() []*OperatorSpecificOwnerSignature {
	if x != nil {
		return x.OperatorSpecificSignatures
	}
	return nil
}

func (x *SignTokenTransactionRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

type KeyshareWithIndex struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The index of the input TTXO associated with this keyshare.
	InputIndex    uint32 `protobuf:"varint,1,opt,name=input_index,json=inputIndex,proto3" json:"input_index,omitempty"`
	Keyshare      []byte `protobuf:"bytes,2,opt,name=keyshare,proto3" json:"keyshare,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeyshareWithIndex) Reset() {
	*x = KeyshareWithIndex{}
	mi := &file_spark_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyshareWithIndex) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyshareWithIndex) ProtoMessage() {}

func (x *KeyshareWithIndex) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyshareWithIndex.ProtoReflect.Descriptor instead.
func (*KeyshareWithIndex) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{48}
}

func (x *KeyshareWithIndex) GetInputIndex() uint32 {
	if x != nil {
		return x.InputIndex
	}
	return 0
}

func (x *KeyshareWithIndex) GetKeyshare() []byte {
	if x != nil {
		return x.Keyshare
	}
	return nil
}

type SignTokenTransactionResponse struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	SparkOperatorSignature []byte                 `protobuf:"bytes,1,opt,name=spark_operator_signature,json=sparkOperatorSignature,proto3" json:"spark_operator_signature,omitempty"`
	RevocationKeyshares    []*KeyshareWithIndex   `protobuf:"bytes,2,rep,name=revocation_keyshares,json=revocationKeyshares,proto3" json:"revocation_keyshares,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *SignTokenTransactionResponse) Reset() {
	*x = SignTokenTransactionResponse{}
	mi := &file_spark_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignTokenTransactionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignTokenTransactionResponse) ProtoMessage() {}

func (x *SignTokenTransactionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignTokenTransactionResponse.ProtoReflect.Descriptor instead.
func (*SignTokenTransactionResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{49}
}

func (x *SignTokenTransactionResponse) GetSparkOperatorSignature() []byte {
	if x != nil {
		return x.SparkOperatorSignature
	}
	return nil
}

func (x *SignTokenTransactionResponse) GetRevocationKeyshares() []*KeyshareWithIndex {
	if x != nil {
		return x.RevocationKeyshares
	}
	return nil
}

type RevocationSecretWithIndex struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The index of the input TTXO associated with this secret.
	InputIndex       uint32 `protobuf:"varint,1,opt,name=input_index,json=inputIndex,proto3" json:"input_index,omitempty"`
	RevocationSecret []byte `protobuf:"bytes,2,opt,name=revocation_secret,json=revocationSecret,proto3" json:"revocation_secret,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *RevocationSecretWithIndex) Reset() {
	*x = RevocationSecretWithIndex{}
	mi := &file_spark_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RevocationSecretWithIndex) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RevocationSecretWithIndex) ProtoMessage() {}

func (x *RevocationSecretWithIndex) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RevocationSecretWithIndex.ProtoReflect.Descriptor instead.
func (*RevocationSecretWithIndex) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{50}
}

func (x *RevocationSecretWithIndex) GetInputIndex() uint32 {
	if x != nil {
		return x.InputIndex
	}
	return 0
}

func (x *RevocationSecretWithIndex) GetRevocationSecret() []byte {
	if x != nil {
		return x.RevocationSecret
	}
	return nil
}

type FinalizeTokenTransactionRequest struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	FinalTokenTransaction *TokenTransaction      `protobuf:"bytes,1,opt,name=final_token_transaction,json=finalTokenTransaction,proto3" json:"final_token_transaction,omitempty"`
	// List of ordered revocation secrets that map 1:1 with leaves being spent in the
	// token transaction.
	RevocationSecrets  []*RevocationSecretWithIndex `protobuf:"bytes,2,rep,name=revocation_secrets,json=revocationSecrets,proto3" json:"revocation_secrets,omitempty"`
	IdentityPublicKey  []byte                       `protobuf:"bytes,3,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	SparkPaymentIntent string                       `protobuf:"bytes,4,opt,name=spark_payment_intent,json=sparkPaymentIntent,proto3" json:"spark_payment_intent,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *FinalizeTokenTransactionRequest) Reset() {
	*x = FinalizeTokenTransactionRequest{}
	mi := &file_spark_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FinalizeTokenTransactionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FinalizeTokenTransactionRequest) ProtoMessage() {}

func (x *FinalizeTokenTransactionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FinalizeTokenTransactionRequest.ProtoReflect.Descriptor instead.
func (*FinalizeTokenTransactionRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{51}
}

func (x *FinalizeTokenTransactionRequest) GetFinalTokenTransaction() *TokenTransaction {
	if x != nil {
		return x.FinalTokenTransaction
	}
	return nil
}

func (x *FinalizeTokenTransactionRequest) GetRevocationSecrets() []*RevocationSecretWithIndex {
	if x != nil {
		return x.RevocationSecrets
	}
	return nil
}

func (x *FinalizeTokenTransactionRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

func (x *FinalizeTokenTransactionRequest) GetSparkPaymentIntent() string {
	if x != nil {
		return x.SparkPaymentIntent
	}
	return ""
}

type FreezeTokensPayload struct {
	state                     protoimpl.MessageState `protogen:"open.v1"`
	OwnerPublicKey            []byte                 `protobuf:"bytes,1,opt,name=owner_public_key,json=ownerPublicKey,proto3" json:"owner_public_key,omitempty"`
	TokenPublicKey            []byte                 `protobuf:"bytes,2,opt,name=token_public_key,json=tokenPublicKey,proto3" json:"token_public_key,omitempty"`
	IssuerProvidedTimestamp   uint64                 `protobuf:"varint,3,opt,name=issuer_provided_timestamp,json=issuerProvidedTimestamp,proto3" json:"issuer_provided_timestamp,omitempty"`
	OperatorIdentityPublicKey []byte                 `protobuf:"bytes,4,opt,name=operator_identity_public_key,json=operatorIdentityPublicKey,proto3" json:"operator_identity_public_key,omitempty"`
	// Set to false when requesting a freeze.
	ShouldUnfreeze  bool   `protobuf:"varint,5,opt,name=should_unfreeze,json=shouldUnfreeze,proto3" json:"should_unfreeze,omitempty"`
	TokenIdentifier []byte `protobuf:"bytes,6,opt,name=token_identifier,json=tokenIdentifier,proto3,oneof" json:"token_identifier,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *FreezeTokensPayload) Reset() {
	*x = FreezeTokensPayload{}
	mi := &file_spark_proto_msgTypes[52]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FreezeTokensPayload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FreezeTokensPayload) ProtoMessage() {}

func (x *FreezeTokensPayload) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[52]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FreezeTokensPayload.ProtoReflect.Descriptor instead.
func (*FreezeTokensPayload) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{52}
}

func (x *FreezeTokensPayload) GetOwnerPublicKey() []byte {
	if x != nil {
		return x.OwnerPublicKey
	}
	return nil
}

func (x *FreezeTokensPayload) GetTokenPublicKey() []byte {
	if x != nil {
		return x.TokenPublicKey
	}
	return nil
}

func (x *FreezeTokensPayload) GetIssuerProvidedTimestamp() uint64 {
	if x != nil {
		return x.IssuerProvidedTimestamp
	}
	return 0
}

func (x *FreezeTokensPayload) GetOperatorIdentityPublicKey() []byte {
	if x != nil {
		return x.OperatorIdentityPublicKey
	}
	return nil
}

func (x *FreezeTokensPayload) GetShouldUnfreeze() bool {
	if x != nil {
		return x.ShouldUnfreeze
	}
	return false
}

func (x *FreezeTokensPayload) GetTokenIdentifier() []byte {
	if x != nil {
		return x.TokenIdentifier
	}
	return nil
}

type FreezeTokensRequest struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	FreezeTokensPayload *FreezeTokensPayload   `protobuf:"bytes,1,opt,name=freeze_tokens_payload,json=freezeTokensPayload,proto3" json:"freeze_tokens_payload,omitempty"`
	// This is a Schnorr or ECDSA DER signature which can be between 64 and 73 bytes.
	IssuerSignature []byte `protobuf:"bytes,2,opt,name=issuer_signature,json=issuerSignature,proto3" json:"issuer_signature,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *FreezeTokensRequest) Reset() {
	*x = FreezeTokensRequest{}
	mi := &file_spark_proto_msgTypes[53]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FreezeTokensRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FreezeTokensRequest) ProtoMessage() {}

func (x *FreezeTokensRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[53]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FreezeTokensRequest.ProtoReflect.Descriptor instead.
func (*FreezeTokensRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{53}
}

func (x *FreezeTokensRequest) GetFreezeTokensPayload() *FreezeTokensPayload {
	if x != nil {
		return x.FreezeTokensPayload
	}
	return nil
}

func (x *FreezeTokensRequest) GetIssuerSignature() []byte {
	if x != nil {
		return x.IssuerSignature
	}
	return nil
}

type FreezeTokensResponse struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	ImpactedOutputIds   []string               `protobuf:"bytes,1,rep,name=impacted_output_ids,json=impactedOutputIds,proto3" json:"impacted_output_ids,omitempty"`
	ImpactedTokenAmount []byte                 `protobuf:"bytes,2,opt,name=impacted_token_amount,json=impactedTokenAmount,proto3" json:"impacted_token_amount,omitempty"` // Decoded uint128
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *FreezeTokensResponse) Reset() {
	*x = FreezeTokensResponse{}
	mi := &file_spark_proto_msgTypes[54]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FreezeTokensResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FreezeTokensResponse) ProtoMessage() {}

func (x *FreezeTokensResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[54]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FreezeTokensResponse.ProtoReflect.Descriptor instead.
func (*FreezeTokensResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{54}
}

func (x *FreezeTokensResponse) GetImpactedOutputIds() []string {
	if x != nil {
		return x.ImpactedOutputIds
	}
	return nil
}

func (x *FreezeTokensResponse) GetImpactedTokenAmount() []byte {
	if x != nil {
		return x.ImpactedTokenAmount
	}
	return nil
}

type QueryTokenOutputsRequest struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	OwnerPublicKeys [][]byte               `protobuf:"bytes,1,rep,name=owner_public_keys,json=ownerPublicKeys,proto3" json:"owner_public_keys,omitempty"`
	// Optionally provide token public keys. If not set return leaves for all tokens.
	TokenPublicKeys  [][]byte `protobuf:"bytes,2,rep,name=token_public_keys,json=tokenPublicKeys,proto3" json:"token_public_keys,omitempty"`
	TokenIdentifiers [][]byte `protobuf:"bytes,4,rep,name=token_identifiers,json=tokenIdentifiers,proto3" json:"token_identifiers,omitempty"`
	Network          Network  `protobuf:"varint,3,opt,name=network,proto3,enum=spark.Network" json:"network,omitempty"` // defaults to mainnet when no network is provided.
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *QueryTokenOutputsRequest) Reset() {
	*x = QueryTokenOutputsRequest{}
	mi := &file_spark_proto_msgTypes[55]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryTokenOutputsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryTokenOutputsRequest) ProtoMessage() {}

func (x *QueryTokenOutputsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[55]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryTokenOutputsRequest.ProtoReflect.Descriptor instead.
func (*QueryTokenOutputsRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{55}
}

func (x *QueryTokenOutputsRequest) GetOwnerPublicKeys() [][]byte {
	if x != nil {
		return x.OwnerPublicKeys
	}
	return nil
}

func (x *QueryTokenOutputsRequest) GetTokenPublicKeys() [][]byte {
	if x != nil {
		return x.TokenPublicKeys
	}
	return nil
}

func (x *QueryTokenOutputsRequest) GetTokenIdentifiers() [][]byte {
	if x != nil {
		return x.TokenIdentifiers
	}
	return nil
}

func (x *QueryTokenOutputsRequest) GetNetwork() Network {
	if x != nil {
		return x.Network
	}
	return Network_UNSPECIFIED
}

// Request constraints are combined using an AND relation.
type QueryTokenTransactionsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Returns transactions that have one of these output ids in the input or output.
	OutputIds []string `protobuf:"bytes,1,rep,name=output_ids,json=outputIds,proto3" json:"output_ids,omitempty"`
	// Returns transactions that have this owner public key as the sender or receiver in one or more of the input/output leaves.
	OwnerPublicKeys [][]byte `protobuf:"bytes,2,rep,name=owner_public_keys,json=ownerPublicKeys,proto3" json:"owner_public_keys,omitempty"`
	// Returns transactions that related to this token public key.
	TokenPublicKeys [][]byte `protobuf:"bytes,3,rep,name=token_public_keys,json=tokenPublicKeys,proto3" json:"token_public_keys,omitempty"`
	// Returns transactions that related to this token identifier.
	TokenIdentifiers [][]byte `protobuf:"bytes,7,rep,name=token_identifiers,json=tokenIdentifiers,proto3" json:"token_identifiers,omitempty"`
	// Returns transactions that match the provided transaction hashes.
	TokenTransactionHashes [][]byte `protobuf:"bytes,4,rep,name=token_transaction_hashes,json=tokenTransactionHashes,proto3" json:"token_transaction_hashes,omitempty"`
	Limit                  int64    `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset                 int64    `protobuf:"varint,6,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *QueryTokenTransactionsRequest) Reset() {
	*x = QueryTokenTransactionsRequest{}
	mi := &file_spark_proto_msgTypes[56]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryTokenTransactionsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryTokenTransactionsRequest) ProtoMessage() {}

func (x *QueryTokenTransactionsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[56]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryTokenTransactionsRequest.ProtoReflect.Descriptor instead.
func (*QueryTokenTransactionsRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{56}
}

func (x *QueryTokenTransactionsRequest) GetOutputIds() []string {
	if x != nil {
		return x.OutputIds
	}
	return nil
}

func (x *QueryTokenTransactionsRequest) GetOwnerPublicKeys() [][]byte {
	if x != nil {
		return x.OwnerPublicKeys
	}
	return nil
}

func (x *QueryTokenTransactionsRequest) GetTokenPublicKeys() [][]byte {
	if x != nil {
		return x.TokenPublicKeys
	}
	return nil
}

func (x *QueryTokenTransactionsRequest) GetTokenIdentifiers() [][]byte {
	if x != nil {
		return x.TokenIdentifiers
	}
	return nil
}

func (x *QueryTokenTransactionsRequest) GetTokenTransactionHashes() [][]byte {
	if x != nil {
		return x.TokenTransactionHashes
	}
	return nil
}

func (x *QueryTokenTransactionsRequest) GetLimit() int64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *QueryTokenTransactionsRequest) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type QueryTokenTransactionsResponse struct {
	state                       protoimpl.MessageState        `protogen:"open.v1"`
	TokenTransactionsWithStatus []*TokenTransactionWithStatus `protobuf:"bytes,1,rep,name=token_transactions_with_status,json=tokenTransactionsWithStatus,proto3" json:"token_transactions_with_status,omitempty"`
	Offset                      int64                         `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields               protoimpl.UnknownFields
	sizeCache                   protoimpl.SizeCache
}

func (x *QueryTokenTransactionsResponse) Reset() {
	*x = QueryTokenTransactionsResponse{}
	mi := &file_spark_proto_msgTypes[57]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryTokenTransactionsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryTokenTransactionsResponse) ProtoMessage() {}

func (x *QueryTokenTransactionsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[57]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryTokenTransactionsResponse.ProtoReflect.Descriptor instead.
func (*QueryTokenTransactionsResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{57}
}

func (x *QueryTokenTransactionsResponse) GetTokenTransactionsWithStatus() []*TokenTransactionWithStatus {
	if x != nil {
		return x.TokenTransactionsWithStatus
	}
	return nil
}

func (x *QueryTokenTransactionsResponse) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type OutputWithPreviousTransactionData struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	Output                  *TokenOutput           `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
	PreviousTransactionHash []byte                 `protobuf:"bytes,2,opt,name=previous_transaction_hash,json=previousTransactionHash,proto3" json:"previous_transaction_hash,omitempty"`
	PreviousTransactionVout uint32                 `protobuf:"varint,3,opt,name=previous_transaction_vout,json=previousTransactionVout,proto3" json:"previous_transaction_vout,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *OutputWithPreviousTransactionData) Reset() {
	*x = OutputWithPreviousTransactionData{}
	mi := &file_spark_proto_msgTypes[58]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OutputWithPreviousTransactionData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OutputWithPreviousTransactionData) ProtoMessage() {}

func (x *OutputWithPreviousTransactionData) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[58]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OutputWithPreviousTransactionData.ProtoReflect.Descriptor instead.
func (*OutputWithPreviousTransactionData) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{58}
}

func (x *OutputWithPreviousTransactionData) GetOutput() *TokenOutput {
	if x != nil {
		return x.Output
	}
	return nil
}

func (x *OutputWithPreviousTransactionData) GetPreviousTransactionHash() []byte {
	if x != nil {
		return x.PreviousTransactionHash
	}
	return nil
}

func (x *OutputWithPreviousTransactionData) GetPreviousTransactionVout() uint32 {
	if x != nil {
		return x.PreviousTransactionVout
	}
	return 0
}

type QueryTokenOutputsResponse struct {
	state                              protoimpl.MessageState               `protogen:"open.v1"`
	OutputsWithPreviousTransactionData []*OutputWithPreviousTransactionData `protobuf:"bytes,1,rep,name=outputs_with_previous_transaction_data,json=outputsWithPreviousTransactionData,proto3" json:"outputs_with_previous_transaction_data,omitempty"`
	unknownFields                      protoimpl.UnknownFields
	sizeCache                          protoimpl.SizeCache
}

func (x *QueryTokenOutputsResponse) Reset() {
	*x = QueryTokenOutputsResponse{}
	mi := &file_spark_proto_msgTypes[59]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryTokenOutputsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryTokenOutputsResponse) ProtoMessage() {}

func (x *QueryTokenOutputsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[59]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryTokenOutputsResponse.ProtoReflect.Descriptor instead.
func (*QueryTokenOutputsResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{59}
}

func (x *QueryTokenOutputsResponse) GetOutputsWithPreviousTransactionData() []*OutputWithPreviousTransactionData {
	if x != nil {
		return x.OutputsWithPreviousTransactionData
	}
	return nil
}

// *
// TreeNode represents a node on the tree.
type TreeNode struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The id of the node.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The id of the tree for this node .
	TreeId string `protobuf:"bytes,2,opt,name=tree_id,json=treeId,proto3" json:"tree_id,omitempty"`
	// The value that this node holds.
	Value uint64 `protobuf:"varint,3,opt,name=value,proto3" json:"value,omitempty"`
	// The id of the parent node.
	ParentNodeId *string `protobuf:"bytes,4,opt,name=parent_node_id,json=parentNodeId,proto3,oneof" json:"parent_node_id,omitempty"`
	// The cpfp transaction of the node, this transaction is to pay to the same address as the node.
	NodeTx []byte `protobuf:"bytes,5,opt,name=node_tx,json=nodeTx,proto3" json:"node_tx,omitempty"`
	// The refund transaction of the node, this transaction is to pay to the user.
	RefundTx []byte `protobuf:"bytes,6,opt,name=refund_tx,json=refundTx,proto3" json:"refund_tx,omitempty"`
	// This vout is the vout to spend the previous transaction, which is in the parent node.
	Vout uint32 `protobuf:"varint,7,opt,name=vout,proto3" json:"vout,omitempty"`
	// The verifying public key of the node.
	VerifyingPublicKey []byte `protobuf:"bytes,8,opt,name=verifying_public_key,json=verifyingPublicKey,proto3" json:"verifying_public_key,omitempty"`
	// The identity public key of the owner of the node.
	OwnerIdentityPublicKey []byte `protobuf:"bytes,9,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	// The signing keyshare information of the node on the SE side.
	SigningKeyshare *SigningKeyshare `protobuf:"bytes,10,opt,name=signing_keyshare,json=signingKeyshare,proto3" json:"signing_keyshare,omitempty"`
	// The status of the node.
	Status string `protobuf:"bytes,11,opt,name=status,proto3" json:"status,omitempty"`
	// The network of the node.
	Network Network `protobuf:"varint,12,opt,name=network,proto3,enum=spark.Network" json:"network,omitempty"`
	// The creation time of the node.
	CreatedTime *timestamppb.Timestamp `protobuf:"bytes,13,opt,name=created_time,json=createdTime,proto3" json:"created_time,omitempty"`
	// The latest update time of the node.
	UpdatedTime *timestamppb.Timestamp `protobuf:"bytes,14,opt,name=updated_time,json=updatedTime,proto3" json:"updated_time,omitempty"`
	// The signing public key of the owner of the node.
	OwnerSigningPublicKey []byte `protobuf:"bytes,15,opt,name=owner_signing_public_key,json=ownerSigningPublicKey,proto3" json:"owner_signing_public_key,omitempty"`
	// The direct transaction of the node, this transaction is for the watchtower to broadcast.
	DirectTx []byte `protobuf:"bytes,16,opt,name=direct_tx,json=directTx,proto3" json:"direct_tx,omitempty"`
	// The refund transaction of the node, this transaction is to pay to the user.
	DirectRefundTx []byte `protobuf:"bytes,17,opt,name=direct_refund_tx,json=directRefundTx,proto3" json:"direct_refund_tx,omitempty"`
	// The refund transaction of the node, this transaction is to pay to the user.
	DirectFromCpfpRefundTx []byte `protobuf:"bytes,18,opt,name=direct_from_cpfp_refund_tx,json=directFromCpfpRefundTx,proto3" json:"direct_from_cpfp_refund_tx,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *TreeNode) Reset() {
	*x = TreeNode{}
	mi := &file_spark_proto_msgTypes[60]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TreeNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TreeNode) ProtoMessage() {}

func (x *TreeNode) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[60]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TreeNode.ProtoReflect.Descriptor instead.
func (*TreeNode) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{60}
}

func (x *TreeNode) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *TreeNode) GetTreeId() string {
	if x != nil {
		return x.TreeId
	}
	return ""
}

func (x *TreeNode) GetValue() uint64 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *TreeNode) GetParentNodeId() string {
	if x != nil && x.ParentNodeId != nil {
		return *x.ParentNodeId
	}
	return ""
}

func (x *TreeNode) GetNodeTx() []byte {
	if x != nil {
		return x.NodeTx
	}
	return nil
}

func (x *TreeNode) GetRefundTx() []byte {
	if x != nil {
		return x.RefundTx
	}
	return nil
}

func (x *TreeNode) GetVout() uint32 {
	if x != nil {
		return x.Vout
	}
	return 0
}

func (x *TreeNode) GetVerifyingPublicKey() []byte {
	if x != nil {
		return x.VerifyingPublicKey
	}
	return nil
}

func (x *TreeNode) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

func (x *TreeNode) GetSigningKeyshare() *SigningKeyshare {
	if x != nil {
		return x.SigningKeyshare
	}
	return nil
}

func (x *TreeNode) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *TreeNode) GetNetwork() Network {
	if x != nil {
		return x.Network
	}
	return Network_UNSPECIFIED
}

func (x *TreeNode) GetCreatedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedTime
	}
	return nil
}

func (x *TreeNode) GetUpdatedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedTime
	}
	return nil
}

func (x *TreeNode) GetOwnerSigningPublicKey() []byte {
	if x != nil {
		return x.OwnerSigningPublicKey
	}
	return nil
}

func (x *TreeNode) GetDirectTx() []byte {
	if x != nil {
		return x.DirectTx
	}
	return nil
}

func (x *TreeNode) GetDirectRefundTx() []byte {
	if x != nil {
		return x.DirectRefundTx
	}
	return nil
}

func (x *TreeNode) GetDirectFromCpfpRefundTx() []byte {
	if x != nil {
		return x.DirectFromCpfpRefundTx
	}
	return nil
}

// *
// FinalizeNodeSignaturesRequest is the request to finalize the signatures for a node.
type FinalizeNodeSignaturesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The intent of the signature.
	Intent common.SignatureIntent `protobuf:"varint,1,opt,name=intent,proto3,enum=common.SignatureIntent" json:"intent,omitempty"`
	// The signatures for the node.
	NodeSignatures []*NodeSignatures `protobuf:"bytes,2,rep,name=node_signatures,json=nodeSignatures,proto3" json:"node_signatures,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *FinalizeNodeSignaturesRequest) Reset() {
	*x = FinalizeNodeSignaturesRequest{}
	mi := &file_spark_proto_msgTypes[61]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FinalizeNodeSignaturesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FinalizeNodeSignaturesRequest) ProtoMessage() {}

func (x *FinalizeNodeSignaturesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[61]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FinalizeNodeSignaturesRequest.ProtoReflect.Descriptor instead.
func (*FinalizeNodeSignaturesRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{61}
}

func (x *FinalizeNodeSignaturesRequest) GetIntent() common.SignatureIntent {
	if x != nil {
		return x.Intent
	}
	return common.SignatureIntent(0)
}

func (x *FinalizeNodeSignaturesRequest) GetNodeSignatures() []*NodeSignatures {
	if x != nil {
		return x.NodeSignatures
	}
	return nil
}

// *
// FinalizeNodeSignaturesResponse is the response to the request to finalize the signatures for a node.
type FinalizeNodeSignaturesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The nodes that are finalized.
	Nodes         []*TreeNode `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FinalizeNodeSignaturesResponse) Reset() {
	*x = FinalizeNodeSignaturesResponse{}
	mi := &file_spark_proto_msgTypes[62]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FinalizeNodeSignaturesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FinalizeNodeSignaturesResponse) ProtoMessage() {}

func (x *FinalizeNodeSignaturesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[62]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FinalizeNodeSignaturesResponse.ProtoReflect.Descriptor instead.
func (*FinalizeNodeSignaturesResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{62}
}

func (x *FinalizeNodeSignaturesResponse) GetNodes() []*TreeNode {
	if x != nil {
		return x.Nodes
	}
	return nil
}

// *
// SecretShare is a secret share of a secret, using Feldman VSS.
// The secret share is in the field of secp256k1 scalar field.
type SecretShare struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The secret share.
	SecretShare []byte `protobuf:"bytes,1,opt,name=secret_share,json=secretShare,proto3" json:"secret_share,omitempty"`
	// The proofs for the secret share. They are the compressed public keys in secp256k1 curve.
	// proofs[0] is the public key of the secret, while proofs[1..n] are the public key of the polynomial.
	Proofs        [][]byte `protobuf:"bytes,2,rep,name=proofs,proto3" json:"proofs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SecretShare) Reset() {
	*x = SecretShare{}
	mi := &file_spark_proto_msgTypes[63]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SecretShare) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecretShare) ProtoMessage() {}

func (x *SecretShare) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[63]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SecretShare.ProtoReflect.Descriptor instead.
func (*SecretShare) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{63}
}

func (x *SecretShare) GetSecretShare() []byte {
	if x != nil {
		return x.SecretShare
	}
	return nil
}

func (x *SecretShare) GetProofs() [][]byte {
	if x != nil {
		return x.Proofs
	}
	return nil
}

// *
// SecretProof is the proof for a secret share using Feldman VSS.
// The proof is the compressed public keys in secp256k1 curve.
type SecretProof struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The proofs for the secret share.
	// proofs[0] is the public key of the secret, while proofs[1..n] are the public key of the polynomial.
	Proofs        [][]byte `protobuf:"bytes,1,rep,name=proofs,proto3" json:"proofs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SecretProof) Reset() {
	*x = SecretProof{}
	mi := &file_spark_proto_msgTypes[64]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SecretProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecretProof) ProtoMessage() {}

func (x *SecretProof) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[64]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SecretProof.ProtoReflect.Descriptor instead.
func (*SecretProof) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{64}
}

func (x *SecretProof) GetProofs() [][]byte {
	if x != nil {
		return x.Proofs
	}
	return nil
}

type LeafRefundTxSigningJob struct {
	state                            protoimpl.MessageState `protogen:"open.v1"`
	LeafId                           string                 `protobuf:"bytes,1,opt,name=leaf_id,json=leafId,proto3" json:"leaf_id,omitempty"`
	RefundTxSigningJob               *SigningJob            `protobuf:"bytes,2,opt,name=refund_tx_signing_job,json=refundTxSigningJob,proto3" json:"refund_tx_signing_job,omitempty"`
	DirectRefundTxSigningJob         *SigningJob            `protobuf:"bytes,3,opt,name=direct_refund_tx_signing_job,json=directRefundTxSigningJob,proto3" json:"direct_refund_tx_signing_job,omitempty"`
	DirectFromCpfpRefundTxSigningJob *SigningJob            `protobuf:"bytes,4,opt,name=direct_from_cpfp_refund_tx_signing_job,json=directFromCpfpRefundTxSigningJob,proto3" json:"direct_from_cpfp_refund_tx_signing_job,omitempty"`
	unknownFields                    protoimpl.UnknownFields
	sizeCache                        protoimpl.SizeCache
}

func (x *LeafRefundTxSigningJob) Reset() {
	*x = LeafRefundTxSigningJob{}
	mi := &file_spark_proto_msgTypes[65]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LeafRefundTxSigningJob) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LeafRefundTxSigningJob) ProtoMessage() {}

func (x *LeafRefundTxSigningJob) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[65]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LeafRefundTxSigningJob.ProtoReflect.Descriptor instead.
func (*LeafRefundTxSigningJob) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{65}
}

func (x *LeafRefundTxSigningJob) GetLeafId() string {
	if x != nil {
		return x.LeafId
	}
	return ""
}

func (x *LeafRefundTxSigningJob) GetRefundTxSigningJob() *SigningJob {
	if x != nil {
		return x.RefundTxSigningJob
	}
	return nil
}

func (x *LeafRefundTxSigningJob) GetDirectRefundTxSigningJob() *SigningJob {
	if x != nil {
		return x.DirectRefundTxSigningJob
	}
	return nil
}

func (x *LeafRefundTxSigningJob) GetDirectFromCpfpRefundTxSigningJob() *SigningJob {
	if x != nil {
		return x.DirectFromCpfpRefundTxSigningJob
	}
	return nil
}

type UserSignedTxSigningJob struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	LeafId           string                 `protobuf:"bytes,1,opt,name=leaf_id,json=leafId,proto3" json:"leaf_id,omitempty"`
	SigningPublicKey []byte                 `protobuf:"bytes,2,opt,name=signing_public_key,json=signingPublicKey,proto3" json:"signing_public_key,omitempty"`
	// CPFP Refund Tx that is created when the User signs refunds. It spends the
	// node transaction to the receiver.
	RawTx                  []byte                    `protobuf:"bytes,3,opt,name=raw_tx,json=rawTx,proto3" json:"raw_tx,omitempty"`
	SigningNonceCommitment *common.SigningCommitment `protobuf:"bytes,4,opt,name=signing_nonce_commitment,json=signingNonceCommitment,proto3" json:"signing_nonce_commitment,omitempty"`
	UserSignature          []byte                    `protobuf:"bytes,5,opt,name=user_signature,json=userSignature,proto3" json:"user_signature,omitempty"`
	SigningCommitments     *SigningCommitments       `protobuf:"bytes,6,opt,name=signing_commitments,json=signingCommitments,proto3" json:"signing_commitments,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *UserSignedTxSigningJob) Reset() {
	*x = UserSignedTxSigningJob{}
	mi := &file_spark_proto_msgTypes[66]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserSignedTxSigningJob) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserSignedTxSigningJob) ProtoMessage() {}

func (x *UserSignedTxSigningJob) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[66]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserSignedTxSigningJob.ProtoReflect.Descriptor instead.
func (*UserSignedTxSigningJob) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{66}
}

func (x *UserSignedTxSigningJob) GetLeafId() string {
	if x != nil {
		return x.LeafId
	}
	return ""
}

func (x *UserSignedTxSigningJob) GetSigningPublicKey() []byte {
	if x != nil {
		return x.SigningPublicKey
	}
	return nil
}

func (x *UserSignedTxSigningJob) GetRawTx() []byte {
	if x != nil {
		return x.RawTx
	}
	return nil
}

func (x *UserSignedTxSigningJob) GetSigningNonceCommitment() *common.SigningCommitment {
	if x != nil {
		return x.SigningNonceCommitment
	}
	return nil
}

func (x *UserSignedTxSigningJob) GetUserSignature() []byte {
	if x != nil {
		return x.UserSignature
	}
	return nil
}

func (x *UserSignedTxSigningJob) GetSigningCommitments() *SigningCommitments {
	if x != nil {
		return x.SigningCommitments
	}
	return nil
}

type LeafRefundTxSigningResult struct {
	state                               protoimpl.MessageState `protogen:"open.v1"`
	LeafId                              string                 `protobuf:"bytes,1,opt,name=leaf_id,json=leafId,proto3" json:"leaf_id,omitempty"`
	RefundTxSigningResult               *SigningResult         `protobuf:"bytes,2,opt,name=refund_tx_signing_result,json=refundTxSigningResult,proto3" json:"refund_tx_signing_result,omitempty"`
	VerifyingKey                        []byte                 `protobuf:"bytes,3,opt,name=verifying_key,json=verifyingKey,proto3" json:"verifying_key,omitempty"`
	DirectRefundTxSigningResult         *SigningResult         `protobuf:"bytes,4,opt,name=direct_refund_tx_signing_result,json=directRefundTxSigningResult,proto3" json:"direct_refund_tx_signing_result,omitempty"`
	DirectFromCpfpRefundTxSigningResult *SigningResult         `protobuf:"bytes,5,opt,name=direct_from_cpfp_refund_tx_signing_result,json=directFromCpfpRefundTxSigningResult,proto3" json:"direct_from_cpfp_refund_tx_signing_result,omitempty"`
	unknownFields                       protoimpl.UnknownFields
	sizeCache                           protoimpl.SizeCache
}

func (x *LeafRefundTxSigningResult) Reset() {
	*x = LeafRefundTxSigningResult{}
	mi := &file_spark_proto_msgTypes[67]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LeafRefundTxSigningResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LeafRefundTxSigningResult) ProtoMessage() {}

func (x *LeafRefundTxSigningResult) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[67]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LeafRefundTxSigningResult.ProtoReflect.Descriptor instead.
func (*LeafRefundTxSigningResult) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{67}
}

func (x *LeafRefundTxSigningResult) GetLeafId() string {
	if x != nil {
		return x.LeafId
	}
	return ""
}

func (x *LeafRefundTxSigningResult) GetRefundTxSigningResult() *SigningResult {
	if x != nil {
		return x.RefundTxSigningResult
	}
	return nil
}

func (x *LeafRefundTxSigningResult) GetVerifyingKey() []byte {
	if x != nil {
		return x.VerifyingKey
	}
	return nil
}

func (x *LeafRefundTxSigningResult) GetDirectRefundTxSigningResult() *SigningResult {
	if x != nil {
		return x.DirectRefundTxSigningResult
	}
	return nil
}

func (x *LeafRefundTxSigningResult) GetDirectFromCpfpRefundTxSigningResult() *SigningResult {
	if x != nil {
		return x.DirectFromCpfpRefundTxSigningResult
	}
	return nil
}

type StartUserSignedTransferRequest struct {
	state                      protoimpl.MessageState    `protogen:"open.v1"`
	TransferId                 string                    `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	OwnerIdentityPublicKey     []byte                    `protobuf:"bytes,2,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	LeavesToSend               []*UserSignedTxSigningJob `protobuf:"bytes,3,rep,name=leaves_to_send,json=leavesToSend,proto3" json:"leaves_to_send,omitempty"`
	ReceiverIdentityPublicKey  []byte                    `protobuf:"bytes,4,opt,name=receiver_identity_public_key,json=receiverIdentityPublicKey,proto3" json:"receiver_identity_public_key,omitempty"`
	ExpiryTime                 *timestamppb.Timestamp    `protobuf:"bytes,5,opt,name=expiry_time,json=expiryTime,proto3" json:"expiry_time,omitempty"`
	DirectLeavesToSend         []*UserSignedTxSigningJob `protobuf:"bytes,6,rep,name=direct_leaves_to_send,json=directLeavesToSend,proto3" json:"direct_leaves_to_send,omitempty"`
	DirectFromCpfpLeavesToSend []*UserSignedTxSigningJob `protobuf:"bytes,7,rep,name=direct_from_cpfp_leaves_to_send,json=directFromCpfpLeavesToSend,proto3" json:"direct_from_cpfp_leaves_to_send,omitempty"`
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *StartUserSignedTransferRequest) Reset() {
	*x = StartUserSignedTransferRequest{}
	mi := &file_spark_proto_msgTypes[68]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartUserSignedTransferRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartUserSignedTransferRequest) ProtoMessage() {}

func (x *StartUserSignedTransferRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[68]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartUserSignedTransferRequest.ProtoReflect.Descriptor instead.
func (*StartUserSignedTransferRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{68}
}

func (x *StartUserSignedTransferRequest) GetTransferId() string {
	if x != nil {
		return x.TransferId
	}
	return ""
}

func (x *StartUserSignedTransferRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

func (x *StartUserSignedTransferRequest) GetLeavesToSend() []*UserSignedTxSigningJob {
	if x != nil {
		return x.LeavesToSend
	}
	return nil
}

func (x *StartUserSignedTransferRequest) GetReceiverIdentityPublicKey() []byte {
	if x != nil {
		return x.ReceiverIdentityPublicKey
	}
	return nil
}

func (x *StartUserSignedTransferRequest) GetExpiryTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpiryTime
	}
	return nil
}

func (x *StartUserSignedTransferRequest) GetDirectLeavesToSend() []*UserSignedTxSigningJob {
	if x != nil {
		return x.DirectLeavesToSend
	}
	return nil
}

func (x *StartUserSignedTransferRequest) GetDirectFromCpfpLeavesToSend() []*UserSignedTxSigningJob {
	if x != nil {
		return x.DirectFromCpfpLeavesToSend
	}
	return nil
}

type StartTransferRequest struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	TransferId             string                 `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	OwnerIdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	// This field is used for swap and coop exits. Regular transfers must use
	// the transfer_package field.
	LeavesToSend              []*LeafRefundTxSigningJob `protobuf:"bytes,3,rep,name=leaves_to_send,json=leavesToSend,proto3" json:"leaves_to_send,omitempty"`
	ReceiverIdentityPublicKey []byte                    `protobuf:"bytes,4,opt,name=receiver_identity_public_key,json=receiverIdentityPublicKey,proto3" json:"receiver_identity_public_key,omitempty"`
	ExpiryTime                *timestamppb.Timestamp    `protobuf:"bytes,5,opt,name=expiry_time,json=expiryTime,proto3" json:"expiry_time,omitempty"`
	// This field is required for transfers of type "transfer". If this field
	// is set, the leaves_to_send and key_tweak_proofs will be ignored.
	TransferPackage *TransferPackage `protobuf:"bytes,7,opt,name=transfer_package,json=transferPackage,proto3" json:"transfer_package,omitempty"`
	// The invoice this transfer pays.
	SparkInvoice  string `protobuf:"bytes,10,opt,name=spark_invoice,json=sparkInvoice,proto3" json:"spark_invoice,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StartTransferRequest) Reset() {
	*x = StartTransferRequest{}
	mi := &file_spark_proto_msgTypes[69]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartTransferRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartTransferRequest) ProtoMessage() {}

func (x *StartTransferRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[69]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartTransferRequest.ProtoReflect.Descriptor instead.
func (*StartTransferRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{69}
}

func (x *StartTransferRequest) GetTransferId() string {
	if x != nil {
		return x.TransferId
	}
	return ""
}

func (x *StartTransferRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

func (x *StartTransferRequest) GetLeavesToSend() []*LeafRefundTxSigningJob {
	if x != nil {
		return x.LeavesToSend
	}
	return nil
}

func (x *StartTransferRequest) GetReceiverIdentityPublicKey() []byte {
	if x != nil {
		return x.ReceiverIdentityPublicKey
	}
	return nil
}

func (x *StartTransferRequest) GetExpiryTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpiryTime
	}
	return nil
}

func (x *StartTransferRequest) GetTransferPackage() *TransferPackage {
	if x != nil {
		return x.TransferPackage
	}
	return nil
}

func (x *StartTransferRequest) GetSparkInvoice() string {
	if x != nil {
		return x.SparkInvoice
	}
	return ""
}

type StartTransferResponse struct {
	state          protoimpl.MessageState       `protogen:"open.v1"`
	Transfer       *Transfer                    `protobuf:"bytes,1,opt,name=transfer,proto3" json:"transfer,omitempty"`
	SigningResults []*LeafRefundTxSigningResult `protobuf:"bytes,2,rep,name=signing_results,json=signingResults,proto3" json:"signing_results,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *StartTransferResponse) Reset() {
	*x = StartTransferResponse{}
	mi := &file_spark_proto_msgTypes[70]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartTransferResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartTransferResponse) ProtoMessage() {}

func (x *StartTransferResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[70]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartTransferResponse.ProtoReflect.Descriptor instead.
func (*StartTransferResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{70}
}

func (x *StartTransferResponse) GetTransfer() *Transfer {
	if x != nil {
		return x.Transfer
	}
	return nil
}

func (x *StartTransferResponse) GetSigningResults() []*LeafRefundTxSigningResult {
	if x != nil {
		return x.SigningResults
	}
	return nil
}

// *
// TransferPackage is a package of leaves to send and key tweaks to send.
// This is in the improved send transfer flow where the sender can send the transfer in one call to
// the coordinator SO.
type TransferPackage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The leaves to send, with user signed cpfp refunds and signing package.
	LeavesToSend []*UserSignedTxSigningJob `protobuf:"bytes,1,rep,name=leaves_to_send,json=leavesToSend,proto3" json:"leaves_to_send,omitempty"`
	// The map of SO identifier to ciphertext of SendLeafTweaks.
	KeyTweakPackage map[string][]byte `protobuf:"bytes,2,rep,name=key_tweak_package,json=keyTweakPackage,proto3" json:"key_tweak_package,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The signature of user to prove that the key_tweak_package is not tampered.
	UserSignature []byte `protobuf:"bytes,3,opt,name=user_signature,json=userSignature,proto3" json:"user_signature,omitempty"`
	// The leaves to send, with user signed direct refunds and signing package.
	DirectLeavesToSend []*UserSignedTxSigningJob `protobuf:"bytes,4,rep,name=direct_leaves_to_send,json=directLeavesToSend,proto3" json:"direct_leaves_to_send,omitempty"`
	// The leaves to send, with user signed direct from cpfp refunds and signing package.
	DirectFromCpfpLeavesToSend []*UserSignedTxSigningJob `protobuf:"bytes,5,rep,name=direct_from_cpfp_leaves_to_send,json=directFromCpfpLeavesToSend,proto3" json:"direct_from_cpfp_leaves_to_send,omitempty"`
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *TransferPackage) Reset() {
	*x = TransferPackage{}
	mi := &file_spark_proto_msgTypes[71]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransferPackage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransferPackage) ProtoMessage() {}

func (x *TransferPackage) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[71]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransferPackage.ProtoReflect.Descriptor instead.
func (*TransferPackage) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{71}
}

func (x *TransferPackage) GetLeavesToSend() []*UserSignedTxSigningJob {
	if x != nil {
		return x.LeavesToSend
	}
	return nil
}

func (x *TransferPackage) GetKeyTweakPackage() map[string][]byte {
	if x != nil {
		return x.KeyTweakPackage
	}
	return nil
}

func (x *TransferPackage) GetUserSignature() []byte {
	if x != nil {
		return x.UserSignature
	}
	return nil
}

func (x *TransferPackage) GetDirectLeavesToSend() []*UserSignedTxSigningJob {
	if x != nil {
		return x.DirectLeavesToSend
	}
	return nil
}

func (x *TransferPackage) GetDirectFromCpfpLeavesToSend() []*UserSignedTxSigningJob {
	if x != nil {
		return x.DirectFromCpfpLeavesToSend
	}
	return nil
}

type SendLeafKeyTweaks struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	LeavesToSend  []*SendLeafKeyTweak    `protobuf:"bytes,1,rep,name=leaves_to_send,json=leavesToSend,proto3" json:"leaves_to_send,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SendLeafKeyTweaks) Reset() {
	*x = SendLeafKeyTweaks{}
	mi := &file_spark_proto_msgTypes[72]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendLeafKeyTweaks) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendLeafKeyTweaks) ProtoMessage() {}

func (x *SendLeafKeyTweaks) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[72]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendLeafKeyTweaks.ProtoReflect.Descriptor instead.
func (*SendLeafKeyTweaks) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{72}
}

func (x *SendLeafKeyTweaks) GetLeavesToSend() []*SendLeafKeyTweak {
	if x != nil {
		return x.LeavesToSend
	}
	return nil
}

type SendLeafKeyTweak struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	LeafId            string                 `protobuf:"bytes,1,opt,name=leaf_id,json=leafId,proto3" json:"leaf_id,omitempty"`
	SecretShareTweak  *SecretShare           `protobuf:"bytes,2,opt,name=secret_share_tweak,json=secretShareTweak,proto3" json:"secret_share_tweak,omitempty"`
	PubkeySharesTweak map[string][]byte      `protobuf:"bytes,3,rep,name=pubkey_shares_tweak,json=pubkeySharesTweak,proto3" json:"pubkey_shares_tweak,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	SecretCipher      []byte                 `protobuf:"bytes,4,opt,name=secret_cipher,json=secretCipher,proto3" json:"secret_cipher,omitempty"`
	// Signature over Sha256(leaf_id||transfer_id||secret_cipher)
	Signature                     []byte `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty"`
	RefundSignature               []byte `protobuf:"bytes,6,opt,name=refund_signature,json=refundSignature,proto3" json:"refund_signature,omitempty"`
	DirectRefundSignature         []byte `protobuf:"bytes,7,opt,name=direct_refund_signature,json=directRefundSignature,proto3" json:"direct_refund_signature,omitempty"`
	DirectFromCpfpRefundSignature []byte `protobuf:"bytes,8,opt,name=direct_from_cpfp_refund_signature,json=directFromCpfpRefundSignature,proto3" json:"direct_from_cpfp_refund_signature,omitempty"`
	unknownFields                 protoimpl.UnknownFields
	sizeCache                     protoimpl.SizeCache
}

func (x *SendLeafKeyTweak) Reset() {
	*x = SendLeafKeyTweak{}
	mi := &file_spark_proto_msgTypes[73]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendLeafKeyTweak) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendLeafKeyTweak) ProtoMessage() {}

func (x *SendLeafKeyTweak) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[73]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendLeafKeyTweak.ProtoReflect.Descriptor instead.
func (*SendLeafKeyTweak) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{73}
}

func (x *SendLeafKeyTweak) GetLeafId() string {
	if x != nil {
		return x.LeafId
	}
	return ""
}

func (x *SendLeafKeyTweak) GetSecretShareTweak() *SecretShare {
	if x != nil {
		return x.SecretShareTweak
	}
	return nil
}

func (x *SendLeafKeyTweak) GetPubkeySharesTweak() map[string][]byte {
	if x != nil {
		return x.PubkeySharesTweak
	}
	return nil
}

func (x *SendLeafKeyTweak) GetSecretCipher() []byte {
	if x != nil {
		return x.SecretCipher
	}
	return nil
}

func (x *SendLeafKeyTweak) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *SendLeafKeyTweak) GetRefundSignature() []byte {
	if x != nil {
		return x.RefundSignature
	}
	return nil
}

func (x *SendLeafKeyTweak) GetDirectRefundSignature() []byte {
	if x != nil {
		return x.DirectRefundSignature
	}
	return nil
}

func (x *SendLeafKeyTweak) GetDirectFromCpfpRefundSignature() []byte {
	if x != nil {
		return x.DirectFromCpfpRefundSignature
	}
	return nil
}

type FinalizeTransferRequest struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	TransferId             string                 `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	OwnerIdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	LeavesToSend           []*SendLeafKeyTweak    `protobuf:"bytes,3,rep,name=leaves_to_send,json=leavesToSend,proto3" json:"leaves_to_send,omitempty"`
	SparkPaymentIntent     string                 `protobuf:"bytes,4,opt,name=spark_payment_intent,json=sparkPaymentIntent,proto3" json:"spark_payment_intent,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *FinalizeTransferRequest) Reset() {
	*x = FinalizeTransferRequest{}
	mi := &file_spark_proto_msgTypes[74]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FinalizeTransferRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FinalizeTransferRequest) ProtoMessage() {}

func (x *FinalizeTransferRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[74]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FinalizeTransferRequest.ProtoReflect.Descriptor instead.
func (*FinalizeTransferRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{74}
}

func (x *FinalizeTransferRequest) GetTransferId() string {
	if x != nil {
		return x.TransferId
	}
	return ""
}

func (x *FinalizeTransferRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

func (x *FinalizeTransferRequest) GetLeavesToSend() []*SendLeafKeyTweak {
	if x != nil {
		return x.LeavesToSend
	}
	return nil
}

func (x *FinalizeTransferRequest) GetSparkPaymentIntent() string {
	if x != nil {
		return x.SparkPaymentIntent
	}
	return ""
}

type FinalizeTransferWithTransferPackageRequest struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	TransferId             string                 `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	OwnerIdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	TransferPackage        *TransferPackage       `protobuf:"bytes,3,opt,name=transfer_package,json=transferPackage,proto3" json:"transfer_package,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *FinalizeTransferWithTransferPackageRequest) Reset() {
	*x = FinalizeTransferWithTransferPackageRequest{}
	mi := &file_spark_proto_msgTypes[75]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FinalizeTransferWithTransferPackageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FinalizeTransferWithTransferPackageRequest) ProtoMessage() {}

func (x *FinalizeTransferWithTransferPackageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[75]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FinalizeTransferWithTransferPackageRequest.ProtoReflect.Descriptor instead.
func (*FinalizeTransferWithTransferPackageRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{75}
}

func (x *FinalizeTransferWithTransferPackageRequest) GetTransferId() string {
	if x != nil {
		return x.TransferId
	}
	return ""
}

func (x *FinalizeTransferWithTransferPackageRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

func (x *FinalizeTransferWithTransferPackageRequest) GetTransferPackage() *TransferPackage {
	if x != nil {
		return x.TransferPackage
	}
	return nil
}

type FinalizeTransferResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Transfer      *Transfer              `protobuf:"bytes,1,opt,name=transfer,proto3" json:"transfer,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FinalizeTransferResponse) Reset() {
	*x = FinalizeTransferResponse{}
	mi := &file_spark_proto_msgTypes[76]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FinalizeTransferResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FinalizeTransferResponse) ProtoMessage() {}

func (x *FinalizeTransferResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[76]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FinalizeTransferResponse.ProtoReflect.Descriptor instead.
func (*FinalizeTransferResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{76}
}

func (x *FinalizeTransferResponse) GetTransfer() *Transfer {
	if x != nil {
		return x.Transfer
	}
	return nil
}

type Transfer struct {
	state                     protoimpl.MessageState `protogen:"open.v1"`
	Id                        string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	SenderIdentityPublicKey   []byte                 `protobuf:"bytes,2,opt,name=sender_identity_public_key,json=senderIdentityPublicKey,proto3" json:"sender_identity_public_key,omitempty"`
	ReceiverIdentityPublicKey []byte                 `protobuf:"bytes,3,opt,name=receiver_identity_public_key,json=receiverIdentityPublicKey,proto3" json:"receiver_identity_public_key,omitempty"`
	Status                    TransferStatus         `protobuf:"varint,4,opt,name=status,proto3,enum=spark.TransferStatus" json:"status,omitempty"`
	TotalValue                uint64                 `protobuf:"varint,5,opt,name=total_value,json=totalValue,proto3" json:"total_value,omitempty"`
	ExpiryTime                *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=expiry_time,json=expiryTime,proto3" json:"expiry_time,omitempty"`
	Leaves                    []*TransferLeaf        `protobuf:"bytes,7,rep,name=leaves,proto3" json:"leaves,omitempty"`
	CreatedTime               *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=created_time,json=createdTime,proto3" json:"created_time,omitempty"`
	UpdatedTime               *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=updated_time,json=updatedTime,proto3" json:"updated_time,omitempty"`
	Type                      TransferType           `protobuf:"varint,10,opt,name=type,proto3,enum=spark.TransferType" json:"type,omitempty"`
	SparkInvoice              string                 `protobuf:"bytes,11,opt,name=spark_invoice,json=sparkInvoice,proto3" json:"spark_invoice,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *Transfer) Reset() {
	*x = Transfer{}
	mi := &file_spark_proto_msgTypes[77]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Transfer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Transfer) ProtoMessage() {}

func (x *Transfer) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[77]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Transfer.ProtoReflect.Descriptor instead.
func (*Transfer) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{77}
}

func (x *Transfer) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Transfer) GetSenderIdentityPublicKey() []byte {
	if x != nil {
		return x.SenderIdentityPublicKey
	}
	return nil
}

func (x *Transfer) GetReceiverIdentityPublicKey() []byte {
	if x != nil {
		return x.ReceiverIdentityPublicKey
	}
	return nil
}

func (x *Transfer) GetStatus() TransferStatus {
	if x != nil {
		return x.Status
	}
	return TransferStatus_TRANSFER_STATUS_SENDER_INITIATED
}

func (x *Transfer) GetTotalValue() uint64 {
	if x != nil {
		return x.TotalValue
	}
	return 0
}

func (x *Transfer) GetExpiryTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpiryTime
	}
	return nil
}

func (x *Transfer) GetLeaves() []*TransferLeaf {
	if x != nil {
		return x.Leaves
	}
	return nil
}

func (x *Transfer) GetCreatedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedTime
	}
	return nil
}

func (x *Transfer) GetUpdatedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedTime
	}
	return nil
}

func (x *Transfer) GetType() TransferType {
	if x != nil {
		return x.Type
	}
	return TransferType_PREIMAGE_SWAP
}

func (x *Transfer) GetSparkInvoice() string {
	if x != nil {
		return x.SparkInvoice
	}
	return ""
}

type TransferLeaf struct {
	state                              protoimpl.MessageState `protogen:"open.v1"`
	Leaf                               *TreeNode              `protobuf:"bytes,1,opt,name=leaf,proto3" json:"leaf,omitempty"`
	SecretCipher                       []byte                 `protobuf:"bytes,2,opt,name=secret_cipher,json=secretCipher,proto3" json:"secret_cipher,omitempty"`
	Signature                          []byte                 `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	IntermediateRefundTx               []byte                 `protobuf:"bytes,4,opt,name=intermediate_refund_tx,json=intermediateRefundTx,proto3" json:"intermediate_refund_tx,omitempty"`
	IntermediateDirectRefundTx         []byte                 `protobuf:"bytes,5,opt,name=intermediate_direct_refund_tx,json=intermediateDirectRefundTx,proto3" json:"intermediate_direct_refund_tx,omitempty"`
	IntermediateDirectFromCpfpRefundTx []byte                 `protobuf:"bytes,6,opt,name=intermediate_direct_from_cpfp_refund_tx,json=intermediateDirectFromCpfpRefundTx,proto3" json:"intermediate_direct_from_cpfp_refund_tx,omitempty"`
	PendingKeyTweakPublicKey           []byte                 `protobuf:"bytes,7,opt,name=pending_key_tweak_public_key,json=pendingKeyTweakPublicKey,proto3" json:"pending_key_tweak_public_key,omitempty"`
	unknownFields                      protoimpl.UnknownFields
	sizeCache                          protoimpl.SizeCache
}

func (x *TransferLeaf) Reset() {
	*x = TransferLeaf{}
	mi := &file_spark_proto_msgTypes[78]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransferLeaf) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransferLeaf) ProtoMessage() {}

func (x *TransferLeaf) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[78]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransferLeaf.ProtoReflect.Descriptor instead.
func (*TransferLeaf) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{78}
}

func (x *TransferLeaf) GetLeaf() *TreeNode {
	if x != nil {
		return x.Leaf
	}
	return nil
}

func (x *TransferLeaf) GetSecretCipher() []byte {
	if x != nil {
		return x.SecretCipher
	}
	return nil
}

func (x *TransferLeaf) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *TransferLeaf) GetIntermediateRefundTx() []byte {
	if x != nil {
		return x.IntermediateRefundTx
	}
	return nil
}

func (x *TransferLeaf) GetIntermediateDirectRefundTx() []byte {
	if x != nil {
		return x.IntermediateDirectRefundTx
	}
	return nil
}

func (x *TransferLeaf) GetIntermediateDirectFromCpfpRefundTx() []byte {
	if x != nil {
		return x.IntermediateDirectFromCpfpRefundTx
	}
	return nil
}

func (x *TransferLeaf) GetPendingKeyTweakPublicKey() []byte {
	if x != nil {
		return x.PendingKeyTweakPublicKey
	}
	return nil
}

type TransferFilter struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Participant:
	//
	//	*TransferFilter_ReceiverIdentityPublicKey
	//	*TransferFilter_SenderIdentityPublicKey
	//	*TransferFilter_SenderOrReceiverIdentityPublicKey
	Participant   isTransferFilter_Participant `protobuf_oneof:"participant"`
	TransferIds   []string                     `protobuf:"bytes,3,rep,name=transfer_ids,json=transferIds,proto3" json:"transfer_ids,omitempty"`
	Limit         int64                        `protobuf:"varint,40,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset        int64                        `protobuf:"varint,50,opt,name=offset,proto3" json:"offset,omitempty"`
	Types         []TransferType               `protobuf:"varint,70,rep,packed,name=types,proto3,enum=spark.TransferType" json:"types,omitempty"`
	Network       Network                      `protobuf:"varint,4,opt,name=network,proto3,enum=spark.Network" json:"network,omitempty"` // defaults to mainnet when no network is provided.
	Statuses      []TransferStatus             `protobuf:"varint,80,rep,packed,name=statuses,proto3,enum=spark.TransferStatus" json:"statuses,omitempty"`
	Order         Order                        `protobuf:"varint,5,opt,name=order,proto3,enum=spark.Order" json:"order,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TransferFilter) Reset() {
	*x = TransferFilter{}
	mi := &file_spark_proto_msgTypes[79]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransferFilter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransferFilter) ProtoMessage() {}

func (x *TransferFilter) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[79]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransferFilter.ProtoReflect.Descriptor instead.
func (*TransferFilter) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{79}
}

func (x *TransferFilter) GetParticipant() isTransferFilter_Participant {
	if x != nil {
		return x.Participant
	}
	return nil
}

func (x *TransferFilter) GetReceiverIdentityPublicKey() []byte {
	if x != nil {
		if x, ok := x.Participant.(*TransferFilter_ReceiverIdentityPublicKey); ok {
			return x.ReceiverIdentityPublicKey
		}
	}
	return nil
}

func (x *TransferFilter) GetSenderIdentityPublicKey() []byte {
	if x != nil {
		if x, ok := x.Participant.(*TransferFilter_SenderIdentityPublicKey); ok {
			return x.SenderIdentityPublicKey
		}
	}
	return nil
}

func (x *TransferFilter) GetSenderOrReceiverIdentityPublicKey() []byte {
	if x != nil {
		if x, ok := x.Participant.(*TransferFilter_SenderOrReceiverIdentityPublicKey); ok {
			return x.SenderOrReceiverIdentityPublicKey
		}
	}
	return nil
}

func (x *TransferFilter) GetTransferIds() []string {
	if x != nil {
		return x.TransferIds
	}
	return nil
}

func (x *TransferFilter) GetLimit() int64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *TransferFilter) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *TransferFilter) GetTypes() []TransferType {
	if x != nil {
		return x.Types
	}
	return nil
}

func (x *TransferFilter) GetNetwork() Network {
	if x != nil {
		return x.Network
	}
	return Network_UNSPECIFIED
}

func (x *TransferFilter) GetStatuses() []TransferStatus {
	if x != nil {
		return x.Statuses
	}
	return nil
}

func (x *TransferFilter) GetOrder() Order {
	if x != nil {
		return x.Order
	}
	return Order_DESCENDING
}

type isTransferFilter_Participant interface {
	isTransferFilter_Participant()
}

type TransferFilter_ReceiverIdentityPublicKey struct {
	ReceiverIdentityPublicKey []byte `protobuf:"bytes,1,opt,name=receiver_identity_public_key,json=receiverIdentityPublicKey,proto3,oneof"`
}

type TransferFilter_SenderIdentityPublicKey struct {
	SenderIdentityPublicKey []byte `protobuf:"bytes,2,opt,name=sender_identity_public_key,json=senderIdentityPublicKey,proto3,oneof"`
}

type TransferFilter_SenderOrReceiverIdentityPublicKey struct {
	// This will include transfers where this public key is the sender or receiver.
	SenderOrReceiverIdentityPublicKey []byte `protobuf:"bytes,60,opt,name=sender_or_receiver_identity_public_key,json=senderOrReceiverIdentityPublicKey,proto3,oneof"`
}

func (*TransferFilter_ReceiverIdentityPublicKey) isTransferFilter_Participant() {}

func (*TransferFilter_SenderIdentityPublicKey) isTransferFilter_Participant() {}

func (*TransferFilter_SenderOrReceiverIdentityPublicKey) isTransferFilter_Participant() {}

type QueryTransfersResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Transfers     []*Transfer            `protobuf:"bytes,1,rep,name=transfers,proto3" json:"transfers,omitempty"`
	Offset        int64                  `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueryTransfersResponse) Reset() {
	*x = QueryTransfersResponse{}
	mi := &file_spark_proto_msgTypes[80]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryTransfersResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryTransfersResponse) ProtoMessage() {}

func (x *QueryTransfersResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[80]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryTransfersResponse.ProtoReflect.Descriptor instead.
func (*QueryTransfersResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{80}
}

func (x *QueryTransfersResponse) GetTransfers() []*Transfer {
	if x != nil {
		return x.Transfers
	}
	return nil
}

func (x *QueryTransfersResponse) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type ClaimLeafKeyTweak struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	LeafId            string                 `protobuf:"bytes,1,opt,name=leaf_id,json=leafId,proto3" json:"leaf_id,omitempty"`
	SecretShareTweak  *SecretShare           `protobuf:"bytes,2,opt,name=secret_share_tweak,json=secretShareTweak,proto3" json:"secret_share_tweak,omitempty"`
	PubkeySharesTweak map[string][]byte      `protobuf:"bytes,3,rep,name=pubkey_shares_tweak,json=pubkeySharesTweak,proto3" json:"pubkey_shares_tweak,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ClaimLeafKeyTweak) Reset() {
	*x = ClaimLeafKeyTweak{}
	mi := &file_spark_proto_msgTypes[81]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClaimLeafKeyTweak) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClaimLeafKeyTweak) ProtoMessage() {}

func (x *ClaimLeafKeyTweak) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[81]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClaimLeafKeyTweak.ProtoReflect.Descriptor instead.
func (*ClaimLeafKeyTweak) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{81}
}

func (x *ClaimLeafKeyTweak) GetLeafId() string {
	if x != nil {
		return x.LeafId
	}
	return ""
}

func (x *ClaimLeafKeyTweak) GetSecretShareTweak() *SecretShare {
	if x != nil {
		return x.SecretShareTweak
	}
	return nil
}

func (x *ClaimLeafKeyTweak) GetPubkeySharesTweak() map[string][]byte {
	if x != nil {
		return x.PubkeySharesTweak
	}
	return nil
}

type ClaimTransferTweakKeysRequest struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	TransferId             string                 `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	OwnerIdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	LeavesToReceive        []*ClaimLeafKeyTweak   `protobuf:"bytes,3,rep,name=leaves_to_receive,json=leavesToReceive,proto3" json:"leaves_to_receive,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *ClaimTransferTweakKeysRequest) Reset() {
	*x = ClaimTransferTweakKeysRequest{}
	mi := &file_spark_proto_msgTypes[82]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClaimTransferTweakKeysRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClaimTransferTweakKeysRequest) ProtoMessage() {}

func (x *ClaimTransferTweakKeysRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[82]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClaimTransferTweakKeysRequest.ProtoReflect.Descriptor instead.
func (*ClaimTransferTweakKeysRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{82}
}

func (x *ClaimTransferTweakKeysRequest) GetTransferId() string {
	if x != nil {
		return x.TransferId
	}
	return ""
}

func (x *ClaimTransferTweakKeysRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

func (x *ClaimTransferTweakKeysRequest) GetLeavesToReceive() []*ClaimLeafKeyTweak {
	if x != nil {
		return x.LeavesToReceive
	}
	return nil
}

type ClaimTransferSignRefundsRequest struct {
	state                  protoimpl.MessageState    `protogen:"open.v1"`
	TransferId             string                    `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	OwnerIdentityPublicKey []byte                    `protobuf:"bytes,2,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	SigningJobs            []*LeafRefundTxSigningJob `protobuf:"bytes,3,rep,name=signing_jobs,json=signingJobs,proto3" json:"signing_jobs,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *ClaimTransferSignRefundsRequest) Reset() {
	*x = ClaimTransferSignRefundsRequest{}
	mi := &file_spark_proto_msgTypes[83]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClaimTransferSignRefundsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClaimTransferSignRefundsRequest) ProtoMessage() {}

func (x *ClaimTransferSignRefundsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[83]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClaimTransferSignRefundsRequest.ProtoReflect.Descriptor instead.
func (*ClaimTransferSignRefundsRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{83}
}

func (x *ClaimTransferSignRefundsRequest) GetTransferId() string {
	if x != nil {
		return x.TransferId
	}
	return ""
}

func (x *ClaimTransferSignRefundsRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

func (x *ClaimTransferSignRefundsRequest) GetSigningJobs() []*LeafRefundTxSigningJob {
	if x != nil {
		return x.SigningJobs
	}
	return nil
}

type ClaimTransferSignRefundsResponse struct {
	state          protoimpl.MessageState       `protogen:"open.v1"`
	SigningResults []*LeafRefundTxSigningResult `protobuf:"bytes,1,rep,name=signing_results,json=signingResults,proto3" json:"signing_results,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ClaimTransferSignRefundsResponse) Reset() {
	*x = ClaimTransferSignRefundsResponse{}
	mi := &file_spark_proto_msgTypes[84]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClaimTransferSignRefundsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClaimTransferSignRefundsResponse) ProtoMessage() {}

func (x *ClaimTransferSignRefundsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[84]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClaimTransferSignRefundsResponse.ProtoReflect.Descriptor instead.
func (*ClaimTransferSignRefundsResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{84}
}

func (x *ClaimTransferSignRefundsResponse) GetSigningResults() []*LeafRefundTxSigningResult {
	if x != nil {
		return x.SigningResults
	}
	return nil
}

type StorePreimageShareRequest struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	PaymentHash           []byte                 `protobuf:"bytes,1,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	PreimageShare         *SecretShare           `protobuf:"bytes,2,opt,name=preimage_share,json=preimageShare,proto3" json:"preimage_share,omitempty"`
	Threshold             uint32                 `protobuf:"varint,3,opt,name=threshold,proto3" json:"threshold,omitempty"`
	InvoiceString         string                 `protobuf:"bytes,4,opt,name=invoice_string,json=invoiceString,proto3" json:"invoice_string,omitempty"`
	UserIdentityPublicKey []byte                 `protobuf:"bytes,5,opt,name=user_identity_public_key,json=userIdentityPublicKey,proto3" json:"user_identity_public_key,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *StorePreimageShareRequest) Reset() {
	*x = StorePreimageShareRequest{}
	mi := &file_spark_proto_msgTypes[85]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StorePreimageShareRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorePreimageShareRequest) ProtoMessage() {}

func (x *StorePreimageShareRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[85]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorePreimageShareRequest.ProtoReflect.Descriptor instead.
func (*StorePreimageShareRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{85}
}

func (x *StorePreimageShareRequest) GetPaymentHash() []byte {
	if x != nil {
		return x.PaymentHash
	}
	return nil
}

func (x *StorePreimageShareRequest) GetPreimageShare() *SecretShare {
	if x != nil {
		return x.PreimageShare
	}
	return nil
}

func (x *StorePreimageShareRequest) GetThreshold() uint32 {
	if x != nil {
		return x.Threshold
	}
	return 0
}

func (x *StorePreimageShareRequest) GetInvoiceString() string {
	if x != nil {
		return x.InvoiceString
	}
	return ""
}

func (x *StorePreimageShareRequest) GetUserIdentityPublicKey() []byte {
	if x != nil {
		return x.UserIdentityPublicKey
	}
	return nil
}

type RequestedSigningCommitments struct {
	state                   protoimpl.MessageState               `protogen:"open.v1"`
	SigningNonceCommitments map[string]*common.SigningCommitment `protobuf:"bytes,1,rep,name=signing_nonce_commitments,json=signingNonceCommitments,proto3" json:"signing_nonce_commitments,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *RequestedSigningCommitments) Reset() {
	*x = RequestedSigningCommitments{}
	mi := &file_spark_proto_msgTypes[86]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RequestedSigningCommitments) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RequestedSigningCommitments) ProtoMessage() {}

func (x *RequestedSigningCommitments) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[86]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RequestedSigningCommitments.ProtoReflect.Descriptor instead.
func (*RequestedSigningCommitments) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{86}
}

func (x *RequestedSigningCommitments) GetSigningNonceCommitments() map[string]*common.SigningCommitment {
	if x != nil {
		return x.SigningNonceCommitments
	}
	return nil
}

type GetSigningCommitmentsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The node IDs for which to get signing commitments.
	NodeIds []string `protobuf:"bytes,1,rep,name=node_ids,json=nodeIds,proto3" json:"node_ids,omitempty"`
	// The number of signing commitments to get per node ID.
	Count         uint32 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetSigningCommitmentsRequest) Reset() {
	*x = GetSigningCommitmentsRequest{}
	mi := &file_spark_proto_msgTypes[87]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetSigningCommitmentsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetSigningCommitmentsRequest) ProtoMessage() {}

func (x *GetSigningCommitmentsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[87]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetSigningCommitmentsRequest.ProtoReflect.Descriptor instead.
func (*GetSigningCommitmentsRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{87}
}

func (x *GetSigningCommitmentsRequest) GetNodeIds() []string {
	if x != nil {
		return x.NodeIds
	}
	return nil
}

func (x *GetSigningCommitmentsRequest) GetCount() uint32 {
	if x != nil {
		return x.Count
	}
	return 0
}

type GetSigningCommitmentsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A list of signing commitments for each requested node ID. The signing commitments will be
	// ordered in the same order as the requested node IDs, repeated for the number of commitments
	// requested. For example, if node_ids = [A, B] and count = 2, the response will contain:
	//
	// [commitment_A1, commitment_B1, commitment_A2, commitment_B2]
	SigningCommitments []*RequestedSigningCommitments `protobuf:"bytes,1,rep,name=signing_commitments,json=signingCommitments,proto3" json:"signing_commitments,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *GetSigningCommitmentsResponse) Reset() {
	*x = GetSigningCommitmentsResponse{}
	mi := &file_spark_proto_msgTypes[88]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetSigningCommitmentsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetSigningCommitmentsResponse) ProtoMessage() {}

func (x *GetSigningCommitmentsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[88]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetSigningCommitmentsResponse.ProtoReflect.Descriptor instead.
func (*GetSigningCommitmentsResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{88}
}

func (x *GetSigningCommitmentsResponse) GetSigningCommitments() []*RequestedSigningCommitments {
	if x != nil {
		return x.SigningCommitments
	}
	return nil
}

type SigningCommitments struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A map of signing operator ID (i.e. 000...01) to the signing commitment provided by that
	// operator.
	SigningCommitments map[string]*common.SigningCommitment `protobuf:"bytes,1,rep,name=signing_commitments,json=signingCommitments,proto3" json:"signing_commitments,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *SigningCommitments) Reset() {
	*x = SigningCommitments{}
	mi := &file_spark_proto_msgTypes[89]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SigningCommitments) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SigningCommitments) ProtoMessage() {}

func (x *SigningCommitments) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[89]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SigningCommitments.ProtoReflect.Descriptor instead.
func (*SigningCommitments) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{89}
}

func (x *SigningCommitments) GetSigningCommitments() map[string]*common.SigningCommitment {
	if x != nil {
		return x.SigningCommitments
	}
	return nil
}

type UserSignedRefund struct {
	state                   protoimpl.MessageState    `protogen:"open.v1"`
	NodeId                  string                    `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	RefundTx                []byte                    `protobuf:"bytes,2,opt,name=refund_tx,json=refundTx,proto3" json:"refund_tx,omitempty"`
	UserSignature           []byte                    `protobuf:"bytes,3,opt,name=user_signature,json=userSignature,proto3" json:"user_signature,omitempty"`
	SigningCommitments      *SigningCommitments       `protobuf:"bytes,4,opt,name=signing_commitments,json=signingCommitments,proto3" json:"signing_commitments,omitempty"`
	UserSignatureCommitment *common.SigningCommitment `protobuf:"bytes,5,opt,name=user_signature_commitment,json=userSignatureCommitment,proto3" json:"user_signature_commitment,omitempty"`
	Network                 Network                   `protobuf:"varint,6,opt,name=network,proto3,enum=spark.Network" json:"network,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *UserSignedRefund) Reset() {
	*x = UserSignedRefund{}
	mi := &file_spark_proto_msgTypes[90]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserSignedRefund) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserSignedRefund) ProtoMessage() {}

func (x *UserSignedRefund) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[90]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserSignedRefund.ProtoReflect.Descriptor instead.
func (*UserSignedRefund) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{90}
}

func (x *UserSignedRefund) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *UserSignedRefund) GetRefundTx() []byte {
	if x != nil {
		return x.RefundTx
	}
	return nil
}

func (x *UserSignedRefund) GetUserSignature() []byte {
	if x != nil {
		return x.UserSignature
	}
	return nil
}

func (x *UserSignedRefund) GetSigningCommitments() *SigningCommitments {
	if x != nil {
		return x.SigningCommitments
	}
	return nil
}

func (x *UserSignedRefund) GetUserSignatureCommitment() *common.SigningCommitment {
	if x != nil {
		return x.UserSignatureCommitment
	}
	return nil
}

func (x *UserSignedRefund) GetNetwork() Network {
	if x != nil {
		return x.Network
	}
	return Network_UNSPECIFIED
}

type InvoiceAmountProof struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Bolt11Invoice string                 `protobuf:"bytes,1,opt,name=bolt11_invoice,json=bolt11Invoice,proto3" json:"bolt11_invoice,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InvoiceAmountProof) Reset() {
	*x = InvoiceAmountProof{}
	mi := &file_spark_proto_msgTypes[91]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InvoiceAmountProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InvoiceAmountProof) ProtoMessage() {}

func (x *InvoiceAmountProof) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[91]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InvoiceAmountProof.ProtoReflect.Descriptor instead.
func (*InvoiceAmountProof) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{91}
}

func (x *InvoiceAmountProof) GetBolt11Invoice() string {
	if x != nil {
		return x.Bolt11Invoice
	}
	return ""
}

type InvoiceAmount struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	ValueSats          uint64                 `protobuf:"varint,1,opt,name=value_sats,json=valueSats,proto3" json:"value_sats,omitempty"`
	InvoiceAmountProof *InvoiceAmountProof    `protobuf:"bytes,2,opt,name=invoice_amount_proof,json=invoiceAmountProof,proto3" json:"invoice_amount_proof,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *InvoiceAmount) Reset() {
	*x = InvoiceAmount{}
	mi := &file_spark_proto_msgTypes[92]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InvoiceAmount) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InvoiceAmount) ProtoMessage() {}

func (x *InvoiceAmount) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[92]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InvoiceAmount.ProtoReflect.Descriptor instead.
func (*InvoiceAmount) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{92}
}

func (x *InvoiceAmount) GetValueSats() uint64 {
	if x != nil {
		return x.ValueSats
	}
	return 0
}

func (x *InvoiceAmount) GetInvoiceAmountProof() *InvoiceAmountProof {
	if x != nil {
		return x.InvoiceAmountProof
	}
	return nil
}

type InitiatePreimageSwapRequest struct {
	state                     protoimpl.MessageState             `protogen:"open.v1"`
	PaymentHash               []byte                             `protobuf:"bytes,1,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	InvoiceAmount             *InvoiceAmount                     `protobuf:"bytes,2,opt,name=invoice_amount,json=invoiceAmount,proto3" json:"invoice_amount,omitempty"`
	Reason                    InitiatePreimageSwapRequest_Reason `protobuf:"varint,3,opt,name=reason,proto3,enum=spark.InitiatePreimageSwapRequest_Reason" json:"reason,omitempty"`
	Transfer                  *StartUserSignedTransferRequest    `protobuf:"bytes,4,opt,name=transfer,proto3" json:"transfer,omitempty"`
	ReceiverIdentityPublicKey []byte                             `protobuf:"bytes,5,opt,name=receiver_identity_public_key,json=receiverIdentityPublicKey,proto3" json:"receiver_identity_public_key,omitempty"`
	FeeSats                   uint64                             `protobuf:"varint,6,opt,name=fee_sats,json=feeSats,proto3" json:"fee_sats,omitempty"`
	TransferRequest           *StartTransferRequest              `protobuf:"bytes,7,opt,name=transfer_request,json=transferRequest,proto3" json:"transfer_request,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *InitiatePreimageSwapRequest) Reset() {
	*x = InitiatePreimageSwapRequest{}
	mi := &file_spark_proto_msgTypes[93]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitiatePreimageSwapRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitiatePreimageSwapRequest) ProtoMessage() {}

func (x *InitiatePreimageSwapRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[93]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitiatePreimageSwapRequest.ProtoReflect.Descriptor instead.
func (*InitiatePreimageSwapRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{93}
}

func (x *InitiatePreimageSwapRequest) GetPaymentHash() []byte {
	if x != nil {
		return x.PaymentHash
	}
	return nil
}

func (x *InitiatePreimageSwapRequest) GetInvoiceAmount() *InvoiceAmount {
	if x != nil {
		return x.InvoiceAmount
	}
	return nil
}

func (x *InitiatePreimageSwapRequest) GetReason() InitiatePreimageSwapRequest_Reason {
	if x != nil {
		return x.Reason
	}
	return InitiatePreimageSwapRequest_REASON_SEND
}

func (x *InitiatePreimageSwapRequest) GetTransfer() *StartUserSignedTransferRequest {
	if x != nil {
		return x.Transfer
	}
	return nil
}

func (x *InitiatePreimageSwapRequest) GetReceiverIdentityPublicKey() []byte {
	if x != nil {
		return x.ReceiverIdentityPublicKey
	}
	return nil
}

func (x *InitiatePreimageSwapRequest) GetFeeSats() uint64 {
	if x != nil {
		return x.FeeSats
	}
	return 0
}

func (x *InitiatePreimageSwapRequest) GetTransferRequest() *StartTransferRequest {
	if x != nil {
		return x.TransferRequest
	}
	return nil
}

type InitiatePreimageSwapResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Preimage      []byte                 `protobuf:"bytes,1,opt,name=preimage,proto3" json:"preimage,omitempty"`
	Transfer      *Transfer              `protobuf:"bytes,2,opt,name=transfer,proto3" json:"transfer,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InitiatePreimageSwapResponse) Reset() {
	*x = InitiatePreimageSwapResponse{}
	mi := &file_spark_proto_msgTypes[94]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitiatePreimageSwapResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitiatePreimageSwapResponse) ProtoMessage() {}

func (x *InitiatePreimageSwapResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[94]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitiatePreimageSwapResponse.ProtoReflect.Descriptor instead.
func (*InitiatePreimageSwapResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{94}
}

func (x *InitiatePreimageSwapResponse) GetPreimage() []byte {
	if x != nil {
		return x.Preimage
	}
	return nil
}

func (x *InitiatePreimageSwapResponse) GetTransfer() *Transfer {
	if x != nil {
		return x.Transfer
	}
	return nil
}

type OutPoint struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Txid          []byte                 `protobuf:"bytes,1,opt,name=txid,proto3" json:"txid,omitempty"`
	Vout          uint32                 `protobuf:"varint,2,opt,name=vout,proto3" json:"vout,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OutPoint) Reset() {
	*x = OutPoint{}
	mi := &file_spark_proto_msgTypes[95]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OutPoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OutPoint) ProtoMessage() {}

func (x *OutPoint) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[95]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OutPoint.ProtoReflect.Descriptor instead.
func (*OutPoint) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{95}
}

func (x *OutPoint) GetTxid() []byte {
	if x != nil {
		return x.Txid
	}
	return nil
}

func (x *OutPoint) GetVout() uint32 {
	if x != nil {
		return x.Vout
	}
	return 0
}

type CooperativeExitRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Transfer      *StartTransferRequest  `protobuf:"bytes,1,opt,name=transfer,proto3" json:"transfer,omitempty"`
	ExitId        string                 `protobuf:"bytes,2,opt,name=exit_id,json=exitId,proto3" json:"exit_id,omitempty"`
	ExitTxid      []byte                 `protobuf:"bytes,3,opt,name=exit_txid,json=exitTxid,proto3" json:"exit_txid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CooperativeExitRequest) Reset() {
	*x = CooperativeExitRequest{}
	mi := &file_spark_proto_msgTypes[96]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CooperativeExitRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CooperativeExitRequest) ProtoMessage() {}

func (x *CooperativeExitRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[96]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CooperativeExitRequest.ProtoReflect.Descriptor instead.
func (*CooperativeExitRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{96}
}

func (x *CooperativeExitRequest) GetTransfer() *StartTransferRequest {
	if x != nil {
		return x.Transfer
	}
	return nil
}

func (x *CooperativeExitRequest) GetExitId() string {
	if x != nil {
		return x.ExitId
	}
	return ""
}

func (x *CooperativeExitRequest) GetExitTxid() []byte {
	if x != nil {
		return x.ExitTxid
	}
	return nil
}

type CooperativeExitResponse struct {
	state          protoimpl.MessageState       `protogen:"open.v1"`
	Transfer       *Transfer                    `protobuf:"bytes,1,opt,name=transfer,proto3" json:"transfer,omitempty"`
	SigningResults []*LeafRefundTxSigningResult `protobuf:"bytes,2,rep,name=signing_results,json=signingResults,proto3" json:"signing_results,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *CooperativeExitResponse) Reset() {
	*x = CooperativeExitResponse{}
	mi := &file_spark_proto_msgTypes[97]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CooperativeExitResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CooperativeExitResponse) ProtoMessage() {}

func (x *CooperativeExitResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[97]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CooperativeExitResponse.ProtoReflect.Descriptor instead.
func (*CooperativeExitResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{97}
}

func (x *CooperativeExitResponse) GetTransfer() *Transfer {
	if x != nil {
		return x.Transfer
	}
	return nil
}

func (x *CooperativeExitResponse) GetSigningResults() []*LeafRefundTxSigningResult {
	if x != nil {
		return x.SigningResults
	}
	return nil
}

type CounterLeafSwapRequest struct {
	state                          protoimpl.MessageState `protogen:"open.v1"`
	Transfer                       *StartTransferRequest  `protobuf:"bytes,1,opt,name=transfer,proto3" json:"transfer,omitempty"`
	SwapId                         string                 `protobuf:"bytes,2,opt,name=swap_id,json=swapId,proto3" json:"swap_id,omitempty"`
	AdaptorPublicKey               []byte                 `protobuf:"bytes,3,opt,name=adaptor_public_key,json=adaptorPublicKey,proto3" json:"adaptor_public_key,omitempty"`
	DirectAdaptorPublicKey         []byte                 `protobuf:"bytes,4,opt,name=direct_adaptor_public_key,json=directAdaptorPublicKey,proto3" json:"direct_adaptor_public_key,omitempty"`
	DirectFromCpfpAdaptorPublicKey []byte                 `protobuf:"bytes,5,opt,name=direct_from_cpfp_adaptor_public_key,json=directFromCpfpAdaptorPublicKey,proto3" json:"direct_from_cpfp_adaptor_public_key,omitempty"`
	unknownFields                  protoimpl.UnknownFields
	sizeCache                      protoimpl.SizeCache
}

func (x *CounterLeafSwapRequest) Reset() {
	*x = CounterLeafSwapRequest{}
	mi := &file_spark_proto_msgTypes[98]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CounterLeafSwapRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CounterLeafSwapRequest) ProtoMessage() {}

func (x *CounterLeafSwapRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[98]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CounterLeafSwapRequest.ProtoReflect.Descriptor instead.
func (*CounterLeafSwapRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{98}
}

func (x *CounterLeafSwapRequest) GetTransfer() *StartTransferRequest {
	if x != nil {
		return x.Transfer
	}
	return nil
}

func (x *CounterLeafSwapRequest) GetSwapId() string {
	if x != nil {
		return x.SwapId
	}
	return ""
}

func (x *CounterLeafSwapRequest) GetAdaptorPublicKey() []byte {
	if x != nil {
		return x.AdaptorPublicKey
	}
	return nil
}

func (x *CounterLeafSwapRequest) GetDirectAdaptorPublicKey() []byte {
	if x != nil {
		return x.DirectAdaptorPublicKey
	}
	return nil
}

func (x *CounterLeafSwapRequest) GetDirectFromCpfpAdaptorPublicKey() []byte {
	if x != nil {
		return x.DirectFromCpfpAdaptorPublicKey
	}
	return nil
}

type CounterLeafSwapResponse struct {
	state          protoimpl.MessageState       `protogen:"open.v1"`
	Transfer       *Transfer                    `protobuf:"bytes,1,opt,name=transfer,proto3" json:"transfer,omitempty"`
	SigningResults []*LeafRefundTxSigningResult `protobuf:"bytes,2,rep,name=signing_results,json=signingResults,proto3" json:"signing_results,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *CounterLeafSwapResponse) Reset() {
	*x = CounterLeafSwapResponse{}
	mi := &file_spark_proto_msgTypes[99]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CounterLeafSwapResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CounterLeafSwapResponse) ProtoMessage() {}

func (x *CounterLeafSwapResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[99]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CounterLeafSwapResponse.ProtoReflect.Descriptor instead.
func (*CounterLeafSwapResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{99}
}

func (x *CounterLeafSwapResponse) GetTransfer() *Transfer {
	if x != nil {
		return x.Transfer
	}
	return nil
}

func (x *CounterLeafSwapResponse) GetSigningResults() []*LeafRefundTxSigningResult {
	if x != nil {
		return x.SigningResults
	}
	return nil
}

type RefreshTimelockRequest struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	LeafId                 string                 `protobuf:"bytes,1,opt,name=leaf_id,json=leafId,proto3" json:"leaf_id,omitempty"`
	OwnerIdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	SigningJobs            []*SigningJob          `protobuf:"bytes,3,rep,name=signing_jobs,json=signingJobs,proto3" json:"signing_jobs,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *RefreshTimelockRequest) Reset() {
	*x = RefreshTimelockRequest{}
	mi := &file_spark_proto_msgTypes[100]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RefreshTimelockRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RefreshTimelockRequest) ProtoMessage() {}

func (x *RefreshTimelockRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[100]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RefreshTimelockRequest.ProtoReflect.Descriptor instead.
func (*RefreshTimelockRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{100}
}

func (x *RefreshTimelockRequest) GetLeafId() string {
	if x != nil {
		return x.LeafId
	}
	return ""
}

func (x *RefreshTimelockRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

func (x *RefreshTimelockRequest) GetSigningJobs() []*SigningJob {
	if x != nil {
		return x.SigningJobs
	}
	return nil
}

type RefreshTimelockSigningResult struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SigningResult *SigningResult         `protobuf:"bytes,1,opt,name=signing_result,json=signingResult,proto3" json:"signing_result,omitempty"`
	VerifyingKey  []byte                 `protobuf:"bytes,2,opt,name=verifying_key,json=verifyingKey,proto3" json:"verifying_key,omitempty"` // Should maybe just be a part of SigningResult?
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RefreshTimelockSigningResult) Reset() {
	*x = RefreshTimelockSigningResult{}
	mi := &file_spark_proto_msgTypes[101]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RefreshTimelockSigningResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RefreshTimelockSigningResult) ProtoMessage() {}

func (x *RefreshTimelockSigningResult) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[101]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RefreshTimelockSigningResult.ProtoReflect.Descriptor instead.
func (*RefreshTimelockSigningResult) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{101}
}

func (x *RefreshTimelockSigningResult) GetSigningResult() *SigningResult {
	if x != nil {
		return x.SigningResult
	}
	return nil
}

func (x *RefreshTimelockSigningResult) GetVerifyingKey() []byte {
	if x != nil {
		return x.VerifyingKey
	}
	return nil
}

type RefreshTimelockResponse struct {
	state          protoimpl.MessageState          `protogen:"open.v1"`
	SigningResults []*RefreshTimelockSigningResult `protobuf:"bytes,1,rep,name=signing_results,json=signingResults,proto3" json:"signing_results,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *RefreshTimelockResponse) Reset() {
	*x = RefreshTimelockResponse{}
	mi := &file_spark_proto_msgTypes[102]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RefreshTimelockResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RefreshTimelockResponse) ProtoMessage() {}

func (x *RefreshTimelockResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[102]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RefreshTimelockResponse.ProtoReflect.Descriptor instead.
func (*RefreshTimelockResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{102}
}

func (x *RefreshTimelockResponse) GetSigningResults() []*RefreshTimelockSigningResult {
	if x != nil {
		return x.SigningResults
	}
	return nil
}

type ExtendLeafRequest struct {
	state                            protoimpl.MessageState `protogen:"open.v1"`
	LeafId                           string                 `protobuf:"bytes,1,opt,name=leaf_id,json=leafId,proto3" json:"leaf_id,omitempty"`
	OwnerIdentityPublicKey           []byte                 `protobuf:"bytes,2,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	NodeTxSigningJob                 *SigningJob            `protobuf:"bytes,3,opt,name=node_tx_signing_job,json=nodeTxSigningJob,proto3" json:"node_tx_signing_job,omitempty"`
	RefundTxSigningJob               *SigningJob            `protobuf:"bytes,4,opt,name=refund_tx_signing_job,json=refundTxSigningJob,proto3" json:"refund_tx_signing_job,omitempty"`
	DirectNodeTxSigningJob           *SigningJob            `protobuf:"bytes,5,opt,name=direct_node_tx_signing_job,json=directNodeTxSigningJob,proto3" json:"direct_node_tx_signing_job,omitempty"`
	DirectRefundTxSigningJob         *SigningJob            `protobuf:"bytes,6,opt,name=direct_refund_tx_signing_job,json=directRefundTxSigningJob,proto3" json:"direct_refund_tx_signing_job,omitempty"`
	DirectFromCpfpRefundTxSigningJob *SigningJob            `protobuf:"bytes,7,opt,name=direct_from_cpfp_refund_tx_signing_job,json=directFromCpfpRefundTxSigningJob,proto3" json:"direct_from_cpfp_refund_tx_signing_job,omitempty"`
	unknownFields                    protoimpl.UnknownFields
	sizeCache                        protoimpl.SizeCache
}

func (x *ExtendLeafRequest) Reset() {
	*x = ExtendLeafRequest{}
	mi := &file_spark_proto_msgTypes[103]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExtendLeafRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExtendLeafRequest) ProtoMessage() {}

func (x *ExtendLeafRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[103]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExtendLeafRequest.ProtoReflect.Descriptor instead.
func (*ExtendLeafRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{103}
}

func (x *ExtendLeafRequest) GetLeafId() string {
	if x != nil {
		return x.LeafId
	}
	return ""
}

func (x *ExtendLeafRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

func (x *ExtendLeafRequest) GetNodeTxSigningJob() *SigningJob {
	if x != nil {
		return x.NodeTxSigningJob
	}
	return nil
}

func (x *ExtendLeafRequest) GetRefundTxSigningJob() *SigningJob {
	if x != nil {
		return x.RefundTxSigningJob
	}
	return nil
}

func (x *ExtendLeafRequest) GetDirectNodeTxSigningJob() *SigningJob {
	if x != nil {
		return x.DirectNodeTxSigningJob
	}
	return nil
}

func (x *ExtendLeafRequest) GetDirectRefundTxSigningJob() *SigningJob {
	if x != nil {
		return x.DirectRefundTxSigningJob
	}
	return nil
}

func (x *ExtendLeafRequest) GetDirectFromCpfpRefundTxSigningJob() *SigningJob {
	if x != nil {
		return x.DirectFromCpfpRefundTxSigningJob
	}
	return nil
}

type ExtendLeafSigningResult struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SigningResult *SigningResult         `protobuf:"bytes,1,opt,name=signing_result,json=signingResult,proto3" json:"signing_result,omitempty"`
	VerifyingKey  []byte                 `protobuf:"bytes,2,opt,name=verifying_key,json=verifyingKey,proto3" json:"verifying_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExtendLeafSigningResult) Reset() {
	*x = ExtendLeafSigningResult{}
	mi := &file_spark_proto_msgTypes[104]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExtendLeafSigningResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExtendLeafSigningResult) ProtoMessage() {}

func (x *ExtendLeafSigningResult) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[104]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExtendLeafSigningResult.ProtoReflect.Descriptor instead.
func (*ExtendLeafSigningResult) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{104}
}

func (x *ExtendLeafSigningResult) GetSigningResult() *SigningResult {
	if x != nil {
		return x.SigningResult
	}
	return nil
}

func (x *ExtendLeafSigningResult) GetVerifyingKey() []byte {
	if x != nil {
		return x.VerifyingKey
	}
	return nil
}

type ExtendLeafResponse struct {
	state                               protoimpl.MessageState   `protogen:"open.v1"`
	LeafId                              string                   `protobuf:"bytes,1,opt,name=leaf_id,json=leafId,proto3" json:"leaf_id,omitempty"`
	NodeTxSigningResult                 *ExtendLeafSigningResult `protobuf:"bytes,2,opt,name=node_tx_signing_result,json=nodeTxSigningResult,proto3" json:"node_tx_signing_result,omitempty"`
	RefundTxSigningResult               *ExtendLeafSigningResult `protobuf:"bytes,3,opt,name=refund_tx_signing_result,json=refundTxSigningResult,proto3" json:"refund_tx_signing_result,omitempty"`
	DirectNodeTxSigningResult           *ExtendLeafSigningResult `protobuf:"bytes,4,opt,name=direct_node_tx_signing_result,json=directNodeTxSigningResult,proto3" json:"direct_node_tx_signing_result,omitempty"`
	DirectRefundTxSigningResult         *ExtendLeafSigningResult `protobuf:"bytes,5,opt,name=direct_refund_tx_signing_result,json=directRefundTxSigningResult,proto3" json:"direct_refund_tx_signing_result,omitempty"`
	DirectFromCpfpRefundTxSigningResult *ExtendLeafSigningResult `protobuf:"bytes,6,opt,name=direct_from_cpfp_refund_tx_signing_result,json=directFromCpfpRefundTxSigningResult,proto3" json:"direct_from_cpfp_refund_tx_signing_result,omitempty"`
	unknownFields                       protoimpl.UnknownFields
	sizeCache                           protoimpl.SizeCache
}

func (x *ExtendLeafResponse) Reset() {
	*x = ExtendLeafResponse{}
	mi := &file_spark_proto_msgTypes[105]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExtendLeafResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExtendLeafResponse) ProtoMessage() {}

func (x *ExtendLeafResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[105]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExtendLeafResponse.ProtoReflect.Descriptor instead.
func (*ExtendLeafResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{105}
}

func (x *ExtendLeafResponse) GetLeafId() string {
	if x != nil {
		return x.LeafId
	}
	return ""
}

func (x *ExtendLeafResponse) GetNodeTxSigningResult() *ExtendLeafSigningResult {
	if x != nil {
		return x.NodeTxSigningResult
	}
	return nil
}

func (x *ExtendLeafResponse) GetRefundTxSigningResult() *ExtendLeafSigningResult {
	if x != nil {
		return x.RefundTxSigningResult
	}
	return nil
}

func (x *ExtendLeafResponse) GetDirectNodeTxSigningResult() *ExtendLeafSigningResult {
	if x != nil {
		return x.DirectNodeTxSigningResult
	}
	return nil
}

func (x *ExtendLeafResponse) GetDirectRefundTxSigningResult() *ExtendLeafSigningResult {
	if x != nil {
		return x.DirectRefundTxSigningResult
	}
	return nil
}

func (x *ExtendLeafResponse) GetDirectFromCpfpRefundTxSigningResult() *ExtendLeafSigningResult {
	if x != nil {
		return x.DirectFromCpfpRefundTxSigningResult
	}
	return nil
}

type AddressRequestNode struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	UserPublicKey []byte                 `protobuf:"bytes,1,opt,name=user_public_key,json=userPublicKey,proto3" json:"user_public_key,omitempty"`
	Children      []*AddressRequestNode  `protobuf:"bytes,2,rep,name=children,proto3" json:"children,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddressRequestNode) Reset() {
	*x = AddressRequestNode{}
	mi := &file_spark_proto_msgTypes[106]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddressRequestNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddressRequestNode) ProtoMessage() {}

func (x *AddressRequestNode) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[106]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddressRequestNode.ProtoReflect.Descriptor instead.
func (*AddressRequestNode) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{106}
}

func (x *AddressRequestNode) GetUserPublicKey() []byte {
	if x != nil {
		return x.UserPublicKey
	}
	return nil
}

func (x *AddressRequestNode) GetChildren() []*AddressRequestNode {
	if x != nil {
		return x.Children
	}
	return nil
}

type PrepareTreeAddressRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Source:
	//
	//	*PrepareTreeAddressRequest_ParentNodeOutput
	//	*PrepareTreeAddressRequest_OnChainUtxo
	Source isPrepareTreeAddressRequest_Source `protobuf_oneof:"source"`
	// The tx on this node is to spend the source's utxo.
	// The user's public key should already be registered with the SE for the root node.
	Node                  *AddressRequestNode `protobuf:"bytes,3,opt,name=node,proto3" json:"node,omitempty"`
	UserIdentityPublicKey []byte              `protobuf:"bytes,4,opt,name=user_identity_public_key,json=userIdentityPublicKey,proto3" json:"user_identity_public_key,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *PrepareTreeAddressRequest) Reset() {
	*x = PrepareTreeAddressRequest{}
	mi := &file_spark_proto_msgTypes[107]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrepareTreeAddressRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrepareTreeAddressRequest) ProtoMessage() {}

func (x *PrepareTreeAddressRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[107]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrepareTreeAddressRequest.ProtoReflect.Descriptor instead.
func (*PrepareTreeAddressRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{107}
}

func (x *PrepareTreeAddressRequest) GetSource() isPrepareTreeAddressRequest_Source {
	if x != nil {
		return x.Source
	}
	return nil
}

func (x *PrepareTreeAddressRequest) GetParentNodeOutput() *NodeOutput {
	if x != nil {
		if x, ok := x.Source.(*PrepareTreeAddressRequest_ParentNodeOutput); ok {
			return x.ParentNodeOutput
		}
	}
	return nil
}

func (x *PrepareTreeAddressRequest) GetOnChainUtxo() *UTXO {
	if x != nil {
		if x, ok := x.Source.(*PrepareTreeAddressRequest_OnChainUtxo); ok {
			return x.OnChainUtxo
		}
	}
	return nil
}

func (x *PrepareTreeAddressRequest) GetNode() *AddressRequestNode {
	if x != nil {
		return x.Node
	}
	return nil
}

func (x *PrepareTreeAddressRequest) GetUserIdentityPublicKey() []byte {
	if x != nil {
		return x.UserIdentityPublicKey
	}
	return nil
}

type isPrepareTreeAddressRequest_Source interface {
	isPrepareTreeAddressRequest_Source()
}

type PrepareTreeAddressRequest_ParentNodeOutput struct {
	ParentNodeOutput *NodeOutput `protobuf:"bytes,1,opt,name=parent_node_output,json=parentNodeOutput,proto3,oneof"`
}

type PrepareTreeAddressRequest_OnChainUtxo struct {
	OnChainUtxo *UTXO `protobuf:"bytes,2,opt,name=on_chain_utxo,json=onChainUtxo,proto3,oneof"`
}

func (*PrepareTreeAddressRequest_ParentNodeOutput) isPrepareTreeAddressRequest_Source() {}

func (*PrepareTreeAddressRequest_OnChainUtxo) isPrepareTreeAddressRequest_Source() {}

type AddressNode struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Address       *Address               `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Children      []*AddressNode         `protobuf:"bytes,2,rep,name=children,proto3" json:"children,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddressNode) Reset() {
	*x = AddressNode{}
	mi := &file_spark_proto_msgTypes[108]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddressNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddressNode) ProtoMessage() {}

func (x *AddressNode) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[108]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddressNode.ProtoReflect.Descriptor instead.
func (*AddressNode) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{108}
}

func (x *AddressNode) GetAddress() *Address {
	if x != nil {
		return x.Address
	}
	return nil
}

func (x *AddressNode) GetChildren() []*AddressNode {
	if x != nil {
		return x.Children
	}
	return nil
}

type PrepareTreeAddressResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Node          *AddressNode           `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PrepareTreeAddressResponse) Reset() {
	*x = PrepareTreeAddressResponse{}
	mi := &file_spark_proto_msgTypes[109]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrepareTreeAddressResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrepareTreeAddressResponse) ProtoMessage() {}

func (x *PrepareTreeAddressResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[109]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrepareTreeAddressResponse.ProtoReflect.Descriptor instead.
func (*PrepareTreeAddressResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{109}
}

func (x *PrepareTreeAddressResponse) GetNode() *AddressNode {
	if x != nil {
		return x.Node
	}
	return nil
}

type CreationNode struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This is the cpfp tx that spends the parent node's output.
	NodeTxSigningJob *SigningJob `protobuf:"bytes,1,opt,name=node_tx_signing_job,json=nodeTxSigningJob,proto3" json:"node_tx_signing_job,omitempty"`
	// The refund tx can only exist if there's no children.
	RefundTxSigningJob *SigningJob `protobuf:"bytes,2,opt,name=refund_tx_signing_job,json=refundTxSigningJob,proto3" json:"refund_tx_signing_job,omitempty"`
	// The children will spend the output of the node's tx. Vout is the index of the child.
	Children []*CreationNode `protobuf:"bytes,3,rep,name=children,proto3" json:"children,omitempty"`
	// This is the direct tx that spends the parent node's output.
	DirectNodeTxSigningJob *SigningJob `protobuf:"bytes,4,opt,name=direct_node_tx_signing_job,json=directNodeTxSigningJob,proto3" json:"direct_node_tx_signing_job,omitempty"`
	// The direct refund tx can only exist if there's no children.
	DirectRefundTxSigningJob *SigningJob `protobuf:"bytes,5,opt,name=direct_refund_tx_signing_job,json=directRefundTxSigningJob,proto3" json:"direct_refund_tx_signing_job,omitempty"`
	// The direct from cpfp refund tx can only exist if there's no children.
	DirectFromCpfpRefundTxSigningJob *SigningJob `protobuf:"bytes,6,opt,name=direct_from_cpfp_refund_tx_signing_job,json=directFromCpfpRefundTxSigningJob,proto3" json:"direct_from_cpfp_refund_tx_signing_job,omitempty"`
	unknownFields                    protoimpl.UnknownFields
	sizeCache                        protoimpl.SizeCache
}

func (x *CreationNode) Reset() {
	*x = CreationNode{}
	mi := &file_spark_proto_msgTypes[110]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreationNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreationNode) ProtoMessage() {}

func (x *CreationNode) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[110]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreationNode.ProtoReflect.Descriptor instead.
func (*CreationNode) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{110}
}

func (x *CreationNode) GetNodeTxSigningJob() *SigningJob {
	if x != nil {
		return x.NodeTxSigningJob
	}
	return nil
}

func (x *CreationNode) GetRefundTxSigningJob() *SigningJob {
	if x != nil {
		return x.RefundTxSigningJob
	}
	return nil
}

func (x *CreationNode) GetChildren() []*CreationNode {
	if x != nil {
		return x.Children
	}
	return nil
}

func (x *CreationNode) GetDirectNodeTxSigningJob() *SigningJob {
	if x != nil {
		return x.DirectNodeTxSigningJob
	}
	return nil
}

func (x *CreationNode) GetDirectRefundTxSigningJob() *SigningJob {
	if x != nil {
		return x.DirectRefundTxSigningJob
	}
	return nil
}

func (x *CreationNode) GetDirectFromCpfpRefundTxSigningJob() *SigningJob {
	if x != nil {
		return x.DirectFromCpfpRefundTxSigningJob
	}
	return nil
}

type CreateTreeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Source:
	//
	//	*CreateTreeRequest_ParentNodeOutput
	//	*CreateTreeRequest_OnChainUtxo
	Source isCreateTreeRequest_Source `protobuf_oneof:"source"`
	// The node should contain the tx that spends the source's utxo.
	Node *CreationNode `protobuf:"bytes,3,opt,name=node,proto3" json:"node,omitempty"`
	// The owner of the tree.
	UserIdentityPublicKey []byte `protobuf:"bytes,4,opt,name=user_identity_public_key,json=userIdentityPublicKey,proto3" json:"user_identity_public_key,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *CreateTreeRequest) Reset() {
	*x = CreateTreeRequest{}
	mi := &file_spark_proto_msgTypes[111]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateTreeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateTreeRequest) ProtoMessage() {}

func (x *CreateTreeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[111]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateTreeRequest.ProtoReflect.Descriptor instead.
func (*CreateTreeRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{111}
}

func (x *CreateTreeRequest) GetSource() isCreateTreeRequest_Source {
	if x != nil {
		return x.Source
	}
	return nil
}

func (x *CreateTreeRequest) GetParentNodeOutput() *NodeOutput {
	if x != nil {
		if x, ok := x.Source.(*CreateTreeRequest_ParentNodeOutput); ok {
			return x.ParentNodeOutput
		}
	}
	return nil
}

func (x *CreateTreeRequest) GetOnChainUtxo() *UTXO {
	if x != nil {
		if x, ok := x.Source.(*CreateTreeRequest_OnChainUtxo); ok {
			return x.OnChainUtxo
		}
	}
	return nil
}

func (x *CreateTreeRequest) GetNode() *CreationNode {
	if x != nil {
		return x.Node
	}
	return nil
}

func (x *CreateTreeRequest) GetUserIdentityPublicKey() []byte {
	if x != nil {
		return x.UserIdentityPublicKey
	}
	return nil
}

type isCreateTreeRequest_Source interface {
	isCreateTreeRequest_Source()
}

type CreateTreeRequest_ParentNodeOutput struct {
	ParentNodeOutput *NodeOutput `protobuf:"bytes,1,opt,name=parent_node_output,json=parentNodeOutput,proto3,oneof"`
}

type CreateTreeRequest_OnChainUtxo struct {
	OnChainUtxo *UTXO `protobuf:"bytes,2,opt,name=on_chain_utxo,json=onChainUtxo,proto3,oneof"`
}

func (*CreateTreeRequest_ParentNodeOutput) isCreateTreeRequest_Source() {}

func (*CreateTreeRequest_OnChainUtxo) isCreateTreeRequest_Source() {}

type CreationResponseNode struct {
	state                               protoimpl.MessageState  `protogen:"open.v1"`
	NodeId                              string                  `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	NodeTxSigningResult                 *SigningResult          `protobuf:"bytes,2,opt,name=node_tx_signing_result,json=nodeTxSigningResult,proto3" json:"node_tx_signing_result,omitempty"`
	RefundTxSigningResult               *SigningResult          `protobuf:"bytes,3,opt,name=refund_tx_signing_result,json=refundTxSigningResult,proto3" json:"refund_tx_signing_result,omitempty"`
	Children                            []*CreationResponseNode `protobuf:"bytes,4,rep,name=children,proto3" json:"children,omitempty"`
	DirectNodeTxSigningResult           *SigningResult          `protobuf:"bytes,5,opt,name=direct_node_tx_signing_result,json=directNodeTxSigningResult,proto3" json:"direct_node_tx_signing_result,omitempty"`
	DirectRefundTxSigningResult         *SigningResult          `protobuf:"bytes,6,opt,name=direct_refund_tx_signing_result,json=directRefundTxSigningResult,proto3" json:"direct_refund_tx_signing_result,omitempty"`
	DirectFromCpfpRefundTxSigningResult *SigningResult          `protobuf:"bytes,7,opt,name=direct_from_cpfp_refund_tx_signing_result,json=directFromCpfpRefundTxSigningResult,proto3" json:"direct_from_cpfp_refund_tx_signing_result,omitempty"`
	unknownFields                       protoimpl.UnknownFields
	sizeCache                           protoimpl.SizeCache
}

func (x *CreationResponseNode) Reset() {
	*x = CreationResponseNode{}
	mi := &file_spark_proto_msgTypes[112]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreationResponseNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreationResponseNode) ProtoMessage() {}

func (x *CreationResponseNode) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[112]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreationResponseNode.ProtoReflect.Descriptor instead.
func (*CreationResponseNode) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{112}
}

func (x *CreationResponseNode) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *CreationResponseNode) GetNodeTxSigningResult() *SigningResult {
	if x != nil {
		return x.NodeTxSigningResult
	}
	return nil
}

func (x *CreationResponseNode) GetRefundTxSigningResult() *SigningResult {
	if x != nil {
		return x.RefundTxSigningResult
	}
	return nil
}

func (x *CreationResponseNode) GetChildren() []*CreationResponseNode {
	if x != nil {
		return x.Children
	}
	return nil
}

func (x *CreationResponseNode) GetDirectNodeTxSigningResult() *SigningResult {
	if x != nil {
		return x.DirectNodeTxSigningResult
	}
	return nil
}

func (x *CreationResponseNode) GetDirectRefundTxSigningResult() *SigningResult {
	if x != nil {
		return x.DirectRefundTxSigningResult
	}
	return nil
}

func (x *CreationResponseNode) GetDirectFromCpfpRefundTxSigningResult() *SigningResult {
	if x != nil {
		return x.DirectFromCpfpRefundTxSigningResult
	}
	return nil
}

type CreateTreeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Node          *CreationResponseNode  `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateTreeResponse) Reset() {
	*x = CreateTreeResponse{}
	mi := &file_spark_proto_msgTypes[113]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateTreeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateTreeResponse) ProtoMessage() {}

func (x *CreateTreeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[113]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateTreeResponse.ProtoReflect.Descriptor instead.
func (*CreateTreeResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{113}
}

func (x *CreateTreeResponse) GetNode() *CreationResponseNode {
	if x != nil {
		return x.Node
	}
	return nil
}

type SigningOperatorInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Index         uint64                 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Identifier    string                 `protobuf:"bytes,2,opt,name=identifier,proto3" json:"identifier,omitempty"`
	PublicKey     []byte                 `protobuf:"bytes,3,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	Address       string                 `protobuf:"bytes,4,opt,name=address,proto3" json:"address,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SigningOperatorInfo) Reset() {
	*x = SigningOperatorInfo{}
	mi := &file_spark_proto_msgTypes[114]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SigningOperatorInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SigningOperatorInfo) ProtoMessage() {}

func (x *SigningOperatorInfo) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[114]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SigningOperatorInfo.ProtoReflect.Descriptor instead.
func (*SigningOperatorInfo) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{114}
}

func (x *SigningOperatorInfo) GetIndex() uint64 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *SigningOperatorInfo) GetIdentifier() string {
	if x != nil {
		return x.Identifier
	}
	return ""
}

func (x *SigningOperatorInfo) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *SigningOperatorInfo) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

type GetSigningOperatorListResponse struct {
	state            protoimpl.MessageState          `protogen:"open.v1"`
	SigningOperators map[string]*SigningOperatorInfo `protobuf:"bytes,1,rep,name=signing_operators,json=signingOperators,proto3" json:"signing_operators,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *GetSigningOperatorListResponse) Reset() {
	*x = GetSigningOperatorListResponse{}
	mi := &file_spark_proto_msgTypes[115]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetSigningOperatorListResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetSigningOperatorListResponse) ProtoMessage() {}

func (x *GetSigningOperatorListResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[115]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetSigningOperatorListResponse.ProtoReflect.Descriptor instead.
func (*GetSigningOperatorListResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{115}
}

func (x *GetSigningOperatorListResponse) GetSigningOperators() map[string]*SigningOperatorInfo {
	if x != nil {
		return x.SigningOperators
	}
	return nil
}

type QueryUserSignedRefundsRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	PaymentHash       []byte                 `protobuf:"bytes,1,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	IdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *QueryUserSignedRefundsRequest) Reset() {
	*x = QueryUserSignedRefundsRequest{}
	mi := &file_spark_proto_msgTypes[116]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryUserSignedRefundsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryUserSignedRefundsRequest) ProtoMessage() {}

func (x *QueryUserSignedRefundsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[116]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryUserSignedRefundsRequest.ProtoReflect.Descriptor instead.
func (*QueryUserSignedRefundsRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{116}
}

func (x *QueryUserSignedRefundsRequest) GetPaymentHash() []byte {
	if x != nil {
		return x.PaymentHash
	}
	return nil
}

func (x *QueryUserSignedRefundsRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

type QueryUserSignedRefundsResponse struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	UserSignedRefunds []*UserSignedRefund    `protobuf:"bytes,1,rep,name=user_signed_refunds,json=userSignedRefunds,proto3" json:"user_signed_refunds,omitempty"`
	Transfer          *Transfer              `protobuf:"bytes,3,opt,name=transfer,proto3" json:"transfer,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *QueryUserSignedRefundsResponse) Reset() {
	*x = QueryUserSignedRefundsResponse{}
	mi := &file_spark_proto_msgTypes[117]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryUserSignedRefundsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryUserSignedRefundsResponse) ProtoMessage() {}

func (x *QueryUserSignedRefundsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[117]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryUserSignedRefundsResponse.ProtoReflect.Descriptor instead.
func (*QueryUserSignedRefundsResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{117}
}

func (x *QueryUserSignedRefundsResponse) GetUserSignedRefunds() []*UserSignedRefund {
	if x != nil {
		return x.UserSignedRefunds
	}
	return nil
}

func (x *QueryUserSignedRefundsResponse) GetTransfer() *Transfer {
	if x != nil {
		return x.Transfer
	}
	return nil
}

type PreimageRequestWithTransfer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Preimage request data
	PaymentHash            []byte                 `protobuf:"bytes,1,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	ReceiverIdentityPubkey []byte                 `protobuf:"bytes,2,opt,name=receiver_identity_pubkey,json=receiverIdentityPubkey,proto3" json:"receiver_identity_pubkey,omitempty"`
	Status                 PreimageRequestStatus  `protobuf:"varint,3,opt,name=status,proto3,enum=spark.PreimageRequestStatus" json:"status,omitempty"`
	CreatedTime            *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=created_time,json=createdTime,proto3" json:"created_time,omitempty"`
	// Associated transfer (if exists)
	Transfer *Transfer `protobuf:"bytes,5,opt,name=transfer,proto3,oneof" json:"transfer,omitempty"`
	// Preimage data (if available)
	Preimage      []byte `protobuf:"bytes,6,opt,name=preimage,proto3,oneof" json:"preimage,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PreimageRequestWithTransfer) Reset() {
	*x = PreimageRequestWithTransfer{}
	mi := &file_spark_proto_msgTypes[118]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PreimageRequestWithTransfer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PreimageRequestWithTransfer) ProtoMessage() {}

func (x *PreimageRequestWithTransfer) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[118]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PreimageRequestWithTransfer.ProtoReflect.Descriptor instead.
func (*PreimageRequestWithTransfer) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{118}
}

func (x *PreimageRequestWithTransfer) GetPaymentHash() []byte {
	if x != nil {
		return x.PaymentHash
	}
	return nil
}

func (x *PreimageRequestWithTransfer) GetReceiverIdentityPubkey() []byte {
	if x != nil {
		return x.ReceiverIdentityPubkey
	}
	return nil
}

func (x *PreimageRequestWithTransfer) GetStatus() PreimageRequestStatus {
	if x != nil {
		return x.Status
	}
	return PreimageRequestStatus_PREIMAGE_REQUEST_STATUS_WAITING_FOR_PREIMAGE
}

func (x *PreimageRequestWithTransfer) GetCreatedTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedTime
	}
	return nil
}

func (x *PreimageRequestWithTransfer) GetTransfer() *Transfer {
	if x != nil {
		return x.Transfer
	}
	return nil
}

func (x *PreimageRequestWithTransfer) GetPreimage() []byte {
	if x != nil {
		return x.Preimage
	}
	return nil
}

type QueryHtlcRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	PaymentHashes     [][]byte               `protobuf:"bytes,1,rep,name=payment_hashes,json=paymentHashes,proto3" json:"payment_hashes,omitempty"`
	IdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	Status            *PreimageRequestStatus `protobuf:"varint,3,opt,name=status,proto3,enum=spark.PreimageRequestStatus,oneof" json:"status,omitempty"`
	Limit             int64                  `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`   // defaults to 100 if not set.
	Offset            int64                  `protobuf:"varint,5,opt,name=offset,proto3" json:"offset,omitempty"` // defaults to 0 if not set.
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *QueryHtlcRequest) Reset() {
	*x = QueryHtlcRequest{}
	mi := &file_spark_proto_msgTypes[119]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryHtlcRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryHtlcRequest) ProtoMessage() {}

func (x *QueryHtlcRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[119]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryHtlcRequest.ProtoReflect.Descriptor instead.
func (*QueryHtlcRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{119}
}

func (x *QueryHtlcRequest) GetPaymentHashes() [][]byte {
	if x != nil {
		return x.PaymentHashes
	}
	return nil
}

func (x *QueryHtlcRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

func (x *QueryHtlcRequest) GetStatus() PreimageRequestStatus {
	if x != nil && x.Status != nil {
		return *x.Status
	}
	return PreimageRequestStatus_PREIMAGE_REQUEST_STATUS_WAITING_FOR_PREIMAGE
}

func (x *QueryHtlcRequest) GetLimit() int64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *QueryHtlcRequest) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type QueryHtlcResponse struct {
	state            protoimpl.MessageState         `protogen:"open.v1"`
	PreimageRequests []*PreimageRequestWithTransfer `protobuf:"bytes,1,rep,name=preimage_requests,json=preimageRequests,proto3" json:"preimage_requests,omitempty"`
	Offset           int64                          `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"` // defaults to -1 if there are no more results
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *QueryHtlcResponse) Reset() {
	*x = QueryHtlcResponse{}
	mi := &file_spark_proto_msgTypes[120]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryHtlcResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryHtlcResponse) ProtoMessage() {}

func (x *QueryHtlcResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[120]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryHtlcResponse.ProtoReflect.Descriptor instead.
func (*QueryHtlcResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{120}
}

func (x *QueryHtlcResponse) GetPreimageRequests() []*PreimageRequestWithTransfer {
	if x != nil {
		return x.PreimageRequests
	}
	return nil
}

func (x *QueryHtlcResponse) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type ProvidePreimageRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	PaymentHash       []byte                 `protobuf:"bytes,1,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	Preimage          []byte                 `protobuf:"bytes,2,opt,name=preimage,proto3" json:"preimage,omitempty"`
	IdentityPublicKey []byte                 `protobuf:"bytes,3,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ProvidePreimageRequest) Reset() {
	*x = ProvidePreimageRequest{}
	mi := &file_spark_proto_msgTypes[121]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProvidePreimageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProvidePreimageRequest) ProtoMessage() {}

func (x *ProvidePreimageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[121]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProvidePreimageRequest.ProtoReflect.Descriptor instead.
func (*ProvidePreimageRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{121}
}

func (x *ProvidePreimageRequest) GetPaymentHash() []byte {
	if x != nil {
		return x.PaymentHash
	}
	return nil
}

func (x *ProvidePreimageRequest) GetPreimage() []byte {
	if x != nil {
		return x.Preimage
	}
	return nil
}

func (x *ProvidePreimageRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

type ProvidePreimageResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Transfer      *Transfer              `protobuf:"bytes,1,opt,name=transfer,proto3" json:"transfer,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProvidePreimageResponse) Reset() {
	*x = ProvidePreimageResponse{}
	mi := &file_spark_proto_msgTypes[122]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProvidePreimageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProvidePreimageResponse) ProtoMessage() {}

func (x *ProvidePreimageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[122]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProvidePreimageResponse.ProtoReflect.Descriptor instead.
func (*ProvidePreimageResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{122}
}

func (x *ProvidePreimageResponse) GetTransfer() *Transfer {
	if x != nil {
		return x.Transfer
	}
	return nil
}

type ReturnLightningPaymentRequest struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	PaymentHash           []byte                 `protobuf:"bytes,1,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	UserIdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=user_identity_public_key,json=userIdentityPublicKey,proto3" json:"user_identity_public_key,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *ReturnLightningPaymentRequest) Reset() {
	*x = ReturnLightningPaymentRequest{}
	mi := &file_spark_proto_msgTypes[123]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReturnLightningPaymentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReturnLightningPaymentRequest) ProtoMessage() {}

func (x *ReturnLightningPaymentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[123]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReturnLightningPaymentRequest.ProtoReflect.Descriptor instead.
func (*ReturnLightningPaymentRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{123}
}

func (x *ReturnLightningPaymentRequest) GetPaymentHash() []byte {
	if x != nil {
		return x.PaymentHash
	}
	return nil
}

func (x *ReturnLightningPaymentRequest) GetUserIdentityPublicKey() []byte {
	if x != nil {
		return x.UserIdentityPublicKey
	}
	return nil
}

type TreeNodeIds struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NodeIds       []string               `protobuf:"bytes,1,rep,name=node_ids,json=nodeIds,proto3" json:"node_ids,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TreeNodeIds) Reset() {
	*x = TreeNodeIds{}
	mi := &file_spark_proto_msgTypes[124]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TreeNodeIds) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TreeNodeIds) ProtoMessage() {}

func (x *TreeNodeIds) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[124]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TreeNodeIds.ProtoReflect.Descriptor instead.
func (*TreeNodeIds) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{124}
}

func (x *TreeNodeIds) GetNodeIds() []string {
	if x != nil {
		return x.NodeIds
	}
	return nil
}

type QueryNodesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Source:
	//
	//	*QueryNodesRequest_OwnerIdentityPubkey
	//	*QueryNodesRequest_NodeIds
	Source         isQueryNodesRequest_Source `protobuf_oneof:"source"`
	IncludeParents bool                       `protobuf:"varint,3,opt,name=include_parents,json=includeParents,proto3" json:"include_parents,omitempty"`
	Limit          int64                      `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset         int64                      `protobuf:"varint,5,opt,name=offset,proto3" json:"offset,omitempty"`
	Network        Network                    `protobuf:"varint,6,opt,name=network,proto3,enum=spark.Network" json:"network,omitempty"` // defaults to mainnet when no network is provided. Does not check network when querying by node_ids
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *QueryNodesRequest) Reset() {
	*x = QueryNodesRequest{}
	mi := &file_spark_proto_msgTypes[125]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryNodesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryNodesRequest) ProtoMessage() {}

func (x *QueryNodesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[125]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryNodesRequest.ProtoReflect.Descriptor instead.
func (*QueryNodesRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{125}
}

func (x *QueryNodesRequest) GetSource() isQueryNodesRequest_Source {
	if x != nil {
		return x.Source
	}
	return nil
}

func (x *QueryNodesRequest) GetOwnerIdentityPubkey() []byte {
	if x != nil {
		if x, ok := x.Source.(*QueryNodesRequest_OwnerIdentityPubkey); ok {
			return x.OwnerIdentityPubkey
		}
	}
	return nil
}

func (x *QueryNodesRequest) GetNodeIds() *TreeNodeIds {
	if x != nil {
		if x, ok := x.Source.(*QueryNodesRequest_NodeIds); ok {
			return x.NodeIds
		}
	}
	return nil
}

func (x *QueryNodesRequest) GetIncludeParents() bool {
	if x != nil {
		return x.IncludeParents
	}
	return false
}

func (x *QueryNodesRequest) GetLimit() int64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *QueryNodesRequest) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *QueryNodesRequest) GetNetwork() Network {
	if x != nil {
		return x.Network
	}
	return Network_UNSPECIFIED
}

type isQueryNodesRequest_Source interface {
	isQueryNodesRequest_Source()
}

type QueryNodesRequest_OwnerIdentityPubkey struct {
	OwnerIdentityPubkey []byte `protobuf:"bytes,1,opt,name=owner_identity_pubkey,json=ownerIdentityPubkey,proto3,oneof"`
}

type QueryNodesRequest_NodeIds struct {
	NodeIds *TreeNodeIds `protobuf:"bytes,2,opt,name=node_ids,json=nodeIds,proto3,oneof"`
}

func (*QueryNodesRequest_OwnerIdentityPubkey) isQueryNodesRequest_Source() {}

func (*QueryNodesRequest_NodeIds) isQueryNodesRequest_Source() {}

type QueryNodesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Nodes         map[string]*TreeNode   `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Offset        int64                  `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueryNodesResponse) Reset() {
	*x = QueryNodesResponse{}
	mi := &file_spark_proto_msgTypes[126]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryNodesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryNodesResponse) ProtoMessage() {}

func (x *QueryNodesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[126]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryNodesResponse.ProtoReflect.Descriptor instead.
func (*QueryNodesResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{126}
}

func (x *QueryNodesResponse) GetNodes() map[string]*TreeNode {
	if x != nil {
		return x.Nodes
	}
	return nil
}

func (x *QueryNodesResponse) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type CancelTransferRequest struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	TransferId              string                 `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	SenderIdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=sender_identity_public_key,json=senderIdentityPublicKey,proto3" json:"sender_identity_public_key,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *CancelTransferRequest) Reset() {
	*x = CancelTransferRequest{}
	mi := &file_spark_proto_msgTypes[127]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CancelTransferRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CancelTransferRequest) ProtoMessage() {}

func (x *CancelTransferRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[127]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CancelTransferRequest.ProtoReflect.Descriptor instead.
func (*CancelTransferRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{127}
}

func (x *CancelTransferRequest) GetTransferId() string {
	if x != nil {
		return x.TransferId
	}
	return ""
}

func (x *CancelTransferRequest) GetSenderIdentityPublicKey() []byte {
	if x != nil {
		return x.SenderIdentityPublicKey
	}
	return nil
}

type CancelTransferResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Transfer      *Transfer              `protobuf:"bytes,1,opt,name=transfer,proto3" json:"transfer,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CancelTransferResponse) Reset() {
	*x = CancelTransferResponse{}
	mi := &file_spark_proto_msgTypes[128]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CancelTransferResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CancelTransferResponse) ProtoMessage() {}

func (x *CancelTransferResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[128]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CancelTransferResponse.ProtoReflect.Descriptor instead.
func (*CancelTransferResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{128}
}

func (x *CancelTransferResponse) GetTransfer() *Transfer {
	if x != nil {
		return x.Transfer
	}
	return nil
}

// *
// Returns a list of addresses that can be used in express deposit flow.
// Excludes static deposit addresses.
type QueryUnusedDepositAddressesRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	IdentityPublicKey []byte                 `protobuf:"bytes,1,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	Network           Network                `protobuf:"varint,2,opt,name=network,proto3,enum=spark.Network" json:"network,omitempty"` // defaults to mainnet when no network is provided.
	Limit             int64                  `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`                        // defaults to 100 if not set.
	Offset            int64                  `protobuf:"varint,4,opt,name=offset,proto3" json:"offset,omitempty"`                      // defaults to 0 if not set.
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *QueryUnusedDepositAddressesRequest) Reset() {
	*x = QueryUnusedDepositAddressesRequest{}
	mi := &file_spark_proto_msgTypes[129]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryUnusedDepositAddressesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryUnusedDepositAddressesRequest) ProtoMessage() {}

func (x *QueryUnusedDepositAddressesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[129]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryUnusedDepositAddressesRequest.ProtoReflect.Descriptor instead.
func (*QueryUnusedDepositAddressesRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{129}
}

func (x *QueryUnusedDepositAddressesRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

func (x *QueryUnusedDepositAddressesRequest) GetNetwork() Network {
	if x != nil {
		return x.Network
	}
	return Network_UNSPECIFIED
}

func (x *QueryUnusedDepositAddressesRequest) GetLimit() int64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *QueryUnusedDepositAddressesRequest) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type QueryStaticDepositAddressesRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	IdentityPublicKey []byte                 `protobuf:"bytes,1,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	Network           Network                `protobuf:"varint,2,opt,name=network,proto3,enum=spark.Network" json:"network,omitempty"` // defaults to mainnet when no network is provided.
	Limit             int64                  `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset            int64                  `protobuf:"varint,5,opt,name=offset,proto3" json:"offset,omitempty"`
	// Optional filter. When specified, only the DepositAddress with this address is returned.
	DepositAddress *string `protobuf:"bytes,6,opt,name=deposit_address,json=depositAddress,proto3,oneof" json:"deposit_address,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *QueryStaticDepositAddressesRequest) Reset() {
	*x = QueryStaticDepositAddressesRequest{}
	mi := &file_spark_proto_msgTypes[130]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryStaticDepositAddressesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryStaticDepositAddressesRequest) ProtoMessage() {}

func (x *QueryStaticDepositAddressesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[130]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryStaticDepositAddressesRequest.ProtoReflect.Descriptor instead.
func (*QueryStaticDepositAddressesRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{130}
}

func (x *QueryStaticDepositAddressesRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

func (x *QueryStaticDepositAddressesRequest) GetNetwork() Network {
	if x != nil {
		return x.Network
	}
	return Network_UNSPECIFIED
}

func (x *QueryStaticDepositAddressesRequest) GetLimit() int64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *QueryStaticDepositAddressesRequest) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *QueryStaticDepositAddressesRequest) GetDepositAddress() string {
	if x != nil && x.DepositAddress != nil {
		return *x.DepositAddress
	}
	return ""
}

type DepositAddressQueryResult struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	DepositAddress       string                 `protobuf:"bytes,1,opt,name=deposit_address,json=depositAddress,proto3" json:"deposit_address,omitempty"`
	UserSigningPublicKey []byte                 `protobuf:"bytes,2,opt,name=user_signing_public_key,json=userSigningPublicKey,proto3" json:"user_signing_public_key,omitempty"`
	VerifyingPublicKey   []byte                 `protobuf:"bytes,3,opt,name=verifying_public_key,json=verifyingPublicKey,proto3" json:"verifying_public_key,omitempty"`
	LeafId               *string                `protobuf:"bytes,4,opt,name=leaf_id,json=leafId,proto3,oneof" json:"leaf_id,omitempty"`
	ProofOfPossession    *DepositAddressProof   `protobuf:"bytes,5,opt,name=proof_of_possession,json=proofOfPossession,proto3,oneof" json:"proof_of_possession,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *DepositAddressQueryResult) Reset() {
	*x = DepositAddressQueryResult{}
	mi := &file_spark_proto_msgTypes[131]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DepositAddressQueryResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DepositAddressQueryResult) ProtoMessage() {}

func (x *DepositAddressQueryResult) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[131]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DepositAddressQueryResult.ProtoReflect.Descriptor instead.
func (*DepositAddressQueryResult) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{131}
}

func (x *DepositAddressQueryResult) GetDepositAddress() string {
	if x != nil {
		return x.DepositAddress
	}
	return ""
}

func (x *DepositAddressQueryResult) GetUserSigningPublicKey() []byte {
	if x != nil {
		return x.UserSigningPublicKey
	}
	return nil
}

func (x *DepositAddressQueryResult) GetVerifyingPublicKey() []byte {
	if x != nil {
		return x.VerifyingPublicKey
	}
	return nil
}

func (x *DepositAddressQueryResult) GetLeafId() string {
	if x != nil && x.LeafId != nil {
		return *x.LeafId
	}
	return ""
}

func (x *DepositAddressQueryResult) GetProofOfPossession() *DepositAddressProof {
	if x != nil {
		return x.ProofOfPossession
	}
	return nil
}

type QueryUnusedDepositAddressesResponse struct {
	state            protoimpl.MessageState       `protogen:"open.v1"`
	DepositAddresses []*DepositAddressQueryResult `protobuf:"bytes,1,rep,name=deposit_addresses,json=depositAddresses,proto3" json:"deposit_addresses,omitempty"`
	Offset           int64                        `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"` // defaults to -1 if there are no more results
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *QueryUnusedDepositAddressesResponse) Reset() {
	*x = QueryUnusedDepositAddressesResponse{}
	mi := &file_spark_proto_msgTypes[132]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryUnusedDepositAddressesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryUnusedDepositAddressesResponse) ProtoMessage() {}

func (x *QueryUnusedDepositAddressesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[132]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryUnusedDepositAddressesResponse.ProtoReflect.Descriptor instead.
func (*QueryUnusedDepositAddressesResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{132}
}

func (x *QueryUnusedDepositAddressesResponse) GetDepositAddresses() []*DepositAddressQueryResult {
	if x != nil {
		return x.DepositAddresses
	}
	return nil
}

func (x *QueryUnusedDepositAddressesResponse) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type QueryStaticDepositAddressesResponse struct {
	state            protoimpl.MessageState       `protogen:"open.v1"`
	DepositAddresses []*DepositAddressQueryResult `protobuf:"bytes,1,rep,name=deposit_addresses,json=depositAddresses,proto3" json:"deposit_addresses,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *QueryStaticDepositAddressesResponse) Reset() {
	*x = QueryStaticDepositAddressesResponse{}
	mi := &file_spark_proto_msgTypes[133]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryStaticDepositAddressesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryStaticDepositAddressesResponse) ProtoMessage() {}

func (x *QueryStaticDepositAddressesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[133]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryStaticDepositAddressesResponse.ProtoReflect.Descriptor instead.
func (*QueryStaticDepositAddressesResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{133}
}

func (x *QueryStaticDepositAddressesResponse) GetDepositAddresses() []*DepositAddressQueryResult {
	if x != nil {
		return x.DepositAddresses
	}
	return nil
}

type QueryBalanceRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	IdentityPublicKey []byte                 `protobuf:"bytes,1,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	Network           Network                `protobuf:"varint,2,opt,name=network,proto3,enum=spark.Network" json:"network,omitempty"` // defaults to mainnet when no network is provided.
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *QueryBalanceRequest) Reset() {
	*x = QueryBalanceRequest{}
	mi := &file_spark_proto_msgTypes[134]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryBalanceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryBalanceRequest) ProtoMessage() {}

func (x *QueryBalanceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[134]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryBalanceRequest.ProtoReflect.Descriptor instead.
func (*QueryBalanceRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{134}
}

func (x *QueryBalanceRequest) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

func (x *QueryBalanceRequest) GetNetwork() Network {
	if x != nil {
		return x.Network
	}
	return Network_UNSPECIFIED
}

type QueryBalanceResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Balance       uint64                 `protobuf:"varint,1,opt,name=balance,proto3" json:"balance,omitempty"`
	NodeBalances  map[string]uint64      `protobuf:"bytes,2,rep,name=node_balances,json=nodeBalances,proto3" json:"node_balances,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueryBalanceResponse) Reset() {
	*x = QueryBalanceResponse{}
	mi := &file_spark_proto_msgTypes[135]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryBalanceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryBalanceResponse) ProtoMessage() {}

func (x *QueryBalanceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[135]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryBalanceResponse.ProtoReflect.Descriptor instead.
func (*QueryBalanceResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{135}
}

func (x *QueryBalanceResponse) GetBalance() uint64 {
	if x != nil {
		return x.Balance
	}
	return 0
}

func (x *QueryBalanceResponse) GetNodeBalances() map[string]uint64 {
	if x != nil {
		return x.NodeBalances
	}
	return nil
}

type SparkAddress struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	IdentityPublicKey  []byte                 `protobuf:"bytes,1,opt,name=identity_public_key,json=identityPublicKey,proto3" json:"identity_public_key,omitempty"`
	SparkInvoiceFields *SparkInvoiceFields    `protobuf:"bytes,2,opt,name=spark_invoice_fields,json=sparkInvoiceFields,proto3" json:"spark_invoice_fields,omitempty"`
	Signature          []byte                 `protobuf:"bytes,3,opt,name=signature,proto3,oneof" json:"signature,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *SparkAddress) Reset() {
	*x = SparkAddress{}
	mi := &file_spark_proto_msgTypes[136]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SparkAddress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SparkAddress) ProtoMessage() {}

func (x *SparkAddress) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[136]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SparkAddress.ProtoReflect.Descriptor instead.
func (*SparkAddress) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{136}
}

func (x *SparkAddress) GetIdentityPublicKey() []byte {
	if x != nil {
		return x.IdentityPublicKey
	}
	return nil
}

func (x *SparkAddress) GetSparkInvoiceFields() *SparkInvoiceFields {
	if x != nil {
		return x.SparkInvoiceFields
	}
	return nil
}

func (x *SparkAddress) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

type SparkInvoiceFields struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Version uint32                 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	Id      []byte                 `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// Types that are valid to be assigned to PaymentType:
	//
	//	*SparkInvoiceFields_TokensPayment
	//	*SparkInvoiceFields_SatsPayment
	PaymentType     isSparkInvoiceFields_PaymentType `protobuf_oneof:"payment_type"`
	Memo            *string                          `protobuf:"bytes,5,opt,name=memo,proto3,oneof" json:"memo,omitempty"`
	SenderPublicKey []byte                           `protobuf:"bytes,6,opt,name=sender_public_key,json=senderPublicKey,proto3,oneof" json:"sender_public_key,omitempty"`
	ExpiryTime      *timestamppb.Timestamp           `protobuf:"bytes,7,opt,name=expiry_time,json=expiryTime,proto3,oneof" json:"expiry_time,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SparkInvoiceFields) Reset() {
	*x = SparkInvoiceFields{}
	mi := &file_spark_proto_msgTypes[137]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SparkInvoiceFields) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SparkInvoiceFields) ProtoMessage() {}

func (x *SparkInvoiceFields) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[137]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SparkInvoiceFields.ProtoReflect.Descriptor instead.
func (*SparkInvoiceFields) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{137}
}

func (x *SparkInvoiceFields) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *SparkInvoiceFields) GetId() []byte {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *SparkInvoiceFields) GetPaymentType() isSparkInvoiceFields_PaymentType {
	if x != nil {
		return x.PaymentType
	}
	return nil
}

func (x *SparkInvoiceFields) GetTokensPayment() *TokensPayment {
	if x != nil {
		if x, ok := x.PaymentType.(*SparkInvoiceFields_TokensPayment); ok {
			return x.TokensPayment
		}
	}
	return nil
}

func (x *SparkInvoiceFields) GetSatsPayment() *SatsPayment {
	if x != nil {
		if x, ok := x.PaymentType.(*SparkInvoiceFields_SatsPayment); ok {
			return x.SatsPayment
		}
	}
	return nil
}

func (x *SparkInvoiceFields) GetMemo() string {
	if x != nil && x.Memo != nil {
		return *x.Memo
	}
	return ""
}

func (x *SparkInvoiceFields) GetSenderPublicKey() []byte {
	if x != nil {
		return x.SenderPublicKey
	}
	return nil
}

func (x *SparkInvoiceFields) GetExpiryTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpiryTime
	}
	return nil
}

type isSparkInvoiceFields_PaymentType interface {
	isSparkInvoiceFields_PaymentType()
}

type SparkInvoiceFields_TokensPayment struct {
	TokensPayment *TokensPayment `protobuf:"bytes,3,opt,name=tokens_payment,json=tokensPayment,proto3,oneof"`
}

type SparkInvoiceFields_SatsPayment struct {
	SatsPayment *SatsPayment `protobuf:"bytes,4,opt,name=sats_payment,json=satsPayment,proto3,oneof"`
}

func (*SparkInvoiceFields_TokensPayment) isSparkInvoiceFields_PaymentType() {}

func (*SparkInvoiceFields_SatsPayment) isSparkInvoiceFields_PaymentType() {}

type SatsPayment struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Amount        *uint64                `protobuf:"varint,1,opt,name=amount,proto3,oneof" json:"amount,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SatsPayment) Reset() {
	*x = SatsPayment{}
	mi := &file_spark_proto_msgTypes[138]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SatsPayment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SatsPayment) ProtoMessage() {}

func (x *SatsPayment) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[138]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SatsPayment.ProtoReflect.Descriptor instead.
func (*SatsPayment) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{138}
}

func (x *SatsPayment) GetAmount() uint64 {
	if x != nil && x.Amount != nil {
		return *x.Amount
	}
	return 0
}

type TokensPayment struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	TokenIdentifier []byte                 `protobuf:"bytes,1,opt,name=token_identifier,json=tokenIdentifier,proto3,oneof" json:"token_identifier,omitempty"`
	Amount          []byte                 `protobuf:"bytes,2,opt,name=amount,proto3,oneof" json:"amount,omitempty"` // variable length uint128
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TokensPayment) Reset() {
	*x = TokensPayment{}
	mi := &file_spark_proto_msgTypes[139]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokensPayment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokensPayment) ProtoMessage() {}

func (x *TokensPayment) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[139]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokensPayment.ProtoReflect.Descriptor instead.
func (*TokensPayment) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{139}
}

func (x *TokensPayment) GetTokenIdentifier() []byte {
	if x != nil {
		return x.TokenIdentifier
	}
	return nil
}

func (x *TokensPayment) GetAmount() []byte {
	if x != nil {
		return x.Amount
	}
	return nil
}

type InitiateStaticDepositUtxoRefundRequest struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	OnChainUtxo *UTXO                  `protobuf:"bytes,1,opt,name=on_chain_utxo,json=onChainUtxo,proto3" json:"on_chain_utxo,omitempty"`
	// A package that is used for signing L1 Bitcoin transactions using FROST.
	// SE consumes it to return SigningResult structure, that is used by the user to
	// construct the final signature for the refund Bitcoin transaction.
	RefundTxSigningJob *SigningJob `protobuf:"bytes,3,opt,name=refund_tx_signing_job,json=refundTxSigningJob,proto3" json:"refund_tx_signing_job,omitempty"`
	// Signature of a user statement that authorises the SE to initiate a static
	// deposit utxo refund to the user.
	//
	// The user statement is constructed by concatenating the following fields in order:
	// 1. Action name: "claim_static_deposit" (UTF-8 string)
	// 2. Network: lowercase network name (e.g., "bitcoin", "testnet") (UTF-8 string)
	// 3. Transaction ID: hex-encoded UTXO transaction ID (UTF-8 string)
	// 4. Output index: UTXO output index (vout) as 4-byte unsigned integer (little-endian)
	// 5. Request type: 2 for refund (1-byte unsigned integer, little-endian)
	// 6. Credit amount: amount of satoshis to credit as 8-byte unsigned integer (little-endian)
	// 7. Signing payload: sighash of spend transaction (UTF-8 string)
	//
	// The concatenated payload is then hashed with SHA-256, and the resulting hash
	// is signed using ECDSA with the user's identity private key to produce this signature.
	UserSignature []byte `protobuf:"bytes,4,opt,name=user_signature,json=userSignature,proto3" json:"user_signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InitiateStaticDepositUtxoRefundRequest) Reset() {
	*x = InitiateStaticDepositUtxoRefundRequest{}
	mi := &file_spark_proto_msgTypes[140]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitiateStaticDepositUtxoRefundRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitiateStaticDepositUtxoRefundRequest) ProtoMessage() {}

func (x *InitiateStaticDepositUtxoRefundRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[140]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitiateStaticDepositUtxoRefundRequest.ProtoReflect.Descriptor instead.
func (*InitiateStaticDepositUtxoRefundRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{140}
}

func (x *InitiateStaticDepositUtxoRefundRequest) GetOnChainUtxo() *UTXO {
	if x != nil {
		return x.OnChainUtxo
	}
	return nil
}

func (x *InitiateStaticDepositUtxoRefundRequest) GetRefundTxSigningJob() *SigningJob {
	if x != nil {
		return x.RefundTxSigningJob
	}
	return nil
}

func (x *InitiateStaticDepositUtxoRefundRequest) GetUserSignature() []byte {
	if x != nil {
		return x.UserSignature
	}
	return nil
}

type InitiateStaticDepositUtxoRefundResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The FROST signing results which must be aggregated by the user to complete signing
	RefundTxSigningResult *SigningResult             `protobuf:"bytes,1,opt,name=refund_tx_signing_result,json=refundTxSigningResult,proto3" json:"refund_tx_signing_result,omitempty"`
	DepositAddress        *DepositAddressQueryResult `protobuf:"bytes,2,opt,name=deposit_address,json=depositAddress,proto3" json:"deposit_address,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *InitiateStaticDepositUtxoRefundResponse) Reset() {
	*x = InitiateStaticDepositUtxoRefundResponse{}
	mi := &file_spark_proto_msgTypes[141]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitiateStaticDepositUtxoRefundResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitiateStaticDepositUtxoRefundResponse) ProtoMessage() {}

func (x *InitiateStaticDepositUtxoRefundResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[141]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitiateStaticDepositUtxoRefundResponse.ProtoReflect.Descriptor instead.
func (*InitiateStaticDepositUtxoRefundResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{141}
}

func (x *InitiateStaticDepositUtxoRefundResponse) GetRefundTxSigningResult() *SigningResult {
	if x != nil {
		return x.RefundTxSigningResult
	}
	return nil
}

func (x *InitiateStaticDepositUtxoRefundResponse) GetDepositAddress() *DepositAddressQueryResult {
	if x != nil {
		return x.DepositAddress
	}
	return nil
}

type InitiateUtxoSwapRequest struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	OnChainUtxo *UTXO                  `protobuf:"bytes,1,opt,name=on_chain_utxo,json=onChainUtxo,proto3" json:"on_chain_utxo,omitempty"`
	RequestType UtxoSwapRequestType    `protobuf:"varint,2,opt,name=request_type,json=requestType,proto3,enum=spark.UtxoSwapRequestType" json:"request_type,omitempty"`
	// Types that are valid to be assigned to Amount:
	//
	//	*InitiateUtxoSwapRequest_CreditAmountSats
	//	*InitiateUtxoSwapRequest_MaxFeeSats
	Amount            isInitiateUtxoSwapRequest_Amount `protobuf_oneof:"amount"`
	SspSignature      []byte                           `protobuf:"bytes,5,opt,name=ssp_signature,json=sspSignature,proto3" json:"ssp_signature,omitempty"`
	UserSignature     []byte                           `protobuf:"bytes,6,opt,name=user_signature,json=userSignature,proto3" json:"user_signature,omitempty"`
	Transfer          *StartTransferRequest            `protobuf:"bytes,7,opt,name=transfer,proto3" json:"transfer,omitempty"`
	SpendTxSigningJob *SigningJob                      `protobuf:"bytes,8,opt,name=spend_tx_signing_job,json=spendTxSigningJob,proto3" json:"spend_tx_signing_job,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *InitiateUtxoSwapRequest) Reset() {
	*x = InitiateUtxoSwapRequest{}
	mi := &file_spark_proto_msgTypes[142]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitiateUtxoSwapRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitiateUtxoSwapRequest) ProtoMessage() {}

func (x *InitiateUtxoSwapRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[142]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitiateUtxoSwapRequest.ProtoReflect.Descriptor instead.
func (*InitiateUtxoSwapRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{142}
}

func (x *InitiateUtxoSwapRequest) GetOnChainUtxo() *UTXO {
	if x != nil {
		return x.OnChainUtxo
	}
	return nil
}

func (x *InitiateUtxoSwapRequest) GetRequestType() UtxoSwapRequestType {
	if x != nil {
		return x.RequestType
	}
	return UtxoSwapRequestType_Fixed
}

func (x *InitiateUtxoSwapRequest) GetAmount() isInitiateUtxoSwapRequest_Amount {
	if x != nil {
		return x.Amount
	}
	return nil
}

func (x *InitiateUtxoSwapRequest) GetCreditAmountSats() uint64 {
	if x != nil {
		if x, ok := x.Amount.(*InitiateUtxoSwapRequest_CreditAmountSats); ok {
			return x.CreditAmountSats
		}
	}
	return 0
}

func (x *InitiateUtxoSwapRequest) GetMaxFeeSats() uint64 {
	if x != nil {
		if x, ok := x.Amount.(*InitiateUtxoSwapRequest_MaxFeeSats); ok {
			return x.MaxFeeSats
		}
	}
	return 0
}

func (x *InitiateUtxoSwapRequest) GetSspSignature() []byte {
	if x != nil {
		return x.SspSignature
	}
	return nil
}

func (x *InitiateUtxoSwapRequest) GetUserSignature() []byte {
	if x != nil {
		return x.UserSignature
	}
	return nil
}

func (x *InitiateUtxoSwapRequest) GetTransfer() *StartTransferRequest {
	if x != nil {
		return x.Transfer
	}
	return nil
}

func (x *InitiateUtxoSwapRequest) GetSpendTxSigningJob() *SigningJob {
	if x != nil {
		return x.SpendTxSigningJob
	}
	return nil
}

type isInitiateUtxoSwapRequest_Amount interface {
	isInitiateUtxoSwapRequest_Amount()
}

type InitiateUtxoSwapRequest_CreditAmountSats struct {
	CreditAmountSats uint64 `protobuf:"varint,3,opt,name=credit_amount_sats,json=creditAmountSats,proto3,oneof"`
}

type InitiateUtxoSwapRequest_MaxFeeSats struct {
	MaxFeeSats uint64 `protobuf:"varint,4,opt,name=max_fee_sats,json=maxFeeSats,proto3,oneof"`
}

func (*InitiateUtxoSwapRequest_CreditAmountSats) isInitiateUtxoSwapRequest_Amount() {}

func (*InitiateUtxoSwapRequest_MaxFeeSats) isInitiateUtxoSwapRequest_Amount() {}

type InitiateUtxoSwapResponse struct {
	state                protoimpl.MessageState     `protogen:"open.v1"`
	SpendTxSigningResult *SigningResult             `protobuf:"bytes,1,opt,name=spend_tx_signing_result,json=spendTxSigningResult,proto3" json:"spend_tx_signing_result,omitempty"`
	Transfer             *Transfer                  `protobuf:"bytes,2,opt,name=transfer,proto3" json:"transfer,omitempty"`
	DepositAddress       *DepositAddressQueryResult `protobuf:"bytes,3,opt,name=deposit_address,json=depositAddress,proto3" json:"deposit_address,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *InitiateUtxoSwapResponse) Reset() {
	*x = InitiateUtxoSwapResponse{}
	mi := &file_spark_proto_msgTypes[143]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitiateUtxoSwapResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitiateUtxoSwapResponse) ProtoMessage() {}

func (x *InitiateUtxoSwapResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[143]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitiateUtxoSwapResponse.ProtoReflect.Descriptor instead.
func (*InitiateUtxoSwapResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{143}
}

func (x *InitiateUtxoSwapResponse) GetSpendTxSigningResult() *SigningResult {
	if x != nil {
		return x.SpendTxSigningResult
	}
	return nil
}

func (x *InitiateUtxoSwapResponse) GetTransfer() *Transfer {
	if x != nil {
		return x.Transfer
	}
	return nil
}

func (x *InitiateUtxoSwapResponse) GetDepositAddress() *DepositAddressQueryResult {
	if x != nil {
		return x.DepositAddress
	}
	return nil
}

type ExitingTree struct {
	state                 protoimpl.MessageState    `protogen:"open.v1"`
	TreeId                string                    `protobuf:"bytes,1,opt,name=tree_id,json=treeId,proto3" json:"tree_id,omitempty"`
	UserSigningCommitment *common.SigningCommitment `protobuf:"bytes,2,opt,name=user_signing_commitment,json=userSigningCommitment,proto3" json:"user_signing_commitment,omitempty"`
	Vin                   uint32                    `protobuf:"varint,3,opt,name=vin,proto3" json:"vin,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *ExitingTree) Reset() {
	*x = ExitingTree{}
	mi := &file_spark_proto_msgTypes[144]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExitingTree) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExitingTree) ProtoMessage() {}

func (x *ExitingTree) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[144]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExitingTree.ProtoReflect.Descriptor instead.
func (*ExitingTree) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{144}
}

func (x *ExitingTree) GetTreeId() string {
	if x != nil {
		return x.TreeId
	}
	return ""
}

func (x *ExitingTree) GetUserSigningCommitment() *common.SigningCommitment {
	if x != nil {
		return x.UserSigningCommitment
	}
	return nil
}

func (x *ExitingTree) GetVin() uint32 {
	if x != nil {
		return x.Vin
	}
	return 0
}

type ExitSingleNodeTreeSigningResult struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TreeId        string                 `protobuf:"bytes,1,opt,name=tree_id,json=treeId,proto3" json:"tree_id,omitempty"`
	SigningResult *SigningResult         `protobuf:"bytes,2,opt,name=signing_result,json=signingResult,proto3" json:"signing_result,omitempty"`
	VerifyingKey  []byte                 `protobuf:"bytes,3,opt,name=verifying_key,json=verifyingKey,proto3" json:"verifying_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExitSingleNodeTreeSigningResult) Reset() {
	*x = ExitSingleNodeTreeSigningResult{}
	mi := &file_spark_proto_msgTypes[145]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExitSingleNodeTreeSigningResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExitSingleNodeTreeSigningResult) ProtoMessage() {}

func (x *ExitSingleNodeTreeSigningResult) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[145]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExitSingleNodeTreeSigningResult.ProtoReflect.Descriptor instead.
func (*ExitSingleNodeTreeSigningResult) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{145}
}

func (x *ExitSingleNodeTreeSigningResult) GetTreeId() string {
	if x != nil {
		return x.TreeId
	}
	return ""
}

func (x *ExitSingleNodeTreeSigningResult) GetSigningResult() *SigningResult {
	if x != nil {
		return x.SigningResult
	}
	return nil
}

func (x *ExitSingleNodeTreeSigningResult) GetVerifyingKey() []byte {
	if x != nil {
		return x.VerifyingKey
	}
	return nil
}

type BitcoinTransactionOutput struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         int64                  `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	PkScript      []byte                 `protobuf:"bytes,2,opt,name=pk_script,json=pkScript,proto3" json:"pk_script,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BitcoinTransactionOutput) Reset() {
	*x = BitcoinTransactionOutput{}
	mi := &file_spark_proto_msgTypes[146]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BitcoinTransactionOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BitcoinTransactionOutput) ProtoMessage() {}

func (x *BitcoinTransactionOutput) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[146]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BitcoinTransactionOutput.ProtoReflect.Descriptor instead.
func (*BitcoinTransactionOutput) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{146}
}

func (x *BitcoinTransactionOutput) GetValue() int64 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *BitcoinTransactionOutput) GetPkScript() []byte {
	if x != nil {
		return x.PkScript
	}
	return nil
}

type ExitSingleNodeTreesRequest struct {
	state                  protoimpl.MessageState      `protogen:"open.v1"`
	OwnerIdentityPublicKey []byte                      `protobuf:"bytes,1,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	ExitingTrees           []*ExitingTree              `protobuf:"bytes,2,rep,name=exiting_trees,json=exitingTrees,proto3" json:"exiting_trees,omitempty"`
	RawTx                  []byte                      `protobuf:"bytes,3,opt,name=raw_tx,json=rawTx,proto3" json:"raw_tx,omitempty"`
	PreviousOutputs        []*BitcoinTransactionOutput `protobuf:"bytes,4,rep,name=previous_outputs,json=previousOutputs,proto3" json:"previous_outputs,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *ExitSingleNodeTreesRequest) Reset() {
	*x = ExitSingleNodeTreesRequest{}
	mi := &file_spark_proto_msgTypes[147]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExitSingleNodeTreesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExitSingleNodeTreesRequest) ProtoMessage() {}

func (x *ExitSingleNodeTreesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[147]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExitSingleNodeTreesRequest.ProtoReflect.Descriptor instead.
func (*ExitSingleNodeTreesRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{147}
}

func (x *ExitSingleNodeTreesRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

func (x *ExitSingleNodeTreesRequest) GetExitingTrees() []*ExitingTree {
	if x != nil {
		return x.ExitingTrees
	}
	return nil
}

func (x *ExitSingleNodeTreesRequest) GetRawTx() []byte {
	if x != nil {
		return x.RawTx
	}
	return nil
}

func (x *ExitSingleNodeTreesRequest) GetPreviousOutputs() []*BitcoinTransactionOutput {
	if x != nil {
		return x.PreviousOutputs
	}
	return nil
}

type ExitSingleNodeTreesResponse struct {
	state          protoimpl.MessageState             `protogen:"open.v1"`
	SigningResults []*ExitSingleNodeTreeSigningResult `protobuf:"bytes,1,rep,name=signing_results,json=signingResults,proto3" json:"signing_results,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ExitSingleNodeTreesResponse) Reset() {
	*x = ExitSingleNodeTreesResponse{}
	mi := &file_spark_proto_msgTypes[148]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExitSingleNodeTreesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExitSingleNodeTreesResponse) ProtoMessage() {}

func (x *ExitSingleNodeTreesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[148]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExitSingleNodeTreesResponse.ProtoReflect.Descriptor instead.
func (*ExitSingleNodeTreesResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{148}
}

func (x *ExitSingleNodeTreesResponse) GetSigningResults() []*ExitSingleNodeTreeSigningResult {
	if x != nil {
		return x.SigningResults
	}
	return nil
}

type InvestigateLeavesRequest struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	LeafIds                []string               `protobuf:"bytes,1,rep,name=leaf_ids,json=leafIds,proto3" json:"leaf_ids,omitempty"`
	OwnerIdentityPublicKey []byte                 `protobuf:"bytes,2,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	TransferId             string                 `protobuf:"bytes,3,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *InvestigateLeavesRequest) Reset() {
	*x = InvestigateLeavesRequest{}
	mi := &file_spark_proto_msgTypes[149]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InvestigateLeavesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InvestigateLeavesRequest) ProtoMessage() {}

func (x *InvestigateLeavesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[149]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InvestigateLeavesRequest.ProtoReflect.Descriptor instead.
func (*InvestigateLeavesRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{149}
}

func (x *InvestigateLeavesRequest) GetLeafIds() []string {
	if x != nil {
		return x.LeafIds
	}
	return nil
}

func (x *InvestigateLeavesRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

func (x *InvestigateLeavesRequest) GetTransferId() string {
	if x != nil {
		return x.TransferId
	}
	return ""
}

type QueryNodesDistributionRequest struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	OwnerIdentityPublicKey []byte                 `protobuf:"bytes,1,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *QueryNodesDistributionRequest) Reset() {
	*x = QueryNodesDistributionRequest{}
	mi := &file_spark_proto_msgTypes[150]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryNodesDistributionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryNodesDistributionRequest) ProtoMessage() {}

func (x *QueryNodesDistributionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[150]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryNodesDistributionRequest.ProtoReflect.Descriptor instead.
func (*QueryNodesDistributionRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{150}
}

func (x *QueryNodesDistributionRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

type QueryNodesDistributionResponse struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	NodeDistribution map[uint64]uint64      `protobuf:"bytes,1,rep,name=node_distribution,json=nodeDistribution,proto3" json:"node_distribution,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *QueryNodesDistributionResponse) Reset() {
	*x = QueryNodesDistributionResponse{}
	mi := &file_spark_proto_msgTypes[151]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryNodesDistributionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryNodesDistributionResponse) ProtoMessage() {}

func (x *QueryNodesDistributionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[151]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryNodesDistributionResponse.ProtoReflect.Descriptor instead.
func (*QueryNodesDistributionResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{151}
}

func (x *QueryNodesDistributionResponse) GetNodeDistribution() map[uint64]uint64 {
	if x != nil {
		return x.NodeDistribution
	}
	return nil
}

type QueryNodesByValueRequest struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	OwnerIdentityPublicKey []byte                 `protobuf:"bytes,1,opt,name=owner_identity_public_key,json=ownerIdentityPublicKey,proto3" json:"owner_identity_public_key,omitempty"`
	Value                  int64                  `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
	Offset                 int64                  `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	Limit                  int64                  `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *QueryNodesByValueRequest) Reset() {
	*x = QueryNodesByValueRequest{}
	mi := &file_spark_proto_msgTypes[152]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryNodesByValueRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryNodesByValueRequest) ProtoMessage() {}

func (x *QueryNodesByValueRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[152]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryNodesByValueRequest.ProtoReflect.Descriptor instead.
func (*QueryNodesByValueRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{152}
}

func (x *QueryNodesByValueRequest) GetOwnerIdentityPublicKey() []byte {
	if x != nil {
		return x.OwnerIdentityPublicKey
	}
	return nil
}

func (x *QueryNodesByValueRequest) GetValue() int64 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *QueryNodesByValueRequest) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *QueryNodesByValueRequest) GetLimit() int64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

type QueryNodesByValueResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Nodes         map[string]*TreeNode   `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Offset        int64                  `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueryNodesByValueResponse) Reset() {
	*x = QueryNodesByValueResponse{}
	mi := &file_spark_proto_msgTypes[153]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryNodesByValueResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryNodesByValueResponse) ProtoMessage() {}

func (x *QueryNodesByValueResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[153]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryNodesByValueResponse.ProtoReflect.Descriptor instead.
func (*QueryNodesByValueResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{153}
}

func (x *QueryNodesByValueResponse) GetNodes() map[string]*TreeNode {
	if x != nil {
		return x.Nodes
	}
	return nil
}

func (x *QueryNodesByValueResponse) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type GetUtxosForAddressRequest struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Address        string                 `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Offset         uint64                 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	Limit          uint64                 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	Network        Network                `protobuf:"varint,4,opt,name=network,proto3,enum=spark.Network" json:"network,omitempty"`
	ExcludeClaimed bool                   `protobuf:"varint,5,opt,name=exclude_claimed,json=excludeClaimed,proto3" json:"exclude_claimed,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *GetUtxosForAddressRequest) Reset() {
	*x = GetUtxosForAddressRequest{}
	mi := &file_spark_proto_msgTypes[154]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetUtxosForAddressRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetUtxosForAddressRequest) ProtoMessage() {}

func (x *GetUtxosForAddressRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[154]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetUtxosForAddressRequest.ProtoReflect.Descriptor instead.
func (*GetUtxosForAddressRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{154}
}

func (x *GetUtxosForAddressRequest) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *GetUtxosForAddressRequest) GetOffset() uint64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *GetUtxosForAddressRequest) GetLimit() uint64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *GetUtxosForAddressRequest) GetNetwork() Network {
	if x != nil {
		return x.Network
	}
	return Network_UNSPECIFIED
}

func (x *GetUtxosForAddressRequest) GetExcludeClaimed() bool {
	if x != nil {
		return x.ExcludeClaimed
	}
	return false
}

type GetUtxosForAddressResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Utxos         []*UTXO                `protobuf:"bytes,1,rep,name=utxos,proto3" json:"utxos,omitempty"`
	Offset        uint64                 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetUtxosForAddressResponse) Reset() {
	*x = GetUtxosForAddressResponse{}
	mi := &file_spark_proto_msgTypes[155]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetUtxosForAddressResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetUtxosForAddressResponse) ProtoMessage() {}

func (x *GetUtxosForAddressResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[155]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetUtxosForAddressResponse.ProtoReflect.Descriptor instead.
func (*GetUtxosForAddressResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{155}
}

func (x *GetUtxosForAddressResponse) GetUtxos() []*UTXO {
	if x != nil {
		return x.Utxos
	}
	return nil
}

func (x *GetUtxosForAddressResponse) GetOffset() uint64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type QuerySparkInvoicesRequest struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Limit  int64                  `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset int64                  `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	// returns the status for the provided list of spark invoices.
	Invoice       []string `protobuf:"bytes,3,rep,name=invoice,proto3" json:"invoice,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QuerySparkInvoicesRequest) Reset() {
	*x = QuerySparkInvoicesRequest{}
	mi := &file_spark_proto_msgTypes[156]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QuerySparkInvoicesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QuerySparkInvoicesRequest) ProtoMessage() {}

func (x *QuerySparkInvoicesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[156]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QuerySparkInvoicesRequest.ProtoReflect.Descriptor instead.
func (*QuerySparkInvoicesRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{156}
}

func (x *QuerySparkInvoicesRequest) GetLimit() int64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *QuerySparkInvoicesRequest) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *QuerySparkInvoicesRequest) GetInvoice() []string {
	if x != nil {
		return x.Invoice
	}
	return nil
}

type QuerySparkInvoicesResponse struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Offset          int64                  `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"`
	InvoiceStatuses []*InvoiceResponse     `protobuf:"bytes,2,rep,name=invoice_statuses,json=invoiceStatuses,proto3" json:"invoice_statuses,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *QuerySparkInvoicesResponse) Reset() {
	*x = QuerySparkInvoicesResponse{}
	mi := &file_spark_proto_msgTypes[157]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QuerySparkInvoicesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QuerySparkInvoicesResponse) ProtoMessage() {}

func (x *QuerySparkInvoicesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[157]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QuerySparkInvoicesResponse.ProtoReflect.Descriptor instead.
func (*QuerySparkInvoicesResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{157}
}

func (x *QuerySparkInvoicesResponse) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *QuerySparkInvoicesResponse) GetInvoiceStatuses() []*InvoiceResponse {
	if x != nil {
		return x.InvoiceStatuses
	}
	return nil
}

type InvoiceResponse struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Invoice string                 `protobuf:"bytes,1,opt,name=invoice,proto3" json:"invoice,omitempty"`
	Status  InvoiceStatus          `protobuf:"varint,2,opt,name=status,proto3,enum=spark.InvoiceStatus" json:"status,omitempty"`
	// Types that are valid to be assigned to TransferType:
	//
	//	*InvoiceResponse_SatsTransfer
	//	*InvoiceResponse_TokenTransfer
	TransferType  isInvoiceResponse_TransferType `protobuf_oneof:"transfer_type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InvoiceResponse) Reset() {
	*x = InvoiceResponse{}
	mi := &file_spark_proto_msgTypes[158]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InvoiceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InvoiceResponse) ProtoMessage() {}

func (x *InvoiceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[158]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InvoiceResponse.ProtoReflect.Descriptor instead.
func (*InvoiceResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{158}
}

func (x *InvoiceResponse) GetInvoice() string {
	if x != nil {
		return x.Invoice
	}
	return ""
}

func (x *InvoiceResponse) GetStatus() InvoiceStatus {
	if x != nil {
		return x.Status
	}
	return InvoiceStatus_NOT_FOUND
}

func (x *InvoiceResponse) GetTransferType() isInvoiceResponse_TransferType {
	if x != nil {
		return x.TransferType
	}
	return nil
}

func (x *InvoiceResponse) GetSatsTransfer() *SatsTransfer {
	if x != nil {
		if x, ok := x.TransferType.(*InvoiceResponse_SatsTransfer); ok {
			return x.SatsTransfer
		}
	}
	return nil
}

func (x *InvoiceResponse) GetTokenTransfer() *TokenTransfer {
	if x != nil {
		if x, ok := x.TransferType.(*InvoiceResponse_TokenTransfer); ok {
			return x.TokenTransfer
		}
	}
	return nil
}

type isInvoiceResponse_TransferType interface {
	isInvoiceResponse_TransferType()
}

type InvoiceResponse_SatsTransfer struct {
	SatsTransfer *SatsTransfer `protobuf:"bytes,3,opt,name=sats_transfer,json=satsTransfer,proto3,oneof"`
}

type InvoiceResponse_TokenTransfer struct {
	TokenTransfer *TokenTransfer `protobuf:"bytes,4,opt,name=token_transfer,json=tokenTransfer,proto3,oneof"`
}

func (*InvoiceResponse_SatsTransfer) isInvoiceResponse_TransferType() {}

func (*InvoiceResponse_TokenTransfer) isInvoiceResponse_TransferType() {}

type SatsTransfer struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TransferId    []byte                 `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SatsTransfer) Reset() {
	*x = SatsTransfer{}
	mi := &file_spark_proto_msgTypes[159]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SatsTransfer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SatsTransfer) ProtoMessage() {}

func (x *SatsTransfer) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[159]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SatsTransfer.ProtoReflect.Descriptor instead.
func (*SatsTransfer) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{159}
}

func (x *SatsTransfer) GetTransferId() []byte {
	if x != nil {
		return x.TransferId
	}
	return nil
}

type TokenTransfer struct {
	state                     protoimpl.MessageState `protogen:"open.v1"`
	FinalTokenTransactionHash []byte                 `protobuf:"bytes,1,opt,name=final_token_transaction_hash,json=finalTokenTransactionHash,proto3" json:"final_token_transaction_hash,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *TokenTransfer) Reset() {
	*x = TokenTransfer{}
	mi := &file_spark_proto_msgTypes[160]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenTransfer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenTransfer) ProtoMessage() {}

func (x *TokenTransfer) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[160]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenTransfer.ProtoReflect.Descriptor instead.
func (*TokenTransfer) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{160}
}

func (x *TokenTransfer) GetFinalTokenTransactionHash() []byte {
	if x != nil {
		return x.FinalTokenTransactionHash
	}
	return nil
}

type InitiateSwapPrimaryTransferRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Transfer with refunds and key tweaks signed
	Transfer *StartTransferRequest `protobuf:"bytes,1,opt,name=transfer,proto3" json:"transfer,omitempty"`
	// Adaptor public keys to verify the signatures of refunds for the primary
	// transfer in the swap
	AdaptorPublicKeys *AdaptorPublicKeyPackage `protobuf:"bytes,2,opt,name=adaptor_public_keys,json=adaptorPublicKeys,proto3" json:"adaptor_public_keys,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *InitiateSwapPrimaryTransferRequest) Reset() {
	*x = InitiateSwapPrimaryTransferRequest{}
	mi := &file_spark_proto_msgTypes[161]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitiateSwapPrimaryTransferRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitiateSwapPrimaryTransferRequest) ProtoMessage() {}

func (x *InitiateSwapPrimaryTransferRequest) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[161]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitiateSwapPrimaryTransferRequest.ProtoReflect.Descriptor instead.
func (*InitiateSwapPrimaryTransferRequest) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{161}
}

func (x *InitiateSwapPrimaryTransferRequest) GetTransfer() *StartTransferRequest {
	if x != nil {
		return x.Transfer
	}
	return nil
}

func (x *InitiateSwapPrimaryTransferRequest) GetAdaptorPublicKeys() *AdaptorPublicKeyPackage {
	if x != nil {
		return x.AdaptorPublicKeys
	}
	return nil
}

type InitiateSwapPrimaryTransferResponse struct {
	state          protoimpl.MessageState       `protogen:"open.v1"`
	Transfer       *Transfer                    `protobuf:"bytes,1,opt,name=transfer,proto3" json:"transfer,omitempty"`
	SigningResults []*LeafRefundTxSigningResult `protobuf:"bytes,2,rep,name=signing_results,json=signingResults,proto3" json:"signing_results,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *InitiateSwapPrimaryTransferResponse) Reset() {
	*x = InitiateSwapPrimaryTransferResponse{}
	mi := &file_spark_proto_msgTypes[162]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitiateSwapPrimaryTransferResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitiateSwapPrimaryTransferResponse) ProtoMessage() {}

func (x *InitiateSwapPrimaryTransferResponse) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[162]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitiateSwapPrimaryTransferResponse.ProtoReflect.Descriptor instead.
func (*InitiateSwapPrimaryTransferResponse) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{162}
}

func (x *InitiateSwapPrimaryTransferResponse) GetTransfer() *Transfer {
	if x != nil {
		return x.Transfer
	}
	return nil
}

func (x *InitiateSwapPrimaryTransferResponse) GetSigningResults() []*LeafRefundTxSigningResult {
	if x != nil {
		return x.SigningResults
	}
	return nil
}

// Adaptor public key is derived from the secret `t` using formula:
// ```
// T = t * G
// ```
type AdaptorPublicKeyPackage struct {
	state                          protoimpl.MessageState `protogen:"open.v1"`
	AdaptorPublicKey               []byte                 `protobuf:"bytes,1,opt,name=adaptor_public_key,json=adaptorPublicKey,proto3" json:"adaptor_public_key,omitempty"`
	DirectAdaptorPublicKey         []byte                 `protobuf:"bytes,2,opt,name=direct_adaptor_public_key,json=directAdaptorPublicKey,proto3" json:"direct_adaptor_public_key,omitempty"`
	DirectFromCpfpAdaptorPublicKey []byte                 `protobuf:"bytes,3,opt,name=direct_from_cpfp_adaptor_public_key,json=directFromCpfpAdaptorPublicKey,proto3" json:"direct_from_cpfp_adaptor_public_key,omitempty"`
	unknownFields                  protoimpl.UnknownFields
	sizeCache                      protoimpl.SizeCache
}

func (x *AdaptorPublicKeyPackage) Reset() {
	*x = AdaptorPublicKeyPackage{}
	mi := &file_spark_proto_msgTypes[163]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AdaptorPublicKeyPackage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AdaptorPublicKeyPackage) ProtoMessage() {}

func (x *AdaptorPublicKeyPackage) ProtoReflect() protoreflect.Message {
	mi := &file_spark_proto_msgTypes[163]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AdaptorPublicKeyPackage.ProtoReflect.Descriptor instead.
func (*AdaptorPublicKeyPackage) Descriptor() ([]byte, []int) {
	return file_spark_proto_rawDescGZIP(), []int{163}
}

func (x *AdaptorPublicKeyPackage) GetAdaptorPublicKey() []byte {
	if x != nil {
		return x.AdaptorPublicKey
	}
	return nil
}

func (x *AdaptorPublicKeyPackage) GetDirectAdaptorPublicKey() []byte {
	if x != nil {
		return x.DirectAdaptorPublicKey
	}
	return nil
}

func (x *AdaptorPublicKeyPackage) GetDirectFromCpfpAdaptorPublicKey() []byte {
	if x != nil {
		return x.DirectFromCpfpAdaptorPublicKey
	}
	return nil
}

var File_spark_proto protoreflect.FileDescriptor

const file_spark_proto_rawDesc = "" +
	"\n" +
	"\vspark.proto\x12\x05spark\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\x17validate/validate.proto\x1a\fcommon.proto\"J\n" +
	"\x18SubscribeToEventsRequest\x12.\n" +
	"\x13identity_public_key\x18\n" +
	" \x01(\fR\x11identityPublicKey\"\xc0\x01\n" +
	"\x19SubscribeToEventsResponse\x122\n" +
	"\btransfer\x18\x01 \x01(\v2\x14.spark.TransferEventH\x00R\btransfer\x12/\n" +
	"\adeposit\x18\x02 \x01(\v2\x13.spark.DepositEventH\x00R\adeposit\x125\n" +
	"\tconnected\x18\x03 \x01(\v2\x15.spark.ConnectedEventH\x00R\tconnectedB\a\n" +
	"\x05event\"\x10\n" +
	"\x0eConnectedEvent\"<\n" +
	"\rTransferEvent\x12+\n" +
	"\btransfer\x18\n" +
	" \x01(\v2\x0f.spark.TransferR\btransfer\"9\n" +
	"\fDepositEvent\x12)\n" +
	"\adeposit\x18\n" +
	" \x01(\v2\x0f.spark.TreeNodeR\adeposit\"r\n" +
	"\vPageRequest\x12\x1b\n" +
	"\tpage_size\x18\x01 \x01(\x05R\bpageSize\x12\x16\n" +
	"\x06cursor\x18\x02 \x01(\tR\x06cursor\x12.\n" +
	"\tdirection\x18\x03 \x01(\x0e2\x10.spark.DirectionR\tdirection\"\xa8\x01\n" +
	"\fPageResponse\x12\"\n" +
	"\rhas_next_page\x18\x01 \x01(\bR\vhasNextPage\x12*\n" +
	"\x11has_previous_page\x18\x02 \x01(\bR\x0fhasPreviousPage\x12\x1f\n" +
	"\vnext_cursor\x18\x03 \x01(\tR\n" +
	"nextCursor\x12'\n" +
	"\x0fprevious_cursor\x18\x04 \x01(\tR\x0epreviousCursor\"\x80\x02\n" +
	"\x13DepositAddressProof\x12`\n" +
	"\x12address_signatures\x18\x01 \x03(\v21.spark.DepositAddressProof.AddressSignaturesEntryR\x11addressSignatures\x12A\n" +
	"\x1dproof_of_possession_signature\x18\x02 \x01(\fR\x1aproofOfPossessionSignature\x1aD\n" +
	"\x16AddressSignaturesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01\"\x95\x02\n" +
	"\x1dGenerateDepositAddressRequest\x12,\n" +
	"\x12signing_public_key\x18\x01 \x01(\fR\x10signingPublicKey\x12.\n" +
	"\x13identity_public_key\x18\x02 \x01(\fR\x11identityPublicKey\x122\n" +
	"\anetwork\x18\x03 \x01(\x0e2\x0e.spark.NetworkB\b\xfaB\x05\x82\x01\x02 \x00R\anetwork\x12&\n" +
	"\aleaf_id\x18\x04 \x01(\tB\b\xfaB\x05r\x03\xb0\x01\x01H\x00R\x06leafId\x88\x01\x01\x12 \n" +
	"\tis_static\x18\x05 \x01(\bH\x01R\bisStatic\x88\x01\x01B\n" +
	"\n" +
	"\b_leaf_idB\f\n" +
	"\n" +
	"_is_static\"\xb5\x01\n" +
	"\aAddress\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x12#\n" +
	"\rverifying_key\x18\x02 \x01(\fR\fverifyingKey\x12N\n" +
	"\x15deposit_address_proof\x18\x03 \x01(\v2\x1a.spark.DepositAddressProofR\x13depositAddressProof\x12\x1b\n" +
	"\tis_static\x18\x05 \x01(\bR\bisStatic\"Y\n" +
	"\x1eGenerateDepositAddressResponse\x127\n" +
	"\x0fdeposit_address\x18\x01 \x01(\v2\x0e.spark.AddressR\x0edepositAddress\"\xc9\x01\n" +
	"#GenerateStaticDepositAddressRequest\x125\n" +
	"\x12signing_public_key\x18\x01 \x01(\fB\a\xfaB\x04z\x02h!R\x10signingPublicKey\x127\n" +
	"\x13identity_public_key\x18\x02 \x01(\fB\a\xfaB\x04z\x02h!R\x11identityPublicKey\x122\n" +
	"\anetwork\x18\x03 \x01(\x0e2\x0e.spark.NetworkB\b\xfaB\x05\x82\x01\x02 \x00R\anetwork\"_\n" +
	"$GenerateStaticDepositAddressResponse\x127\n" +
	"\x0fdeposit_address\x18\x01 \x01(\v2\x0e.spark.AddressR\x0edepositAddress\"y\n" +
	"\x04UTXO\x12\x15\n" +
	"\x06raw_tx\x18\x01 \x01(\fR\x05rawTx\x12\x12\n" +
	"\x04vout\x18\x02 \x01(\rR\x04vout\x122\n" +
	"\anetwork\x18\x03 \x01(\x0e2\x0e.spark.NetworkB\b\xfaB\x05\x82\x01\x02 \x00R\anetwork\x12\x12\n" +
	"\x04txid\x18\x04 \x01(\fR\x04txid\"9\n" +
	"\n" +
	"NodeOutput\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x12\n" +
	"\x04vout\x18\x02 \x01(\rR\x04vout\"\xa6\x01\n" +
	"\n" +
	"SigningJob\x12,\n" +
	"\x12signing_public_key\x18\x01 \x01(\fR\x10signingPublicKey\x12\x15\n" +
	"\x06raw_tx\x18\x02 \x01(\fR\x05rawTx\x12S\n" +
	"\x18signing_nonce_commitment\x18\x03 \x01(\v2\x19.common.SigningCommitmentR\x16signingNonceCommitment\"\xca\x02\n" +
	"\x0fSigningKeyshare\x12+\n" +
	"\x11owner_identifiers\x18\x01 \x03(\tR\x10ownerIdentifiers\x12\x1c\n" +
	"\tthreshold\x18\x02 \x01(\rR\tthreshold\x12\x1d\n" +
	"\n" +
	"public_key\x18\x03 \x01(\fR\tpublicKey\x12M\n" +
	"\rpublic_shares\x18\x04 \x03(\v2(.spark.SigningKeyshare.PublicSharesEntryR\fpublicShares\x12=\n" +
	"\fupdated_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\vupdatedTime\x1a?\n" +
	"\x11PublicSharesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01\"\xc8\x04\n" +
	"\rSigningResult\x12E\n" +
	"\vpublic_keys\x18\x01 \x03(\v2$.spark.SigningResult.PublicKeysEntryR\n" +
	"publicKeys\x12m\n" +
	"\x19signing_nonce_commitments\x18\x02 \x03(\v21.spark.SigningResult.SigningNonceCommitmentsEntryR\x17signingNonceCommitments\x12T\n" +
	"\x10signature_shares\x18\x03 \x03(\v2).spark.SigningResult.SignatureSharesEntryR\x0fsignatureShares\x12A\n" +
	"\x10signing_keyshare\x18\x04 \x01(\v2\x16.spark.SigningKeyshareR\x0fsigningKeyshare\x1a=\n" +
	"\x0fPublicKeysEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01\x1ae\n" +
	"\x1cSigningNonceCommitmentsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12/\n" +
	"\x05value\x18\x02 \x01(\v2\x19.common.SigningCommitmentR\x05value:\x028\x01\x1aB\n" +
	"\x14SignatureSharesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01\"\x92\x03\n" +
	"\x10RenewLeafRequest\x12\x17\n" +
	"\aleaf_id\x18\x01 \x01(\tR\x06leafId\x12j\n" +
	"\x1frenew_node_timelock_signing_job\x18\x02 \x01(\v2\".spark.RenewNodeTimelockSigningJobH\x00R\x1brenewNodeTimelockSigningJob\x12p\n" +
	"!renew_refund_timelock_signing_job\x18\x03 \x01(\v2$.spark.RenewRefundTimelockSigningJobH\x00R\x1drenewRefundTimelockSigningJob\x12w\n" +
	"$renew_node_zero_timelock_signing_job\x18\x04 \x01(\v2&.spark.RenewNodeZeroTimelockSigningJobH\x00R\x1frenewNodeZeroTimelockSigningJobB\x0e\n" +
	"\fsigning_jobs\"\xa7\x05\n" +
	"\x1bRenewNodeTimelockSigningJob\x12W\n" +
	"\x19split_node_tx_signing_job\x18\x01 \x01(\v2\x1d.spark.UserSignedTxSigningJobR\x15splitNodeTxSigningJob\x12d\n" +
	" split_node_direct_tx_signing_job\x18\x02 \x01(\v2\x1d.spark.UserSignedTxSigningJobR\x1bsplitNodeDirectTxSigningJob\x12L\n" +
	"\x13node_tx_signing_job\x18\x03 \x01(\v2\x1d.spark.UserSignedTxSigningJobR\x10nodeTxSigningJob\x12P\n" +
	"\x15refund_tx_signing_job\x18\x04 \x01(\v2\x1d.spark.UserSignedTxSigningJobR\x12refundTxSigningJob\x12Y\n" +
	"\x1adirect_node_tx_signing_job\x18\x05 \x01(\v2\x1d.spark.UserSignedTxSigningJobR\x16directNodeTxSigningJob\x12]\n" +
	"\x1cdirect_refund_tx_signing_job\x18\x06 \x01(\v2\x1d.spark.UserSignedTxSigningJobR\x18directRefundTxSigningJob\x12o\n" +
	"&direct_from_cpfp_refund_tx_signing_job\x18\a \x01(\v2\x1d.spark.UserSignedTxSigningJobR directFromCpfpRefundTxSigningJob\"\xea\x03\n" +
	"\x1dRenewRefundTimelockSigningJob\x12L\n" +
	"\x13node_tx_signing_job\x18\x01 \x01(\v2\x1d.spark.UserSignedTxSigningJobR\x10nodeTxSigningJob\x12P\n" +
	"\x15refund_tx_signing_job\x18\x02 \x01(\v2\x1d.spark.UserSignedTxSigningJobR\x12refundTxSigningJob\x12Y\n" +
	"\x1adirect_node_tx_signing_job\x18\x03 \x01(\v2\x1d.spark.UserSignedTxSigningJobR\x16directNodeTxSigningJob\x12]\n" +
	"\x1cdirect_refund_tx_signing_job\x18\x04 \x01(\v2\x1d.spark.UserSignedTxSigningJobR\x18directRefundTxSigningJob\x12o\n" +
	"&direct_from_cpfp_refund_tx_signing_job\x18\x05 \x01(\v2\x1d.spark.UserSignedTxSigningJobR directFromCpfpRefundTxSigningJob\"\x93\x03\n" +
	"\x1fRenewNodeZeroTimelockSigningJob\x12L\n" +
	"\x13node_tx_signing_job\x18\x01 \x01(\v2\x1d.spark.UserSignedTxSigningJobR\x10nodeTxSigningJob\x12P\n" +
	"\x15refund_tx_signing_job\x18\x02 \x01(\v2\x1d.spark.UserSignedTxSigningJobR\x12refundTxSigningJob\x12Y\n" +
	"\x1adirect_node_tx_signing_job\x18\x03 \x01(\v2\x1d.spark.UserSignedTxSigningJobR\x16directNodeTxSigningJob\x12o\n" +
	"&direct_from_cpfp_refund_tx_signing_job\x18\x05 \x01(\v2\x1d.spark.UserSignedTxSigningJobR directFromCpfpRefundTxSigningJobJ\x04\b\x04\x10\x05\"\xd3\x02\n" +
	"\x11RenewLeafResponse\x12]\n" +
	"\x1arenew_node_timelock_result\x18\x01 \x01(\v2\x1e.spark.RenewNodeTimelockResultH\x00R\x17renewNodeTimelockResult\x12c\n" +
	"\x1crenew_refund_timelock_result\x18\x02 \x01(\v2 .spark.RenewRefundTimelockResultH\x00R\x19renewRefundTimelockResult\x12j\n" +
	"\x1frenew_node_zero_timelock_result\x18\x03 \x01(\v2\".spark.RenewNodeZeroTimelockResultH\x00R\x1brenewNodeZeroTimelockResultB\x0e\n" +
	"\frenew_result\"n\n" +
	"\x17RenewNodeTimelockResult\x12.\n" +
	"\n" +
	"split_node\x18\x01 \x01(\v2\x0f.spark.TreeNodeR\tsplitNode\x12#\n" +
	"\x04node\x18\x02 \x01(\v2\x0f.spark.TreeNodeR\x04node\"@\n" +
	"\x19RenewRefundTimelockResult\x12#\n" +
	"\x04node\x18\x01 \x01(\v2\x0f.spark.TreeNodeR\x04node\"r\n" +
	"\x1bRenewNodeZeroTimelockResult\x12.\n" +
	"\n" +
	"split_node\x18\x01 \x01(\v2\x0f.spark.TreeNodeR\tsplitNode\x12#\n" +
	"\x04node\x18\x02 \x01(\v2\x0f.spark.TreeNodeR\x04node\"\x8f\x04\n" +
	"\x13NodeSignatureShares\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12I\n" +
	"\x16node_tx_signing_result\x18\x02 \x01(\v2\x14.spark.SigningResultR\x13nodeTxSigningResult\x12M\n" +
	"\x18refund_tx_signing_result\x18\x03 \x01(\v2\x14.spark.SigningResultR\x15refundTxSigningResult\x12#\n" +
	"\rverifying_key\x18\x04 \x01(\fR\fverifyingKey\x12V\n" +
	"\x1ddirect_node_tx_signing_result\x18\x05 \x01(\v2\x14.spark.SigningResultR\x19directNodeTxSigningResult\x12Z\n" +
	"\x1fdirect_refund_tx_signing_result\x18\x06 \x01(\v2\x14.spark.SigningResultR\x1bdirectRefundTxSigningResult\x12l\n" +
	")direct_from_cpfp_refund_tx_signing_result\x18\a \x01(\v2\x14.spark.SigningResultR#directFromCpfpRefundTxSigningResult\"\xca\x02\n" +
	"\x0eNodeSignatures\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12*\n" +
	"\x11node_tx_signature\x18\x02 \x01(\fR\x0fnodeTxSignature\x12.\n" +
	"\x13refund_tx_signature\x18\x03 \x01(\fR\x11refundTxSignature\x127\n" +
	"\x18direct_node_tx_signature\x18\x04 \x01(\fR\x15directNodeTxSignature\x12;\n" +
	"\x1adirect_refund_tx_signature\x18\x05 \x01(\fR\x17directRefundTxSignature\x12M\n" +
	"$direct_from_cpfp_refund_tx_signature\x18\x06 \x01(\fR\x1fdirectFromCpfpRefundTxSignature\"\x8a\x04\n" +
	"\x18StartTreeCreationRequest\x12.\n" +
	"\x13identity_public_key\x18\x01 \x01(\fR\x11identityPublicKey\x12/\n" +
	"\ron_chain_utxo\x18\x02 \x01(\v2\v.spark.UTXOR\vonChainUtxo\x12@\n" +
	"\x13root_tx_signing_job\x18\x03 \x01(\v2\x11.spark.SigningJobR\x10rootTxSigningJob\x12D\n" +
	"\x15refund_tx_signing_job\x18\x04 \x01(\v2\x11.spark.SigningJobR\x12refundTxSigningJob\x12M\n" +
	"\x1adirect_root_tx_signing_job\x18\x05 \x01(\v2\x11.spark.SigningJobR\x16directRootTxSigningJob\x12Q\n" +
	"\x1cdirect_refund_tx_signing_job\x18\x06 \x01(\v2\x11.spark.SigningJobR\x18directRefundTxSigningJob\x12c\n" +
	"&direct_from_cpfp_refund_tx_signing_job\x18\a \x01(\v2\x11.spark.SigningJobR directFromCpfpRefundTxSigningJob\"\x8d\x01\n" +
	"\x19StartTreeCreationResponse\x12\x17\n" +
	"\atree_id\x18\x01 \x01(\tR\x06treeId\x12W\n" +
	"\x1aroot_node_signature_shares\x18\x02 \x01(\v2\x1a.spark.NodeSignatureSharesR\x17rootNodeSignatureShares\"\x91\x04\n" +
	"\x1fStartDepositTreeCreationRequest\x12.\n" +
	"\x13identity_public_key\x18\x01 \x01(\fR\x11identityPublicKey\x12/\n" +
	"\ron_chain_utxo\x18\x02 \x01(\v2\v.spark.UTXOR\vonChainUtxo\x12@\n" +
	"\x13root_tx_signing_job\x18\x03 \x01(\v2\x11.spark.SigningJobR\x10rootTxSigningJob\x12D\n" +
	"\x15refund_tx_signing_job\x18\x04 \x01(\v2\x11.spark.SigningJobR\x12refundTxSigningJob\x12M\n" +
	"\x1adirect_root_tx_signing_job\x18\x05 \x01(\v2\x11.spark.SigningJobR\x16directRootTxSigningJob\x12Q\n" +
	"\x1cdirect_refund_tx_signing_job\x18\x06 \x01(\v2\x11.spark.SigningJobR\x18directRefundTxSigningJob\x12c\n" +
	"&direct_from_cpfp_refund_tx_signing_job\x18\a \x01(\v2\x11.spark.SigningJobR directFromCpfpRefundTxSigningJob\"\x94\x01\n" +
	" StartDepositTreeCreationResponse\x12\x17\n" +
	"\atree_id\x18\x01 \x01(\tR\x06treeId\x12W\n" +
	"\x1aroot_node_signature_shares\x18\x02 \x01(\v2\x1a.spark.NodeSignatureSharesR\x17rootNodeSignatureShares\"\x9b\x01\n" +
	"\x12TokenOutputToSpend\x12F\n" +
	"\x1bprev_token_transaction_hash\x18\x01 \x01(\fB\a\xfaB\x04z\x02h R\x18prevTokenTransactionHash\x12=\n" +
	"\x1bprev_token_transaction_vout\x18\x02 \x01(\rR\x18prevTokenTransactionVout\"Y\n" +
	"\x12TokenTransferInput\x12C\n" +
	"\x10outputs_to_spend\x18\x01 \x03(\v2\x19.spark.TokenOutputToSpendR\x0eoutputsToSpend\"\xcf\x01\n" +
	"\x0eTokenMintInput\x123\n" +
	"\x11issuer_public_key\x18\x01 \x01(\fB\a\xfaB\x04z\x02h!R\x0fissuerPublicKey\x12:\n" +
	"\x19issuer_provided_timestamp\x18\x02 \x01(\x04R\x17issuerProvidedTimestamp\x127\n" +
	"\x10token_identifier\x18\x03 \x01(\fB\a\xfaB\x04z\x02h H\x00R\x0ftokenIdentifier\x88\x01\x01B\x13\n" +
	"\x11_token_identifier\"\xf6\x02\n" +
	"\x10TokenCreateInput\x123\n" +
	"\x11issuer_public_key\x18\x01 \x01(\fB\a\xfaB\x04z\x02h!R\x0fissuerPublicKey\x12&\n" +
	"\n" +
	"token_name\x18\x02 \x01(\tB\a\xfaB\x04r\x02\x18\x14R\ttokenName\x12*\n" +
	"\ftoken_ticker\x18\x03 \x01(\tB\a\xfaB\x04r\x02\x18\x06R\vtokenTicker\x12$\n" +
	"\bdecimals\x18\x04 \x01(\rB\b\xfaB\x05*\x03\x18\xff\x01R\bdecimals\x12&\n" +
	"\n" +
	"max_supply\x18\x05 \x01(\fB\a\xfaB\x04z\x02h\x10R\tmaxSupply\x12!\n" +
	"\fis_freezable\x18\x06 \x01(\bR\visFreezable\x12I\n" +
	"\x1acreation_entity_public_key\x18\a \x01(\fB\a\xfaB\x04z\x02h!H\x00R\x17creationEntityPublicKey\x88\x01\x01B\x1d\n" +
	"\x1b_creation_entity_public_key\"\xc7\x04\n" +
	"\vTokenOutput\x12\x1d\n" +
	"\x02id\x18\x01 \x01(\tB\b\xfaB\x05r\x03\xb0\x01\x01H\x00R\x02id\x88\x01\x01\x121\n" +
	"\x10owner_public_key\x18\x02 \x01(\fB\a\xfaB\x04z\x02h!R\x0eownerPublicKey\x12A\n" +
	"\x15revocation_commitment\x18\x03 \x01(\fB\a\xfaB\x04z\x02h!H\x01R\x14revocationCommitment\x88\x01\x01\x121\n" +
	"\x12withdraw_bond_sats\x18\x04 \x01(\x04H\x02R\x10withdrawBondSats\x88\x01\x01\x12L\n" +
	" withdraw_relative_block_locktime\x18\x05 \x01(\x04H\x03R\x1dwithdrawRelativeBlockLocktime\x88\x01\x01\x126\n" +
	"\x10token_public_key\x18\x06 \x01(\fB\a\xfaB\x04z\x02h!H\x04R\x0etokenPublicKey\x88\x01\x01\x127\n" +
	"\x10token_identifier\x18\b \x01(\fB\a\xfaB\x04z\x02h H\x05R\x0ftokenIdentifier\x88\x01\x01\x12*\n" +
	"\ftoken_amount\x18\a \x01(\fB\a\xfaB\x04z\x02h\x10R\vtokenAmountB\x05\n" +
	"\x03_idB\x18\n" +
	"\x16_revocation_commitmentB\x15\n" +
	"\x13_withdraw_bond_satsB#\n" +
	"!_withdraw_relative_block_locktimeB\x13\n" +
	"\x11_token_public_keyB\x13\n" +
	"\x11_token_identifier\"\xa5\x03\n" +
	"\x10TokenTransaction\x126\n" +
	"\n" +
	"mint_input\x18\x01 \x01(\v2\x15.spark.TokenMintInputH\x00R\tmintInput\x12B\n" +
	"\x0etransfer_input\x18\x02 \x01(\v2\x19.spark.TokenTransferInputH\x00R\rtransferInput\x12<\n" +
	"\fcreate_input\x18\x05 \x01(\v2\x17.spark.TokenCreateInputH\x00R\vcreateInput\x127\n" +
	"\rtoken_outputs\x18\x03 \x03(\v2\x12.spark.TokenOutputR\ftokenOutputs\x12Z\n" +
	"#spark_operator_identity_public_keys\x18\x04 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h!R\x1fsparkOperatorIdentityPublicKeys\x122\n" +
	"\anetwork\x18\n" +
	" \x01(\x0e2\x0e.spark.NetworkB\b\xfaB\x05\x82\x01\x02 \x00R\anetworkB\x0e\n" +
	"\ftoken_inputs\"d\n" +
	"\x18SpentTokenOutputMetadata\x12\x1b\n" +
	"\toutput_id\x18\x01 \x01(\tR\boutputId\x12+\n" +
	"\x11revocation_secret\x18\x02 \x01(\fR\x10revocationSecret\"\x88\x01\n" +
	"$TokenTransactionConfirmationMetadata\x12`\n" +
	"\x1cspent_token_outputs_metadata\x18\x01 \x03(\v2\x1f.spark.SpentTokenOutputMetadataR\x19spentTokenOutputsMetadata\"\xba\x02\n" +
	"\x1aTokenTransactionWithStatus\x12D\n" +
	"\x11token_transaction\x18\x01 \x01(\v2\x17.spark.TokenTransactionR\x10tokenTransaction\x125\n" +
	"\x06status\x18\x02 \x01(\x0e2\x1d.spark.TokenTransactionStatusR\x06status\x12`\n" +
	"\x15confirmation_metadata\x18\x03 \x01(\v2+.spark.TokenTransactionConfirmationMetadataR\x14confirmationMetadata\x12=\n" +
	"\x16token_transaction_hash\x18\x04 \x01(\fB\a\xfaB\x04z\x02h R\x14tokenTransactionHash\"^\n" +
	"\x12SignatureWithIndex\x12'\n" +
	"\tsignature\x18\x01 \x01(\fB\t\xfaB\x06z\x04\x10@\x18IR\tsignature\x12\x1f\n" +
	"\vinput_index\x18\x02 \x01(\rR\n" +
	"inputIndex\"b\n" +
	"\x1aTokenTransactionSignatures\x12D\n" +
	"\x10owner_signatures\x18\x01 \x03(\v2\x19.spark.SignatureWithIndexR\x0fownerSignatures\"\xc3\x02\n" +
	"\x1cStartTokenTransactionRequest\x127\n" +
	"\x13identity_public_key\x18\x01 \x01(\fB\a\xfaB\x04z\x02h!R\x11identityPublicKey\x12S\n" +
	"\x19partial_token_transaction\x18\x02 \x01(\v2\x17.spark.TokenTransactionR\x17partialTokenTransaction\x12c\n" +
	"\x1ctoken_transaction_signatures\x18\x03 \x01(\v2!.spark.TokenTransactionSignaturesR\x1atokenTransactionSignatures\x120\n" +
	"\x14spark_payment_intent\x18\x04 \x01(\tR\x12sparkPaymentIntent\"\xad\x01\n" +
	"\x1dStartTokenTransactionResponse\x12O\n" +
	"\x17final_token_transaction\x18\x01 \x01(\v2\x17.spark.TokenTransactionR\x15finalTokenTransaction\x12;\n" +
	"\rkeyshare_info\x18\x02 \x01(\v2\x16.spark.SigningKeyshareR\fkeyshareInfo\"\xc5\x01\n" +
	"/OperatorSpecificTokenTransactionSignablePayload\x12H\n" +
	"\x1cfinal_token_transaction_hash\x18\x01 \x01(\fB\a\xfaB\x04z\x02h R\x19finalTokenTransactionHash\x12H\n" +
	"\x1coperator_identity_public_key\x18\x02 \x01(\fB\a\xfaB\x04z\x02h!R\x19operatorIdentityPublicKey\"\xb6\x01\n" +
	"\x1eOperatorSpecificOwnerSignature\x12B\n" +
	"\x0fowner_signature\x18\x01 \x01(\v2\x19.spark.SignatureWithIndexR\x0eownerSignature\x12P\n" +
	"\apayload\x18\x02 \x01(\v26.spark.OperatorSpecificTokenTransactionSignablePayloadR\apayload\"\x90\x02\n" +
	"\x1bSignTokenTransactionRequest\x12O\n" +
	"\x17final_token_transaction\x18\x01 \x01(\v2\x17.spark.TokenTransactionR\x15finalTokenTransaction\x12g\n" +
	"\x1coperator_specific_signatures\x18\x02 \x03(\v2%.spark.OperatorSpecificOwnerSignatureR\x1aoperatorSpecificSignatures\x127\n" +
	"\x13identity_public_key\x18\x03 \x01(\fB\a\xfaB\x04z\x02h!R\x11identityPublicKey\"Y\n" +
	"\x11KeyshareWithIndex\x12\x1f\n" +
	"\vinput_index\x18\x01 \x01(\rR\n" +
	"inputIndex\x12#\n" +
	"\bkeyshare\x18\x02 \x01(\fB\a\xfaB\x04z\x02h R\bkeyshare\"\xb0\x01\n" +
	"\x1cSignTokenTransactionResponse\x12C\n" +
	"\x18spark_operator_signature\x18\x01 \x01(\fB\t\xfaB\x06z\x04\x10@\x18IR\x16sparkOperatorSignature\x12K\n" +
	"\x14revocation_keyshares\x18\x02 \x03(\v2\x18.spark.KeyshareWithIndexR\x13revocationKeyshares\"r\n" +
	"\x19RevocationSecretWithIndex\x12\x1f\n" +
	"\vinput_index\x18\x01 \x01(\rR\n" +
	"inputIndex\x124\n" +
	"\x11revocation_secret\x18\x02 \x01(\fB\a\xfaB\x04z\x02h R\x10revocationSecret\"\xae\x02\n" +
	"\x1fFinalizeTokenTransactionRequest\x12O\n" +
	"\x17final_token_transaction\x18\x01 \x01(\v2\x17.spark.TokenTransactionR\x15finalTokenTransaction\x12O\n" +
	"\x12revocation_secrets\x18\x02 \x03(\v2 .spark.RevocationSecretWithIndexR\x11revocationSecrets\x127\n" +
	"\x13identity_public_key\x18\x03 \x01(\fB\a\xfaB\x04z\x02h!R\x11identityPublicKey\x120\n" +
	"\x14spark_payment_intent\x18\x04 \x01(\tR\x12sparkPaymentIntent\"\xf8\x02\n" +
	"\x13FreezeTokensPayload\x121\n" +
	"\x10owner_public_key\x18\x01 \x01(\fB\a\xfaB\x04z\x02h!R\x0eownerPublicKey\x121\n" +
	"\x10token_public_key\x18\x02 \x01(\fB\a\xfaB\x04z\x02h!R\x0etokenPublicKey\x12:\n" +
	"\x19issuer_provided_timestamp\x18\x03 \x01(\x04R\x17issuerProvidedTimestamp\x12H\n" +
	"\x1coperator_identity_public_key\x18\x04 \x01(\fB\a\xfaB\x04z\x02h!R\x19operatorIdentityPublicKey\x12'\n" +
	"\x0fshould_unfreeze\x18\x05 \x01(\bR\x0eshouldUnfreeze\x127\n" +
	"\x10token_identifier\x18\x06 \x01(\fB\a\xfaB\x04z\x02h H\x00R\x0ftokenIdentifier\x88\x01\x01B\x13\n" +
	"\x11_token_identifier\"\x9b\x01\n" +
	"\x13FreezeTokensRequest\x12N\n" +
	"\x15freeze_tokens_payload\x18\x01 \x01(\v2\x1a.spark.FreezeTokensPayloadR\x13freezeTokensPayload\x124\n" +
	"\x10issuer_signature\x18\x02 \x01(\fB\t\xfaB\x06z\x04\x10@\x18IR\x0fissuerSignature\"\x89\x01\n" +
	"\x14FreezeTokensResponse\x12=\n" +
	"\x13impacted_output_ids\x18\x01 \x03(\tB\r\xfaB\n" +
	"\x92\x01\a\"\x05r\x03\xb0\x01\x01R\x11impactedOutputIds\x122\n" +
	"\x15impacted_token_amount\x18\x02 \x01(\fR\x13impactedTokenAmount\"\xf3\x01\n" +
	"\x18QueryTokenOutputsRequest\x128\n" +
	"\x11owner_public_keys\x18\x01 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h!R\x0fownerPublicKeys\x128\n" +
	"\x11token_public_keys\x18\x02 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h!R\x0ftokenPublicKeys\x129\n" +
	"\x11token_identifiers\x18\x04 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h R\x10tokenIdentifiers\x12(\n" +
	"\anetwork\x18\x03 \x01(\x0e2\x0e.spark.NetworkR\anetwork\"\xf2\x02\n" +
	"\x1dQueryTokenTransactionsRequest\x12,\n" +
	"\n" +
	"output_ids\x18\x01 \x03(\tB\r\xfaB\n" +
	"\x92\x01\a\"\x05r\x03\xb0\x01\x01R\toutputIds\x128\n" +
	"\x11owner_public_keys\x18\x02 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h!R\x0fownerPublicKeys\x128\n" +
	"\x11token_public_keys\x18\x03 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h!R\x0ftokenPublicKeys\x129\n" +
	"\x11token_identifiers\x18\a \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h R\x10tokenIdentifiers\x12F\n" +
	"\x18token_transaction_hashes\x18\x04 \x03(\fB\f\xfaB\t\x92\x01\x06\"\x04z\x02h R\x16tokenTransactionHashes\x12\x14\n" +
	"\x05limit\x18\x05 \x01(\x03R\x05limit\x12\x16\n" +
	"\x06offset\x18\x06 \x01(\x03R\x06offset\"\xa0\x01\n" +
	"\x1eQueryTokenTransactionsResponse\x12f\n" +
	"\x1etoken_transactions_with_status\x18\x01 \x03(\v2!.spark.TokenTransactionWithStatusR\x1btokenTransactionsWithStatus\x12\x16\n" +
	"\x06offset\x18\x02 \x01(\x03R\x06offset\"\xd0\x01\n" +
	"!OutputWithPreviousTransactionData\x12*\n" +
	"\x06output\x18\x01 \x01(\v2\x12.spark.TokenOutputR\x06output\x12C\n" +
	"\x19previous_transaction_hash\x18\x02 \x01(\fB\a\xfaB\x04z\x02h R\x17previousTransactionHash\x12:\n" +
	"\x19previous_transaction_vout\x18\x03 \x01(\rR\x17previousTransactionVout\"\x99\x01\n" +
	"\x19QueryTokenOutputsResponse\x12|\n" +
	"&outputs_with_previous_transaction_data\x18\x01 \x03(\v2(.spark.OutputWithPreviousTransactionDataR\"outputsWithPreviousTransactionData\"\xfd\x05\n" +
	"\bTreeNode\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x17\n" +
	"\atree_id\x18\x02 \x01(\tR\x06treeId\x12\x14\n" +
	"\x05value\x18\x03 \x01(\x04R\x05value\x12)\n" +
	"\x0eparent_node_id\x18\x04 \x01(\tH\x00R\fparentNodeId\x88\x01\x01\x12\x17\n" +
	"\anode_tx\x18\x05 \x01(\fR\x06nodeTx\x12\x1b\n" +
	"\trefund_tx\x18\x06 \x01(\fR\brefundTx\x12\x12\n" +
	"\x04vout\x18\a \x01(\rR\x04vout\x120\n" +
	"\x14verifying_public_key\x18\b \x01(\fR\x12verifyingPublicKey\x129\n" +
	"\x19owner_identity_public_key\x18\t \x01(\fR\x16ownerIdentityPublicKey\x12A\n" +
	"\x10signing_keyshare\x18\n" +
	" \x01(\v2\x16.spark.SigningKeyshareR\x0fsigningKeyshare\x12\x16\n" +
	"\x06status\x18\v \x01(\tR\x06status\x12(\n" +
	"\anetwork\x18\f \x01(\x0e2\x0e.spark.NetworkR\anetwork\x12=\n" +
	"\fcreated_time\x18\r \x01(\v2\x1a.google.protobuf.TimestampR\vcreatedTime\x12=\n" +
	"\fupdated_time\x18\x0e \x01(\v2\x1a.google.protobuf.TimestampR\vupdatedTime\x127\n" +
	"\x18owner_signing_public_key\x18\x0f \x01(\fR\x15ownerSigningPublicKey\x12\x1b\n" +
	"\tdirect_tx\x18\x10 \x01(\fR\bdirectTx\x12(\n" +
	"\x10direct_refund_tx\x18\x11 \x01(\fR\x0edirectRefundTx\x12:\n" +
	"\x1adirect_from_cpfp_refund_tx\x18\x12 \x01(\fR\x16directFromCpfpRefundTxB\x11\n" +
	"\x0f_parent_node_id\"\x90\x01\n" +
	"\x1dFinalizeNodeSignaturesRequest\x12/\n" +
	"\x06intent\x18\x01 \x01(\x0e2\x17.common.SignatureIntentR\x06intent\x12>\n" +
	"\x0fnode_signatures\x18\x02 \x03(\v2\x15.spark.NodeSignaturesR\x0enodeSignatures\"G\n" +
	"\x1eFinalizeNodeSignaturesResponse\x12%\n" +
	"\x05nodes\x18\x01 \x03(\v2\x0f.spark.TreeNodeR\x05nodes\"H\n" +
	"\vSecretShare\x12!\n" +
	"\fsecret_share\x18\x01 \x01(\fR\vsecretShare\x12\x16\n" +
	"\x06proofs\x18\x02 \x03(\fR\x06proofs\"%\n" +
	"\vSecretProof\x12\x16\n" +
	"\x06proofs\x18\x01 \x03(\fR\x06proofs\"\xaf\x02\n" +
	"\x16LeafRefundTxSigningJob\x12\x17\n" +
	"\aleaf_id\x18\x01 \x01(\tR\x06leafId\x12D\n" +
	"\x15refund_tx_signing_job\x18\x02 \x01(\v2\x11.spark.SigningJobR\x12refundTxSigningJob\x12Q\n" +
	"\x1cdirect_refund_tx_signing_job\x18\x03 \x01(\v2\x11.spark.SigningJobR\x18directRefundTxSigningJob\x12c\n" +
	"&direct_from_cpfp_refund_tx_signing_job\x18\x04 \x01(\v2\x11.spark.SigningJobR directFromCpfpRefundTxSigningJob\"\xbe\x02\n" +
	"\x16UserSignedTxSigningJob\x12\x17\n" +
	"\aleaf_id\x18\x01 \x01(\tR\x06leafId\x12,\n" +
	"\x12signing_public_key\x18\x02 \x01(\fR\x10signingPublicKey\x12\x15\n" +
	"\x06raw_tx\x18\x03 \x01(\fR\x05rawTx\x12S\n" +
	"\x18signing_nonce_commitment\x18\x04 \x01(\v2\x19.common.SigningCommitmentR\x16signingNonceCommitment\x12%\n" +
	"\x0euser_signature\x18\x05 \x01(\fR\ruserSignature\x12J\n" +
	"\x13signing_commitments\x18\x06 \x01(\v2\x19.spark.SigningCommitmentsR\x12signingCommitments\"\xf2\x02\n" +
	"\x19LeafRefundTxSigningResult\x12\x17\n" +
	"\aleaf_id\x18\x01 \x01(\tR\x06leafId\x12M\n" +
	"\x18refund_tx_signing_result\x18\x02 \x01(\v2\x14.spark.SigningResultR\x15refundTxSigningResult\x12#\n" +
	"\rverifying_key\x18\x03 \x01(\fR\fverifyingKey\x12Z\n" +
	"\x1fdirect_refund_tx_signing_result\x18\x04 \x01(\v2\x14.spark.SigningResultR\x1bdirectRefundTxSigningResult\x12l\n" +
	")direct_from_cpfp_refund_tx_signing_result\x18\x05 \x01(\v2\x14.spark.SigningResultR#directFromCpfpRefundTxSigningResult\"\xf5\x03\n" +
	"\x1eStartUserSignedTransferRequest\x12\x1f\n" +
	"\vtransfer_id\x18\x01 \x01(\tR\n" +
	"transferId\x129\n" +
	"\x19owner_identity_public_key\x18\x02 \x01(\fR\x16ownerIdentityPublicKey\x12C\n" +
	"\x0eleaves_to_send\x18\x03 \x03(\v2\x1d.spark.UserSignedTxSigningJobR\fleavesToSend\x12?\n" +
	"\x1creceiver_identity_public_key\x18\x04 \x01(\fR\x19receiverIdentityPublicKey\x12;\n" +
	"\vexpiry_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"expiryTime\x12P\n" +
	"\x15direct_leaves_to_send\x18\x06 \x03(\v2\x1d.spark.UserSignedTxSigningJobR\x12directLeavesToSend\x12b\n" +
	"\x1fdirect_from_cpfp_leaves_to_send\x18\a \x03(\v2\x1d.spark.UserSignedTxSigningJobR\x1adirectFromCpfpLeavesToSend\"\xa9\x03\n" +
	"\x14StartTransferRequest\x12\x1f\n" +
	"\vtransfer_id\x18\x01 \x01(\tR\n" +
	"transferId\x129\n" +
	"\x19owner_identity_public_key\x18\x02 \x01(\fR\x16ownerIdentityPublicKey\x12C\n" +
	"\x0eleaves_to_send\x18\x03 \x03(\v2\x1d.spark.LeafRefundTxSigningJobR\fleavesToSend\x12?\n" +
	"\x1creceiver_identity_public_key\x18\x04 \x01(\fR\x19receiverIdentityPublicKey\x12;\n" +
	"\vexpiry_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"expiryTime\x12A\n" +
	"\x10transfer_package\x18\a \x01(\v2\x16.spark.TransferPackageR\x0ftransferPackage\x12#\n" +
	"\rspark_invoice\x18\n" +
	" \x01(\tR\fsparkInvoiceJ\x04\b\x06\x10\aJ\x04\b\t\x10\n" +
	"\"\x8f\x01\n" +
	"\x15StartTransferResponse\x12+\n" +
	"\btransfer\x18\x01 \x01(\v2\x0f.spark.TransferR\btransfer\x12I\n" +
	"\x0fsigning_results\x18\x02 \x03(\v2 .spark.LeafRefundTxSigningResultR\x0esigningResults\"\xd0\x03\n" +
	"\x0fTransferPackage\x12C\n" +
	"\x0eleaves_to_send\x18\x01 \x03(\v2\x1d.spark.UserSignedTxSigningJobR\fleavesToSend\x12W\n" +
	"\x11key_tweak_package\x18\x02 \x03(\v2+.spark.TransferPackage.KeyTweakPackageEntryR\x0fkeyTweakPackage\x12%\n" +
	"\x0euser_signature\x18\x03 \x01(\fR\ruserSignature\x12P\n" +
	"\x15direct_leaves_to_send\x18\x04 \x03(\v2\x1d.spark.UserSignedTxSigningJobR\x12directLeavesToSend\x12b\n" +
	"\x1fdirect_from_cpfp_leaves_to_send\x18\x05 \x03(\v2\x1d.spark.UserSignedTxSigningJobR\x1adirectFromCpfpLeavesToSend\x1aB\n" +
	"\x14KeyTweakPackageEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01\"R\n" +
	"\x11SendLeafKeyTweaks\x12=\n" +
	"\x0eleaves_to_send\x18\x01 \x03(\v2\x17.spark.SendLeafKeyTweakR\fleavesToSend\"\x83\x04\n" +
	"\x10SendLeafKeyTweak\x12\x17\n" +
	"\aleaf_id\x18\x01 \x01(\tR\x06leafId\x12@\n" +
	"\x12secret_share_tweak\x18\x02 \x01(\v2\x12.spark.SecretShareR\x10secretShareTweak\x12^\n" +
	"\x13pubkey_shares_tweak\x18\x03 \x03(\v2..spark.SendLeafKeyTweak.PubkeySharesTweakEntryR\x11pubkeySharesTweak\x12#\n" +
	"\rsecret_cipher\x18\x04 \x01(\fR\fsecretCipher\x12\x1c\n" +
	"\tsignature\x18\x05 \x01(\fR\tsignature\x12)\n" +
	"\x10refund_signature\x18\x06 \x01(\fR\x0frefundSignature\x126\n" +
	"\x17direct_refund_signature\x18\a \x01(\fR\x15directRefundSignature\x12H\n" +
	"!direct_from_cpfp_refund_signature\x18\b \x01(\fR\x1ddirectFromCpfpRefundSignature\x1aD\n" +
	"\x16PubkeySharesTweakEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01\"\xe6\x01\n" +
	"\x17FinalizeTransferRequest\x12\x1f\n" +
	"\vtransfer_id\x18\x01 \x01(\tR\n" +
	"transferId\x129\n" +
	"\x19owner_identity_public_key\x18\x02 \x01(\fR\x16ownerIdentityPublicKey\x12=\n" +
	"\x0eleaves_to_send\x18\x03 \x03(\v2\x17.spark.SendLeafKeyTweakR\fleavesToSend\x120\n" +
	"\x14spark_payment_intent\x18\x04 \x01(\tR\x12sparkPaymentIntent\"\xcb\x01\n" +
	"*FinalizeTransferWithTransferPackageRequest\x12\x1f\n" +
	"\vtransfer_id\x18\x01 \x01(\tR\n" +
	"transferId\x129\n" +
	"\x19owner_identity_public_key\x18\x02 \x01(\fR\x16ownerIdentityPublicKey\x12A\n" +
	"\x10transfer_package\x18\x03 \x01(\v2\x16.spark.TransferPackageR\x0ftransferPackage\"G\n" +
	"\x18FinalizeTransferResponse\x12+\n" +
	"\btransfer\x18\x01 \x01(\v2\x0f.spark.TransferR\btransfer\"\x9e\x04\n" +
	"\bTransfer\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12;\n" +
	"\x1asender_identity_public_key\x18\x02 \x01(\fR\x17senderIdentityPublicKey\x12?\n" +
	"\x1creceiver_identity_public_key\x18\x03 \x01(\fR\x19receiverIdentityPublicKey\x12-\n" +
	"\x06status\x18\x04 \x01(\x0e2\x15.spark.TransferStatusR\x06status\x12\x1f\n" +
	"\vtotal_value\x18\x05 \x01(\x04R\n" +
	"totalValue\x12;\n" +
	"\vexpiry_time\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"expiryTime\x12+\n" +
	"\x06leaves\x18\a \x03(\v2\x13.spark.TransferLeafR\x06leaves\x12=\n" +
	"\fcreated_time\x18\b \x01(\v2\x1a.google.protobuf.TimestampR\vcreatedTime\x12=\n" +
	"\fupdated_time\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\vupdatedTime\x12'\n" +
	"\x04type\x18\n" +
	" \x01(\x0e2\x13.spark.TransferTypeR\x04type\x12#\n" +
	"\rspark_invoice\x18\v \x01(\tR\fsparkInvoice\"\x84\x03\n" +
	"\fTransferLeaf\x12#\n" +
	"\x04leaf\x18\x01 \x01(\v2\x0f.spark.TreeNodeR\x04leaf\x12#\n" +
	"\rsecret_cipher\x18\x02 \x01(\fR\fsecretCipher\x12\x1c\n" +
	"\tsignature\x18\x03 \x01(\fR\tsignature\x124\n" +
	"\x16intermediate_refund_tx\x18\x04 \x01(\fR\x14intermediateRefundTx\x12A\n" +
	"\x1dintermediate_direct_refund_tx\x18\x05 \x01(\fR\x1aintermediateDirectRefundTx\x12S\n" +
	"'intermediate_direct_from_cpfp_refund_tx\x18\x06 \x01(\fR\"intermediateDirectFromCpfpRefundTx\x12>\n" +
	"\x1cpending_key_tweak_public_key\x18\a \x01(\fR\x18pendingKeyTweakPublicKey\"\xf3\x03\n" +
	"\x0eTransferFilter\x12A\n" +
	"\x1creceiver_identity_public_key\x18\x01 \x01(\fH\x00R\x19receiverIdentityPublicKey\x12=\n" +
	"\x1asender_identity_public_key\x18\x02 \x01(\fH\x00R\x17senderIdentityPublicKey\x12S\n" +
	"&sender_or_receiver_identity_public_key\x18< \x01(\fH\x00R!senderOrReceiverIdentityPublicKey\x12!\n" +
	"\ftransfer_ids\x18\x03 \x03(\tR\vtransferIds\x12\x14\n" +
	"\x05limit\x18( \x01(\x03R\x05limit\x12\x16\n" +
	"\x06offset\x182 \x01(\x03R\x06offset\x12)\n" +
	"\x05types\x18F \x03(\x0e2\x13.spark.TransferTypeR\x05types\x12(\n" +
	"\anetwork\x18\x04 \x01(\x0e2\x0e.spark.NetworkR\anetwork\x121\n" +
	"\bstatuses\x18P \x03(\x0e2\x15.spark.TransferStatusR\bstatuses\x12\"\n" +
	"\x05order\x18\x05 \x01(\x0e2\f.spark.OrderR\x05orderB\r\n" +
	"\vparticipant\"_\n" +
	"\x16QueryTransfersResponse\x12-\n" +
	"\ttransfers\x18\x01 \x03(\v2\x0f.spark.TransferR\ttransfers\x12\x16\n" +
	"\x06offset\x18\x02 \x01(\x03R\x06offset\"\x95\x02\n" +
	"\x11ClaimLeafKeyTweak\x12\x17\n" +
	"\aleaf_id\x18\x01 \x01(\tR\x06leafId\x12@\n" +
	"\x12secret_share_tweak\x18\x02 \x01(\v2\x12.spark.SecretShareR\x10secretShareTweak\x12_\n" +
	"\x13pubkey_shares_tweak\x18\x03 \x03(\v2/.spark.ClaimLeafKeyTweak.PubkeySharesTweakEntryR\x11pubkeySharesTweak\x1aD\n" +
	"\x16PubkeySharesTweakEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value:\x028\x01\"\xc1\x01\n" +
	"\x1dClaimTransferTweakKeysRequest\x12\x1f\n" +
	"\vtransfer_id\x18\x01 \x01(\tR\n" +
	"transferId\x129\n" +
	"\x19owner_identity_public_key\x18\x02 \x01(\fR\x16ownerIdentityPublicKey\x12D\n" +
	"\x11leaves_to_receive\x18\x03 \x03(\v2\x18.spark.ClaimLeafKeyTweakR\x0fleavesToReceive\"\xc5\x01\n" +
	"\x1fClaimTransferSignRefundsRequest\x12\x1f\n" +
	"\vtransfer_id\x18\x01 \x01(\tR\n" +
	"transferId\x129\n" +
	"\x19owner_identity_public_key\x18\x02 \x01(\fR\x16ownerIdentityPublicKey\x12@\n" +
	"\fsigning_jobs\x18\x03 \x03(\v2\x1d.spark.LeafRefundTxSigningJobR\vsigningJobsJ\x04\b\x04\x10\x05\"m\n" +
	" ClaimTransferSignRefundsResponse\x12I\n" +
	"\x0fsigning_results\x18\x01 \x03(\v2 .spark.LeafRefundTxSigningResultR\x0esigningResults\"\xf7\x01\n" +
	"\x19StorePreimageShareRequest\x12!\n" +
	"\fpayment_hash\x18\x01 \x01(\fR\vpaymentHash\x129\n" +
	"\x0epreimage_share\x18\x02 \x01(\v2\x12.spark.SecretShareR\rpreimageShare\x12\x1c\n" +
	"\tthreshold\x18\x03 \x01(\rR\tthreshold\x12%\n" +
	"\x0einvoice_string\x18\x04 \x01(\tR\rinvoiceString\x127\n" +
	"\x18user_identity_public_key\x18\x05 \x01(\fR\x15userIdentityPublicKey\"\x81\x02\n" +
	"\x1bRequestedSigningCommitments\x12{\n" +
	"\x19signing_nonce_commitments\x18\x01 \x03(\v2?.spark.RequestedSigningCommitments.SigningNonceCommitmentsEntryR\x17signingNonceCommitments\x1ae\n" +
	"\x1cSigningNonceCommitmentsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12/\n" +
	"\x05value\x18\x02 \x01(\v2\x19.common.SigningCommitmentR\x05value:\x028\x01\"O\n" +
	"\x1cGetSigningCommitmentsRequest\x12\x19\n" +
	"\bnode_ids\x18\x01 \x03(\tR\anodeIds\x12\x14\n" +
	"\x05count\x18\x02 \x01(\rR\x05count\"t\n" +
	"\x1dGetSigningCommitmentsResponse\x12S\n" +
	"\x13signing_commitments\x18\x01 \x03(\v2\".spark.RequestedSigningCommitmentsR\x12signingCommitments\"\xda\x01\n" +
	"\x12SigningCommitments\x12b\n" +
	"\x13signing_commitments\x18\x01 \x03(\v21.spark.SigningCommitments.SigningCommitmentsEntryR\x12signingCommitments\x1a`\n" +
	"\x17SigningCommitmentsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12/\n" +
	"\x05value\x18\x02 \x01(\v2\x19.common.SigningCommitmentR\x05value:\x028\x01\"\xc6\x02\n" +
	"\x10UserSignedRefund\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x1b\n" +
	"\trefund_tx\x18\x02 \x01(\fR\brefundTx\x12%\n" +
	"\x0euser_signature\x18\x03 \x01(\fR\ruserSignature\x12J\n" +
	"\x13signing_commitments\x18\x04 \x01(\v2\x19.spark.SigningCommitmentsR\x12signingCommitments\x12U\n" +
	"\x19user_signature_commitment\x18\x05 \x01(\v2\x19.common.SigningCommitmentR\x17userSignatureCommitment\x122\n" +
	"\anetwork\x18\x06 \x01(\x0e2\x0e.spark.NetworkB\b\xfaB\x05\x82\x01\x02 \x00R\anetwork\";\n" +
	"\x12InvoiceAmountProof\x12%\n" +
	"\x0ebolt11_invoice\x18\x01 \x01(\tR\rbolt11Invoice\"{\n" +
	"\rInvoiceAmount\x12\x1d\n" +
	"\n" +
	"value_sats\x18\x01 \x01(\x04R\tvalueSats\x12K\n" +
	"\x14invoice_amount_proof\x18\x02 \x01(\v2\x19.spark.InvoiceAmountProofR\x12invoiceAmountProof\"\xd6\x03\n" +
	"\x1bInitiatePreimageSwapRequest\x12!\n" +
	"\fpayment_hash\x18\x01 \x01(\fR\vpaymentHash\x12;\n" +
	"\x0einvoice_amount\x18\x02 \x01(\v2\x14.spark.InvoiceAmountR\rinvoiceAmount\x12A\n" +
	"\x06reason\x18\x03 \x01(\x0e2).spark.InitiatePreimageSwapRequest.ReasonR\x06reason\x12A\n" +
	"\btransfer\x18\x04 \x01(\v2%.spark.StartUserSignedTransferRequestR\btransfer\x12?\n" +
	"\x1creceiver_identity_public_key\x18\x05 \x01(\fR\x19receiverIdentityPublicKey\x12\x19\n" +
	"\bfee_sats\x18\x06 \x01(\x04R\afeeSats\x12F\n" +
	"\x10transfer_request\x18\a \x01(\v2\x1b.spark.StartTransferRequestR\x0ftransferRequest\"-\n" +
	"\x06Reason\x12\x0f\n" +
	"\vREASON_SEND\x10\x00\x12\x12\n" +
	"\x0eREASON_RECEIVE\x10\x01\"g\n" +
	"\x1cInitiatePreimageSwapResponse\x12\x1a\n" +
	"\bpreimage\x18\x01 \x01(\fR\bpreimage\x12+\n" +
	"\btransfer\x18\x02 \x01(\v2\x0f.spark.TransferR\btransfer\"2\n" +
	"\bOutPoint\x12\x12\n" +
	"\x04txid\x18\x01 \x01(\fR\x04txid\x12\x12\n" +
	"\x04vout\x18\x02 \x01(\rR\x04vout\"\x87\x01\n" +
	"\x16CooperativeExitRequest\x127\n" +
	"\btransfer\x18\x01 \x01(\v2\x1b.spark.StartTransferRequestR\btransfer\x12\x17\n" +
	"\aexit_id\x18\x02 \x01(\tR\x06exitId\x12\x1b\n" +
	"\texit_txid\x18\x03 \x01(\fR\bexitTxid\"\x91\x01\n" +
	"\x17CooperativeExitResponse\x12+\n" +
	"\btransfer\x18\x01 \x01(\v2\x0f.spark.TransferR\btransfer\x12I\n" +
	"\x0fsigning_results\x18\x02 \x03(\v2 .spark.LeafRefundTxSigningResultR\x0esigningResults\"\xa0\x02\n" +
	"\x16CounterLeafSwapRequest\x127\n" +
	"\btransfer\x18\x01 \x01(\v2\x1b.spark.StartTransferRequestR\btransfer\x12\x17\n" +
	"\aswap_id\x18\x02 \x01(\tR\x06swapId\x12,\n" +
	"\x12adaptor_public_key\x18\x03 \x01(\fR\x10adaptorPublicKey\x129\n" +
	"\x19direct_adaptor_public_key\x18\x04 \x01(\fR\x16directAdaptorPublicKey\x12K\n" +
	"#direct_from_cpfp_adaptor_public_key\x18\x05 \x01(\fR\x1edirectFromCpfpAdaptorPublicKey\"\x91\x01\n" +
	"\x17CounterLeafSwapResponse\x12+\n" +
	"\btransfer\x18\x01 \x01(\v2\x0f.spark.TransferR\btransfer\x12I\n" +
	"\x0fsigning_results\x18\x02 \x03(\v2 .spark.LeafRefundTxSigningResultR\x0esigningResults\"\xa2\x01\n" +
	"\x16RefreshTimelockRequest\x12\x17\n" +
	"\aleaf_id\x18\x01 \x01(\tR\x06leafId\x129\n" +
	"\x19owner_identity_public_key\x18\x02 \x01(\fR\x16ownerIdentityPublicKey\x124\n" +
	"\fsigning_jobs\x18\x03 \x03(\v2\x11.spark.SigningJobR\vsigningJobs\"\x80\x01\n" +
	"\x1cRefreshTimelockSigningResult\x12;\n" +
	"\x0esigning_result\x18\x01 \x01(\v2\x14.spark.SigningResultR\rsigningResult\x12#\n" +
	"\rverifying_key\x18\x02 \x01(\fR\fverifyingKey\"g\n" +
	"\x17RefreshTimelockResponse\x12L\n" +
	"\x0fsigning_results\x18\x01 \x03(\v2#.spark.RefreshTimelockSigningResultR\x0esigningResults\"\xf6\x03\n" +
	"\x11ExtendLeafRequest\x12\x17\n" +
	"\aleaf_id\x18\x01 \x01(\tR\x06leafId\x129\n" +
	"\x19owner_identity_public_key\x18\x02 \x01(\fR\x16ownerIdentityPublicKey\x12@\n" +
	"\x13node_tx_signing_job\x18\x03 \x01(\v2\x11.spark.SigningJobR\x10nodeTxSigningJob\x12D\n" +
	"\x15refund_tx_signing_job\x18\x04 \x01(\v2\x11.spark.SigningJobR\x12refundTxSigningJob\x12M\n" +
	"\x1adirect_node_tx_signing_job\x18\x05 \x01(\v2\x11.spark.SigningJobR\x16directNodeTxSigningJob\x12Q\n" +
	"\x1cdirect_refund_tx_signing_job\x18\x06 \x01(\v2\x11.spark.SigningJobR\x18directRefundTxSigningJob\x12c\n" +
	"&direct_from_cpfp_refund_tx_signing_job\x18\a \x01(\v2\x11.spark.SigningJobR directFromCpfpRefundTxSigningJob\"{\n" +
	"\x17ExtendLeafSigningResult\x12;\n" +
	"\x0esigning_result\x18\x01 \x01(\v2\x14.spark.SigningResultR\rsigningResult\x12#\n" +
	"\rverifying_key\x18\x02 \x01(\fR\fverifyingKey\"\x9b\x04\n" +
	"\x12ExtendLeafResponse\x12\x17\n" +
	"\aleaf_id\x18\x01 \x01(\tR\x06leafId\x12S\n" +
	"\x16node_tx_signing_result\x18\x02 \x01(\v2\x1e.spark.ExtendLeafSigningResultR\x13nodeTxSigningResult\x12W\n" +
	"\x18refund_tx_signing_result\x18\x03 \x01(\v2\x1e.spark.ExtendLeafSigningResultR\x15refundTxSigningResult\x12`\n" +
	"\x1ddirect_node_tx_signing_result\x18\x04 \x01(\v2\x1e.spark.ExtendLeafSigningResultR\x19directNodeTxSigningResult\x12d\n" +
	"\x1fdirect_refund_tx_signing_result\x18\x05 \x01(\v2\x1e.spark.ExtendLeafSigningResultR\x1bdirectRefundTxSigningResult\x12v\n" +
	")direct_from_cpfp_refund_tx_signing_result\x18\x06 \x01(\v2\x1e.spark.ExtendLeafSigningResultR#directFromCpfpRefundTxSigningResult\"s\n" +
	"\x12AddressRequestNode\x12&\n" +
	"\x0fuser_public_key\x18\x01 \x01(\fR\ruserPublicKey\x125\n" +
	"\bchildren\x18\x02 \x03(\v2\x19.spark.AddressRequestNodeR\bchildren\"\x83\x02\n" +
	"\x19PrepareTreeAddressRequest\x12A\n" +
	"\x12parent_node_output\x18\x01 \x01(\v2\x11.spark.NodeOutputH\x00R\x10parentNodeOutput\x121\n" +
	"\ron_chain_utxo\x18\x02 \x01(\v2\v.spark.UTXOH\x00R\vonChainUtxo\x12-\n" +
	"\x04node\x18\x03 \x01(\v2\x19.spark.AddressRequestNodeR\x04node\x127\n" +
	"\x18user_identity_public_key\x18\x04 \x01(\fR\x15userIdentityPublicKeyB\b\n" +
	"\x06source\"g\n" +
	"\vAddressNode\x12(\n" +
	"\aaddress\x18\x01 \x01(\v2\x0e.spark.AddressR\aaddress\x12.\n" +
	"\bchildren\x18\x02 \x03(\v2\x12.spark.AddressNodeR\bchildren\"D\n" +
	"\x1aPrepareTreeAddressResponse\x12&\n" +
	"\x04node\x18\x01 \x01(\v2\x12.spark.AddressNodeR\x04node\"\xce\x03\n" +
	"\fCreationNode\x12@\n" +
	"\x13node_tx_signing_job\x18\x01 \x01(\v2\x11.spark.SigningJobR\x10nodeTxSigningJob\x12D\n" +
	"\x15refund_tx_signing_job\x18\x02 \x01(\v2\x11.spark.SigningJobR\x12refundTxSigningJob\x12/\n" +
	"\bchildren\x18\x03 \x03(\v2\x13.spark.CreationNodeR\bchildren\x12M\n" +
	"\x1adirect_node_tx_signing_job\x18\x04 \x01(\v2\x11.spark.SigningJobR\x16directNodeTxSigningJob\x12Q\n" +
	"\x1cdirect_refund_tx_signing_job\x18\x05 \x01(\v2\x11.spark.SigningJobR\x18directRefundTxSigningJob\x12c\n" +
	"&direct_from_cpfp_refund_tx_signing_job\x18\x06 \x01(\v2\x11.spark.SigningJobR directFromCpfpRefundTxSigningJob\"\xf5\x01\n" +
	"\x11CreateTreeRequest\x12A\n" +
	"\x12parent_node_output\x18\x01 \x01(\v2\x11.spark.NodeOutputH\x00R\x10parentNodeOutput\x121\n" +
	"\ron_chain_utxo\x18\x02 \x01(\v2\v.spark.UTXOH\x00R\vonChainUtxo\x12'\n" +
	"\x04node\x18\x03 \x01(\v2\x13.spark.CreationNodeR\x04node\x127\n" +
	"\x18user_identity_public_key\x18\x04 \x01(\fR\x15userIdentityPublicKeyB\b\n" +
	"\x06source\"\xa4\x04\n" +
	"\x14CreationResponseNode\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12I\n" +
	"\x16node_tx_signing_result\x18\x02 \x01(\v2\x14.spark.SigningResultR\x13nodeTxSigningResult\x12M\n" +
	"\x18refund_tx_signing_result\x18\x03 \x01(\v2\x14.spark.SigningResultR\x15refundTxSigningResult\x127\n" +
	"\bchildren\x18\x04 \x03(\v2\x1b.spark.CreationResponseNodeR\bchildren\x12V\n" +
	"\x1ddirect_node_tx_signing_result\x18\x05 \x01(\v2\x14.spark.SigningResultR\x19directNodeTxSigningResult\x12Z\n" +
	"\x1fdirect_refund_tx_signing_result\x18\x06 \x01(\v2\x14.spark.SigningResultR\x1bdirectRefundTxSigningResult\x12l\n" +
	")direct_from_cpfp_refund_tx_signing_result\x18\a \x01(\v2\x14.spark.SigningResultR#directFromCpfpRefundTxSigningResult\"E\n" +
	"\x12CreateTreeResponse\x12/\n" +
	"\x04node\x18\x01 \x01(\v2\x1b.spark.CreationResponseNodeR\x04node\"\x84\x01\n" +
	"\x13SigningOperatorInfo\x12\x14\n" +
	"\x05index\x18\x01 \x01(\x04R\x05index\x12\x1e\n" +
	"\n" +
	"identifier\x18\x02 \x01(\tR\n" +
	"identifier\x12\x1d\n" +
	"\n" +
	"public_key\x18\x03 \x01(\fR\tpublicKey\x12\x18\n" +
	"\aaddress\x18\x04 \x01(\tR\aaddress\"\xeb\x01\n" +
	"\x1eGetSigningOperatorListResponse\x12h\n" +
	"\x11signing_operators\x18\x01 \x03(\v2;.spark.GetSigningOperatorListResponse.SigningOperatorsEntryR\x10signingOperators\x1a_\n" +
	"\x15SigningOperatorsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x120\n" +
	"\x05value\x18\x02 \x01(\v2\x1a.spark.SigningOperatorInfoR\x05value:\x028\x01\"r\n" +
	"\x1dQueryUserSignedRefundsRequest\x12!\n" +
	"\fpayment_hash\x18\x01 \x01(\fR\vpaymentHash\x12.\n" +
	"\x13identity_public_key\x18\x02 \x01(\fR\x11identityPublicKey\"\x9c\x01\n" +
	"\x1eQueryUserSignedRefundsResponse\x12G\n" +
	"\x13user_signed_refunds\x18\x01 \x03(\v2\x17.spark.UserSignedRefundR\x11userSignedRefunds\x12+\n" +
	"\btransfer\x18\x03 \x01(\v2\x0f.spark.TransferR\btransferJ\x04\b\x02\x10\x03\"\xee\x02\n" +
	"\x1bPreimageRequestWithTransfer\x12*\n" +
	"\fpayment_hash\x18\x01 \x01(\fB\a\xfaB\x04z\x02h R\vpaymentHash\x12A\n" +
	"\x18receiver_identity_pubkey\x18\x02 \x01(\fB\a\xfaB\x04z\x02h!R\x16receiverIdentityPubkey\x124\n" +
	"\x06status\x18\x03 \x01(\x0e2\x1c.spark.PreimageRequestStatusR\x06status\x12=\n" +
	"\fcreated_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\vcreatedTime\x120\n" +
	"\btransfer\x18\x05 \x01(\v2\x0f.spark.TransferH\x00R\btransfer\x88\x01\x01\x12\x1f\n" +
	"\bpreimage\x18\x06 \x01(\fH\x01R\bpreimage\x88\x01\x01B\v\n" +
	"\t_transferB\v\n" +
	"\t_preimage\"\xdd\x01\n" +
	"\x10QueryHtlcRequest\x12%\n" +
	"\x0epayment_hashes\x18\x01 \x03(\fR\rpaymentHashes\x12.\n" +
	"\x13identity_public_key\x18\x02 \x01(\fR\x11identityPublicKey\x129\n" +
	"\x06status\x18\x03 \x01(\x0e2\x1c.spark.PreimageRequestStatusH\x00R\x06status\x88\x01\x01\x12\x14\n" +
	"\x05limit\x18\x04 \x01(\x03R\x05limit\x12\x16\n" +
	"\x06offset\x18\x05 \x01(\x03R\x06offsetB\t\n" +
	"\a_status\"|\n" +
	"\x11QueryHtlcResponse\x12O\n" +
	"\x11preimage_requests\x18\x01 \x03(\v2\".spark.PreimageRequestWithTransferR\x10preimageRequests\x12\x16\n" +
	"\x06offset\x18\x02 \x01(\x03R\x06offset\"\x87\x01\n" +
	"\x16ProvidePreimageRequest\x12!\n" +
	"\fpayment_hash\x18\x01 \x01(\fR\vpaymentHash\x12\x1a\n" +
	"\bpreimage\x18\x02 \x01(\fR\bpreimage\x12.\n" +
	"\x13identity_public_key\x18\x03 \x01(\fR\x11identityPublicKey\"F\n" +
	"\x17ProvidePreimageResponse\x12+\n" +
	"\btransfer\x18\x01 \x01(\v2\x0f.spark.TransferR\btransfer\"{\n" +
	"\x1dReturnLightningPaymentRequest\x12!\n" +
	"\fpayment_hash\x18\x01 \x01(\fR\vpaymentHash\x127\n" +
	"\x18user_identity_public_key\x18\x02 \x01(\fR\x15userIdentityPublicKey\"(\n" +
	"\vTreeNodeIds\x12\x19\n" +
	"\bnode_ids\x18\x01 \x03(\tR\anodeIds\"\x85\x02\n" +
	"\x11QueryNodesRequest\x124\n" +
	"\x15owner_identity_pubkey\x18\x01 \x01(\fH\x00R\x13ownerIdentityPubkey\x12/\n" +
	"\bnode_ids\x18\x02 \x01(\v2\x12.spark.TreeNodeIdsH\x00R\anodeIds\x12'\n" +
	"\x0finclude_parents\x18\x03 \x01(\bR\x0eincludeParents\x12\x14\n" +
	"\x05limit\x18\x04 \x01(\x03R\x05limit\x12\x16\n" +
	"\x06offset\x18\x05 \x01(\x03R\x06offset\x12(\n" +
	"\anetwork\x18\x06 \x01(\x0e2\x0e.spark.NetworkR\anetworkB\b\n" +
	"\x06source\"\xb3\x01\n" +
	"\x12QueryNodesResponse\x12:\n" +
	"\x05nodes\x18\x01 \x03(\v2$.spark.QueryNodesResponse.NodesEntryR\x05nodes\x12\x16\n" +
	"\x06offset\x18\x02 \x01(\x03R\x06offset\x1aI\n" +
	"\n" +
	"NodesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12%\n" +
	"\x05value\x18\x02 \x01(\v2\x0f.spark.TreeNodeR\x05value:\x028\x01\"u\n" +
	"\x15CancelTransferRequest\x12\x1f\n" +
	"\vtransfer_id\x18\x01 \x01(\tR\n" +
	"transferId\x12;\n" +
	"\x1asender_identity_public_key\x18\x02 \x01(\fR\x17senderIdentityPublicKey\"E\n" +
	"\x16CancelTransferResponse\x12+\n" +
	"\btransfer\x18\x01 \x01(\v2\x0f.spark.TransferR\btransfer\"\xac\x01\n" +
	"\"QueryUnusedDepositAddressesRequest\x12.\n" +
	"\x13identity_public_key\x18\x01 \x01(\fR\x11identityPublicKey\x12(\n" +
	"\anetwork\x18\x02 \x01(\x0e2\x0e.spark.NetworkR\anetwork\x12\x14\n" +
	"\x05limit\x18\x03 \x01(\x03R\x05limit\x12\x16\n" +
	"\x06offset\x18\x04 \x01(\x03R\x06offset\"\xee\x01\n" +
	"\"QueryStaticDepositAddressesRequest\x12.\n" +
	"\x13identity_public_key\x18\x01 \x01(\fR\x11identityPublicKey\x12(\n" +
	"\anetwork\x18\x02 \x01(\x0e2\x0e.spark.NetworkR\anetwork\x12\x14\n" +
	"\x05limit\x18\x04 \x01(\x03R\x05limit\x12\x16\n" +
	"\x06offset\x18\x05 \x01(\x03R\x06offset\x12,\n" +
	"\x0fdeposit_address\x18\x06 \x01(\tH\x00R\x0edepositAddress\x88\x01\x01B\x12\n" +
	"\x10_deposit_address\"\xca\x02\n" +
	"\x19DepositAddressQueryResult\x12'\n" +
	"\x0fdeposit_address\x18\x01 \x01(\tR\x0edepositAddress\x125\n" +
	"\x17user_signing_public_key\x18\x02 \x01(\fR\x14userSigningPublicKey\x120\n" +
	"\x14verifying_public_key\x18\x03 \x01(\fR\x12verifyingPublicKey\x12&\n" +
	"\aleaf_id\x18\x04 \x01(\tB\b\xfaB\x05r\x03\xb0\x01\x01H\x00R\x06leafId\x88\x01\x01\x12O\n" +
	"\x13proof_of_possession\x18\x05 \x01(\v2\x1a.spark.DepositAddressProofH\x01R\x11proofOfPossession\x88\x01\x01B\n" +
	"\n" +
	"\b_leaf_idB\x16\n" +
	"\x14_proof_of_possession\"\x8c\x01\n" +
	"#QueryUnusedDepositAddressesResponse\x12M\n" +
	"\x11deposit_addresses\x18\x01 \x03(\v2 .spark.DepositAddressQueryResultR\x10depositAddresses\x12\x16\n" +
	"\x06offset\x18\x02 \x01(\x03R\x06offset\"t\n" +
	"#QueryStaticDepositAddressesResponse\x12M\n" +
	"\x11deposit_addresses\x18\x01 \x03(\v2 .spark.DepositAddressQueryResultR\x10depositAddresses\"o\n" +
	"\x13QueryBalanceRequest\x12.\n" +
	"\x13identity_public_key\x18\x01 \x01(\fR\x11identityPublicKey\x12(\n" +
	"\anetwork\x18\x02 \x01(\x0e2\x0e.spark.NetworkR\anetwork\"\xc5\x01\n" +
	"\x14QueryBalanceResponse\x12\x18\n" +
	"\abalance\x18\x01 \x01(\x04R\abalance\x12R\n" +
	"\rnode_balances\x18\x02 \x03(\v2-.spark.QueryBalanceResponse.NodeBalancesEntryR\fnodeBalances\x1a?\n" +
	"\x11NodeBalancesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x04R\x05value:\x028\x01\"\xc5\x01\n" +
	"\fSparkAddress\x12.\n" +
	"\x13identity_public_key\x18\x01 \x01(\fR\x11identityPublicKey\x12K\n" +
	"\x14spark_invoice_fields\x18\x02 \x01(\v2\x19.spark.SparkInvoiceFieldsR\x12sparkInvoiceFields\x12*\n" +
	"\tsignature\x18\x03 \x01(\fB\a\xfaB\x04z\x02h@H\x00R\tsignature\x88\x01\x01B\f\n" +
	"\n" +
	"_signature\"\x9c\x03\n" +
	"\x12SparkInvoiceFields\x12\x18\n" +
	"\aversion\x18\x01 \x01(\rR\aversion\x12\x17\n" +
	"\x02id\x18\x02 \x01(\fB\a\xfaB\x04z\x02h\x10R\x02id\x12=\n" +
	"\x0etokens_payment\x18\x03 \x01(\v2\x14.spark.TokensPaymentH\x00R\rtokensPayment\x127\n" +
	"\fsats_payment\x18\x04 \x01(\v2\x12.spark.SatsPaymentH\x00R\vsatsPayment\x12 \n" +
	"\x04memo\x18\x05 \x01(\tB\a\xfaB\x04r\x02(xH\x01R\x04memo\x88\x01\x01\x128\n" +
	"\x11sender_public_key\x18\x06 \x01(\fB\a\xfaB\x04z\x02h!H\x02R\x0fsenderPublicKey\x88\x01\x01\x12@\n" +
	"\vexpiry_time\x18\a \x01(\v2\x1a.google.protobuf.TimestampH\x03R\n" +
	"expiryTime\x88\x01\x01B\x0e\n" +
	"\fpayment_typeB\a\n" +
	"\x05_memoB\x14\n" +
	"\x12_sender_public_keyB\x0e\n" +
	"\f_expiry_time\"5\n" +
	"\vSatsPayment\x12\x1b\n" +
	"\x06amount\x18\x01 \x01(\x04H\x00R\x06amount\x88\x01\x01B\t\n" +
	"\a_amount\"\x8e\x01\n" +
	"\rTokensPayment\x127\n" +
	"\x10token_identifier\x18\x01 \x01(\fB\a\xfaB\x04z\x02h H\x00R\x0ftokenIdentifier\x88\x01\x01\x12$\n" +
	"\x06amount\x18\x02 \x01(\fB\a\xfaB\x04z\x02\x18\x10H\x01R\x06amount\x88\x01\x01B\x13\n" +
	"\x11_token_identifierB\t\n" +
	"\a_amount\"\xc6\x01\n" +
	"&InitiateStaticDepositUtxoRefundRequest\x12/\n" +
	"\ron_chain_utxo\x18\x01 \x01(\v2\v.spark.UTXOR\vonChainUtxo\x12D\n" +
	"\x15refund_tx_signing_job\x18\x03 \x01(\v2\x11.spark.SigningJobR\x12refundTxSigningJob\x12%\n" +
	"\x0euser_signature\x18\x04 \x01(\fR\ruserSignature\"\xc3\x01\n" +
	"'InitiateStaticDepositUtxoRefundResponse\x12M\n" +
	"\x18refund_tx_signing_result\x18\x01 \x01(\v2\x14.spark.SigningResultR\x15refundTxSigningResult\x12I\n" +
	"\x0fdeposit_address\x18\x02 \x01(\v2 .spark.DepositAddressQueryResultR\x0edepositAddress\"\xb0\x03\n" +
	"\x17InitiateUtxoSwapRequest\x12/\n" +
	"\ron_chain_utxo\x18\x01 \x01(\v2\v.spark.UTXOR\vonChainUtxo\x12=\n" +
	"\frequest_type\x18\x02 \x01(\x0e2\x1a.spark.UtxoSwapRequestTypeR\vrequestType\x12.\n" +
	"\x12credit_amount_sats\x18\x03 \x01(\x04H\x00R\x10creditAmountSats\x12\"\n" +
	"\fmax_fee_sats\x18\x04 \x01(\x04H\x00R\n" +
	"maxFeeSats\x12#\n" +
	"\rssp_signature\x18\x05 \x01(\fR\fsspSignature\x12%\n" +
	"\x0euser_signature\x18\x06 \x01(\fR\ruserSignature\x127\n" +
	"\btransfer\x18\a \x01(\v2\x1b.spark.StartTransferRequestR\btransfer\x12B\n" +
	"\x14spend_tx_signing_job\x18\b \x01(\v2\x11.spark.SigningJobR\x11spendTxSigningJobB\b\n" +
	"\x06amount\"\xdf\x01\n" +
	"\x18InitiateUtxoSwapResponse\x12K\n" +
	"\x17spend_tx_signing_result\x18\x01 \x01(\v2\x14.spark.SigningResultR\x14spendTxSigningResult\x12+\n" +
	"\btransfer\x18\x02 \x01(\v2\x0f.spark.TransferR\btransfer\x12I\n" +
	"\x0fdeposit_address\x18\x03 \x01(\v2 .spark.DepositAddressQueryResultR\x0edepositAddress\"\x8b\x01\n" +
	"\vExitingTree\x12\x17\n" +
	"\atree_id\x18\x01 \x01(\tR\x06treeId\x12Q\n" +
	"\x17user_signing_commitment\x18\x02 \x01(\v2\x19.common.SigningCommitmentR\x15userSigningCommitment\x12\x10\n" +
	"\x03vin\x18\x03 \x01(\rR\x03vin\"\x9c\x01\n" +
	"\x1fExitSingleNodeTreeSigningResult\x12\x17\n" +
	"\atree_id\x18\x01 \x01(\tR\x06treeId\x12;\n" +
	"\x0esigning_result\x18\x02 \x01(\v2\x14.spark.SigningResultR\rsigningResult\x12#\n" +
	"\rverifying_key\x18\x03 \x01(\fR\fverifyingKey\"M\n" +
	"\x18BitcoinTransactionOutput\x12\x14\n" +
	"\x05value\x18\x01 \x01(\x03R\x05value\x12\x1b\n" +
	"\tpk_script\x18\x02 \x01(\fR\bpkScript\"\xf3\x01\n" +
	"\x1aExitSingleNodeTreesRequest\x129\n" +
	"\x19owner_identity_public_key\x18\x01 \x01(\fR\x16ownerIdentityPublicKey\x127\n" +
	"\rexiting_trees\x18\x02 \x03(\v2\x12.spark.ExitingTreeR\fexitingTrees\x12\x15\n" +
	"\x06raw_tx\x18\x03 \x01(\fR\x05rawTx\x12J\n" +
	"\x10previous_outputs\x18\x04 \x03(\v2\x1f.spark.BitcoinTransactionOutputR\x0fpreviousOutputs\"n\n" +
	"\x1bExitSingleNodeTreesResponse\x12O\n" +
	"\x0fsigning_results\x18\x01 \x03(\v2&.spark.ExitSingleNodeTreeSigningResultR\x0esigningResults\"\x91\x01\n" +
	"\x18InvestigateLeavesRequest\x12\x19\n" +
	"\bleaf_ids\x18\x01 \x03(\tR\aleafIds\x129\n" +
	"\x19owner_identity_public_key\x18\x02 \x01(\fR\x16ownerIdentityPublicKey\x12\x1f\n" +
	"\vtransfer_id\x18\x03 \x01(\tR\n" +
	"transferId\"Z\n" +
	"\x1dQueryNodesDistributionRequest\x129\n" +
	"\x19owner_identity_public_key\x18\x01 \x01(\fR\x16ownerIdentityPublicKey\"\xcf\x01\n" +
	"\x1eQueryNodesDistributionResponse\x12h\n" +
	"\x11node_distribution\x18\x01 \x03(\v2;.spark.QueryNodesDistributionResponse.NodeDistributionEntryR\x10nodeDistribution\x1aC\n" +
	"\x15NodeDistributionEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x04R\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x04R\x05value:\x028\x01\"\x99\x01\n" +
	"\x18QueryNodesByValueRequest\x129\n" +
	"\x19owner_identity_public_key\x18\x01 \x01(\fR\x16ownerIdentityPublicKey\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x03R\x05value\x12\x16\n" +
	"\x06offset\x18\x03 \x01(\x03R\x06offset\x12\x14\n" +
	"\x05limit\x18\x04 \x01(\x03R\x05limit\"\xc1\x01\n" +
	"\x19QueryNodesByValueResponse\x12A\n" +
	"\x05nodes\x18\x01 \x03(\v2+.spark.QueryNodesByValueResponse.NodesEntryR\x05nodes\x12\x16\n" +
	"\x06offset\x18\x02 \x01(\x03R\x06offset\x1aI\n" +
	"\n" +
	"NodesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12%\n" +
	"\x05value\x18\x02 \x01(\v2\x0f.spark.TreeNodeR\x05value:\x028\x01\"\xb6\x01\n" +
	"\x19GetUtxosForAddressRequest\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x12\x16\n" +
	"\x06offset\x18\x02 \x01(\x04R\x06offset\x12\x14\n" +
	"\x05limit\x18\x03 \x01(\x04R\x05limit\x12(\n" +
	"\anetwork\x18\x04 \x01(\x0e2\x0e.spark.NetworkR\anetwork\x12'\n" +
	"\x0fexclude_claimed\x18\x05 \x01(\bR\x0eexcludeClaimed\"W\n" +
	"\x1aGetUtxosForAddressResponse\x12!\n" +
	"\x05utxos\x18\x01 \x03(\v2\v.spark.UTXOR\x05utxos\x12\x16\n" +
	"\x06offset\x18\x02 \x01(\x04R\x06offset\"c\n" +
	"\x19QuerySparkInvoicesRequest\x12\x14\n" +
	"\x05limit\x18\x01 \x01(\x03R\x05limit\x12\x16\n" +
	"\x06offset\x18\x02 \x01(\x03R\x06offset\x12\x18\n" +
	"\ainvoice\x18\x03 \x03(\tR\ainvoice\"w\n" +
	"\x1aQuerySparkInvoicesResponse\x12\x16\n" +
	"\x06offset\x18\x01 \x01(\x03R\x06offset\x12A\n" +
	"\x10invoice_statuses\x18\x02 \x03(\v2\x16.spark.InvoiceResponseR\x0finvoiceStatuses\"\xe5\x01\n" +
	"\x0fInvoiceResponse\x12\x18\n" +
	"\ainvoice\x18\x01 \x01(\tR\ainvoice\x12,\n" +
	"\x06status\x18\x02 \x01(\x0e2\x14.spark.InvoiceStatusR\x06status\x12:\n" +
	"\rsats_transfer\x18\x03 \x01(\v2\x13.spark.SatsTransferH\x00R\fsatsTransfer\x12=\n" +
	"\x0etoken_transfer\x18\x04 \x01(\v2\x14.spark.TokenTransferH\x00R\rtokenTransferB\x0f\n" +
	"\rtransfer_type\"8\n" +
	"\fSatsTransfer\x12(\n" +
	"\vtransfer_id\x18\x01 \x01(\fB\a\xfaB\x04z\x02h\x10R\n" +
	"transferId\"Y\n" +
	"\rTokenTransfer\x12H\n" +
	"\x1cfinal_token_transaction_hash\x18\x01 \x01(\fB\a\xfaB\x04z\x02h R\x19finalTokenTransactionHash\"\xad\x01\n" +
	"\"InitiateSwapPrimaryTransferRequest\x127\n" +
	"\btransfer\x18\x01 \x01(\v2\x1b.spark.StartTransferRequestR\btransfer\x12N\n" +
	"\x13adaptor_public_keys\x18\x02 \x01(\v2\x1e.spark.AdaptorPublicKeyPackageR\x11adaptorPublicKeys\"\x9d\x01\n" +
	"#InitiateSwapPrimaryTransferResponse\x12+\n" +
	"\btransfer\x18\x01 \x01(\v2\x0f.spark.TransferR\btransfer\x12I\n" +
	"\x0fsigning_results\x18\x02 \x03(\v2 .spark.LeafRefundTxSigningResultR\x0esigningResults\"\xcf\x01\n" +
	"\x17AdaptorPublicKeyPackage\x12,\n" +
	"\x12adaptor_public_key\x18\x01 \x01(\fR\x10adaptorPublicKey\x129\n" +
	"\x19direct_adaptor_public_key\x18\x02 \x01(\fR\x16directAdaptorPublicKey\x12K\n" +
	"#direct_from_cpfp_adaptor_public_key\x18\x03 \x01(\fR\x1edirectFromCpfpAdaptorPublicKey*M\n" +
	"\aNetwork\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x00\x12\v\n" +
	"\aMAINNET\x10\x01\x12\v\n" +
	"\aREGTEST\x10\x02\x12\v\n" +
	"\aTESTNET\x10\x03\x12\n" +
	"\n" +
	"\x06SIGNET\x10\x04*#\n" +
	"\tDirection\x12\b\n" +
	"\x04NEXT\x10\x00\x12\f\n" +
	"\bPREVIOUS\x10\x01*\x86\x02\n" +
	"\x16TokenTransactionStatus\x12\x1d\n" +
	"\x19TOKEN_TRANSACTION_STARTED\x10\x00\x12\x1c\n" +
	"\x18TOKEN_TRANSACTION_SIGNED\x10\x01\x12\x1e\n" +
	"\x1aTOKEN_TRANSACTION_REVEALED\x10\x05\x12\x1f\n" +
	"\x1bTOKEN_TRANSACTION_FINALIZED\x10\x02\x12'\n" +
	"#TOKEN_TRANSACTION_STARTED_CANCELLED\x10\x03\x12&\n" +
	"\"TOKEN_TRANSACTION_SIGNED_CANCELLED\x10\x04\x12\x1d\n" +
	"\x19TOKEN_TRANSACTION_UNKNOWN\x10\n" +
	"*\xcd\x03\n" +
	"\x0eTransferStatus\x12$\n" +
	" TRANSFER_STATUS_SENDER_INITIATED\x10\x00\x12,\n" +
	"(TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING\x10\x01\x12&\n" +
	"\"TRANSFER_STATUS_SENDER_KEY_TWEAKED\x10\x02\x12(\n" +
	"$TRANSFER_STATUS_RECEIVER_KEY_TWEAKED\x10\x03\x12*\n" +
	"&TRANSFER_STATUS_RECEIVER_REFUND_SIGNED\x10\x04\x12\x1d\n" +
	"\x19TRANSFER_STATUS_COMPLETED\x10\x05\x12\x1b\n" +
	"\x17TRANSFER_STATUS_EXPIRED\x10\x06\x12\x1c\n" +
	"\x18TRANSFER_STATUS_RETURNED\x10\a\x120\n" +
	",TRANSFER_STATUS_SENDER_INITIATED_COORDINATOR\x10\b\x12-\n" +
	")TRANSFER_STATUS_RECEIVER_KEY_TWEAK_LOCKED\x10\t\x12.\n" +
	"*TRANSFER_STATUS_RECEIVER_KEY_TWEAK_APPLIED\x10\n" +
	"*p\n" +
	"\fTransferType\x12\x11\n" +
	"\rPREIMAGE_SWAP\x10\x00\x12\x14\n" +
	"\x10COOPERATIVE_EXIT\x10\x01\x12\f\n" +
	"\bTRANSFER\x10\x02\x12\r\n" +
	"\tUTXO_SWAP\x10\x03\x12\b\n" +
	"\x04SWAP\x10\x1e\x12\x10\n" +
	"\fCOUNTER_SWAP\x10(*&\n" +
	"\x05Order\x12\x0e\n" +
	"\n" +
	"DESCENDING\x10\x00\x12\r\n" +
	"\tASCENDING\x10\x01*\x9c\x01\n" +
	"\x15PreimageRequestStatus\x120\n" +
	",PREIMAGE_REQUEST_STATUS_WAITING_FOR_PREIMAGE\x10\x00\x12+\n" +
	"'PREIMAGE_REQUEST_STATUS_PREIMAGE_SHARED\x10\x01\x12$\n" +
	" PREIMAGE_REQUEST_STATUS_RETURNED\x10\x02*8\n" +
	"\x13UtxoSwapRequestType\x12\t\n" +
	"\x05Fixed\x10\x00\x12\n" +
	"\n" +
	"\x06MaxFee\x10\x01\x12\n" +
	"\n" +
	"\x06Refund\x10\x02*N\n" +
	"\rInvoiceStatus\x12\r\n" +
	"\tNOT_FOUND\x10\x00\x12\v\n" +
	"\aPENDING\x10\x01\x12\r\n" +
	"\tFINALIZED\x10\x02\x12\f\n" +
	"\bRETURNED\x10\x04\"\x04\b\x03\x10\x032\xdc)\n" +
	"\fSparkService\x12i\n" +
	"\x18generate_deposit_address\x12$.spark.GenerateDepositAddressRequest\x1a%.spark.GenerateDepositAddressResponse\"\x00\x12|\n" +
	"\x1fgenerate_static_deposit_address\x12*.spark.GenerateStaticDepositAddressRequest\x1a+.spark.GenerateStaticDepositAddressResponse\"\x00\x12p\n" +
	"\x1bstart_deposit_tree_creation\x12&.spark.StartDepositTreeCreationRequest\x1a'.spark.StartDepositTreeCreationResponse\"\x00\x12]\n" +
	"\x13start_tree_creation\x12\x1f.spark.StartTreeCreationRequest\x1a .spark.StartTreeCreationResponse\"\x03\x88\x02\x01\x12i\n" +
	"\x18finalize_node_signatures\x12$.spark.FinalizeNodeSignaturesRequest\x1a%.spark.FinalizeNodeSignaturesResponse\"\x00\x12M\n" +
	"\x0estart_transfer\x12\x1b.spark.StartTransferRequest\x1a\x1c.spark.StartTransferResponse\"\x00\x12Y\n" +
	"\x11finalize_transfer\x12\x1e.spark.FinalizeTransferRequest\x1a\x1f.spark.FinalizeTransferResponse\"\x03\x88\x02\x01\x12\x7f\n" +
	"'finalize_transfer_with_transfer_package\x121.spark.FinalizeTransferWithTransferPackageRequest\x1a\x1f.spark.FinalizeTransferResponse\"\x00\x12P\n" +
	"\x0fcancel_transfer\x12\x1c.spark.CancelTransferRequest\x1a\x1d.spark.CancelTransferResponse\"\x00\x12Q\n" +
	"\x17query_pending_transfers\x12\x15.spark.TransferFilter\x1a\x1d.spark.QueryTransfersResponse\"\x00\x12M\n" +
	"\x13query_all_transfers\x12\x15.spark.TransferFilter\x1a\x1d.spark.QueryTransfersResponse\"\x00\x12[\n" +
	"\x19claim_transfer_tweak_keys\x12$.spark.ClaimTransferTweakKeysRequest\x1a\x16.google.protobuf.Empty\"\x00\x12p\n" +
	"\x1bclaim_transfer_sign_refunds\x12&.spark.ClaimTransferSignRefundsRequest\x1a'.spark.ClaimTransferSignRefundsResponse\"\x00\x12R\n" +
	"\x14store_preimage_share\x12 .spark.StorePreimageShareRequest\x1a\x16.google.protobuf.Empty\"\x00\x12f\n" +
	"\x17get_signing_commitments\x12#.spark.GetSigningCommitmentsRequest\x1a$.spark.GetSigningCommitmentsResponse\"\x00\x12S\n" +
	"\x10cooperative_exit\x12\x1d.spark.CooperativeExitRequest\x1a\x1e.spark.CooperativeExitResponse\"\x00\x12c\n" +
	"\x16initiate_preimage_swap\x12\".spark.InitiatePreimageSwapRequest\x1a#.spark.InitiatePreimageSwapResponse\"\x00\x12S\n" +
	"\x10provide_preimage\x12\x1d.spark.ProvidePreimageRequest\x1a\x1e.spark.ProvidePreimageResponse\"\x00\x12A\n" +
	"\n" +
	"query_htlc\x12\x17.spark.QueryHtlcRequest\x1a\x18.spark.QueryHtlcResponse\"\x00\x12N\n" +
	"\x0fstart_leaf_swap\x12\x1b.spark.StartTransferRequest\x1a\x1c.spark.StartTransferResponse\"\x00\x12O\n" +
	"\tleaf_swap\x12\x1d.spark.CounterLeafSwapRequest\x1a\x1e.spark.CounterLeafSwapResponse\"\x03\x88\x02\x01\x12T\n" +
	"\x11counter_leaf_swap\x12\x1d.spark.CounterLeafSwapRequest\x1a\x1e.spark.CounterLeafSwapResponse\"\x00\x12S\n" +
	"\x10refresh_timelock\x12\x1d.spark.RefreshTimelockRequest\x1a\x1e.spark.RefreshTimelockResponse\"\x00\x12D\n" +
	"\vextend_leaf\x12\x18.spark.ExtendLeafRequest\x1a\x19.spark.ExtendLeafResponse\"\x00\x12A\n" +
	"\n" +
	"renew_leaf\x12\x17.spark.RenewLeafRequest\x1a\x18.spark.RenewLeafResponse\"\x00\x12\\\n" +
	"\x19get_signing_operator_list\x12\x16.google.protobuf.Empty\x1a%.spark.GetSigningOperatorListResponse\"\x00\x12D\n" +
	"\vquery_nodes\x12\x18.spark.QueryNodesRequest\x1a\x19.spark.QueryNodesResponse\"\x00\x12i\n" +
	"\x18query_nodes_distribution\x12$.spark.QueryNodesDistributionRequest\x1a%.spark.QueryNodesDistributionResponse\"\x00\x12[\n" +
	"\x14query_nodes_by_value\x12\x1f.spark.QueryNodesByValueRequest\x1a .spark.QueryNodesByValueResponse\"\x00\x12J\n" +
	"\rquery_balance\x12\x1a.spark.QueryBalanceRequest\x1a\x1b.spark.QueryBalanceResponse\"\x00\x12j\n" +
	"\x19query_user_signed_refunds\x12$.spark.QueryUserSignedRefundsRequest\x1a%.spark.QueryUserSignedRefundsResponse\"\x00\x12f\n" +
	"\x17start_token_transaction\x12#.spark.StartTokenTransactionRequest\x1a$.spark.StartTokenTransactionResponse\"\x00\x12c\n" +
	"\x16sign_token_transaction\x12\".spark.SignTokenTransactionRequest\x1a#.spark.SignTokenTransactionResponse\"\x00\x12^\n" +
	"\x1afinalize_token_transaction\x12&.spark.FinalizeTokenTransactionRequest\x1a\x16.google.protobuf.Empty\"\x00\x12J\n" +
	"\rfreeze_tokens\x12\x1a.spark.FreezeTokensRequest\x1a\x1b.spark.FreezeTokensResponse\"\x00\x12Z\n" +
	"\x13query_token_outputs\x12\x1f.spark.QueryTokenOutputsRequest\x1a .spark.QueryTokenOutputsResponse\"\x00\x12i\n" +
	"\x18query_token_transactions\x12$.spark.QueryTokenTransactionsRequest\x1a%.spark.QueryTokenTransactionsResponse\"\x00\x12Z\n" +
	"\x18return_lightning_payment\x12$.spark.ReturnLightningPaymentRequest\x1a\x16.google.protobuf.Empty\"\x00\x12y\n" +
	"\x1equery_unused_deposit_addresses\x12).spark.QueryUnusedDepositAddressesRequest\x1a*.spark.QueryUnusedDepositAddressesResponse\"\x00\x12y\n" +
	"\x1equery_static_deposit_addresses\x12).spark.QueryStaticDepositAddressesRequest\x1a*.spark.QueryStaticDepositAddressesResponse\"\x00\x12\\\n" +
	"\x13subscribe_to_events\x12\x1f.spark.SubscribeToEventsRequest\x1a .spark.SubscribeToEventsResponse\"\x000\x01\x12\x86\x01\n" +
	"#initiate_static_deposit_utxo_refund\x12-.spark.InitiateStaticDepositUtxoRefundRequest\x1a..spark.InitiateStaticDepositUtxoRefundResponse\"\x00\x12Z\n" +
	"\x12initiate_utxo_swap\x12\x1e.spark.InitiateUtxoSwapRequest\x1a\x1f.spark.InitiateUtxoSwapResponse\"\x03\x88\x02\x01\x12a\n" +
	"\x16exit_single_node_trees\x12!.spark.ExitSingleNodeTreesRequest\x1a\".spark.ExitSingleNodeTreesResponse\"\x00\x12V\n" +
	"\x13cooperative_exit_v2\x12\x1d.spark.CooperativeExitRequest\x1a\x1e.spark.CooperativeExitResponse\"\x00\x12G\n" +
	"\x0eextend_leaf_v2\x12\x18.spark.ExtendLeafRequest\x1a\x19.spark.ExtendLeafResponse\"\x00\x12s\n" +
	"\x1eclaim_transfer_sign_refunds_v2\x12&.spark.ClaimTransferSignRefundsRequest\x1a'.spark.ClaimTransferSignRefundsResponse\"\x00\x12l\n" +
	"\x1bfinalize_node_signatures_v2\x12$.spark.FinalizeNodeSignaturesRequest\x1a%.spark.FinalizeNodeSignaturesResponse\"\x00\x12f\n" +
	"\x19initiate_preimage_swap_v2\x12\".spark.InitiatePreimageSwapRequest\x1a#.spark.InitiatePreimageSwapResponse\"\x00\x12Q\n" +
	"\x12start_leaf_swap_v2\x12\x1b.spark.StartTransferRequest\x1a\x1c.spark.StartTransferResponse\"\x00\x12W\n" +
	"\x14counter_leaf_swap_v2\x12\x1d.spark.CounterLeafSwapRequest\x1a\x1e.spark.CounterLeafSwapResponse\"\x00\x12P\n" +
	"\x11start_transfer_v2\x12\x1b.spark.StartTransferRequest\x1a\x1c.spark.StartTransferResponse\"\x00\x12V\n" +
	"\x13refresh_timelock_v2\x12\x1d.spark.RefreshTimelockRequest\x1a\x1e.spark.RefreshTimelockResponse\"\x00\x12^\n" +
	"\x15get_utxos_for_address\x12 .spark.GetUtxosForAddressRequest\x1a!.spark.GetUtxosForAddressResponse\"\x00\x12]\n" +
	"\x14query_spark_invoices\x12 .spark.QuerySparkInvoicesRequest\x1a!.spark.QuerySparkInvoicesResponse\"\x00\x12y\n" +
	"\x1einitiate_swap_primary_transfer\x12).spark.InitiateSwapPrimaryTransferRequest\x1a*.spark.InitiateSwapPrimaryTransferResponse\"\x00B,Z*github.com/lightsparkdev/spark/proto/sparkb\x06proto3"

var (
	file_spark_proto_rawDescOnce sync.Once
	file_spark_proto_rawDescData []byte
)

func file_spark_proto_rawDescGZIP() []byte {
	file_spark_proto_rawDescOnce.Do(func() {
		file_spark_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_spark_proto_rawDesc), len(file_spark_proto_rawDesc)))
	})
	return file_spark_proto_rawDescData
}

var file_spark_proto_enumTypes = make([]protoimpl.EnumInfo, 10)
var file_spark_proto_msgTypes = make([]protoimpl.MessageInfo, 179)
var file_spark_proto_goTypes = []any{
	(Network)(0),                                            // 0: spark.Network
	(Direction)(0),                                          // 1: spark.Direction
	(TokenTransactionStatus)(0),                             // 2: spark.TokenTransactionStatus
	(TransferStatus)(0),                                     // 3: spark.TransferStatus
	(TransferType)(0),                                       // 4: spark.TransferType
	(Order)(0),                                              // 5: spark.Order
	(PreimageRequestStatus)(0),                              // 6: spark.PreimageRequestStatus
	(UtxoSwapRequestType)(0),                                // 7: spark.UtxoSwapRequestType
	(InvoiceStatus)(0),                                      // 8: spark.InvoiceStatus
	(InitiatePreimageSwapRequest_Reason)(0),                 // 9: spark.InitiatePreimageSwapRequest.Reason
	(*SubscribeToEventsRequest)(nil),                        // 10: spark.SubscribeToEventsRequest
	(*SubscribeToEventsResponse)(nil),                       // 11: spark.SubscribeToEventsResponse
	(*ConnectedEvent)(nil),                                  // 12: spark.ConnectedEvent
	(*TransferEvent)(nil),                                   // 13: spark.TransferEvent
	(*DepositEvent)(nil),                                    // 14: spark.DepositEvent
	(*PageRequest)(nil),                                     // 15: spark.PageRequest
	(*PageResponse)(nil),                                    // 16: spark.PageResponse
	(*DepositAddressProof)(nil),                             // 17: spark.DepositAddressProof
	(*GenerateDepositAddressRequest)(nil),                   // 18: spark.GenerateDepositAddressRequest
	(*Address)(nil),                                         // 19: spark.Address
	(*GenerateDepositAddressResponse)(nil),                  // 20: spark.GenerateDepositAddressResponse
	(*GenerateStaticDepositAddressRequest)(nil),             // 21: spark.GenerateStaticDepositAddressRequest
	(*GenerateStaticDepositAddressResponse)(nil),            // 22: spark.GenerateStaticDepositAddressResponse
	(*UTXO)(nil),                                            // 23: spark.UTXO
	(*NodeOutput)(nil),                                      // 24: spark.NodeOutput
	(*SigningJob)(nil),                                      // 25: spark.SigningJob
	(*SigningKeyshare)(nil),                                 // 26: spark.SigningKeyshare
	(*SigningResult)(nil),                                   // 27: spark.SigningResult
	(*RenewLeafRequest)(nil),                                // 28: spark.RenewLeafRequest
	(*RenewNodeTimelockSigningJob)(nil),                     // 29: spark.RenewNodeTimelockSigningJob
	(*RenewRefundTimelockSigningJob)(nil),                   // 30: spark.RenewRefundTimelockSigningJob
	(*RenewNodeZeroTimelockSigningJob)(nil),                 // 31: spark.RenewNodeZeroTimelockSigningJob
	(*RenewLeafResponse)(nil),                               // 32: spark.RenewLeafResponse
	(*RenewNodeTimelockResult)(nil),                         // 33: spark.RenewNodeTimelockResult
	(*RenewRefundTimelockResult)(nil),                       // 34: spark.RenewRefundTimelockResult
	(*RenewNodeZeroTimelockResult)(nil),                     // 35: spark.RenewNodeZeroTimelockResult
	(*NodeSignatureShares)(nil),                             // 36: spark.NodeSignatureShares
	(*NodeSignatures)(nil),                                  // 37: spark.NodeSignatures
	(*StartTreeCreationRequest)(nil),                        // 38: spark.StartTreeCreationRequest
	(*StartTreeCreationResponse)(nil),                       // 39: spark.StartTreeCreationResponse
	(*StartDepositTreeCreationRequest)(nil),                 // 40: spark.StartDepositTreeCreationRequest
	(*StartDepositTreeCreationResponse)(nil),                // 41: spark.StartDepositTreeCreationResponse
	(*TokenOutputToSpend)(nil),                              // 42: spark.TokenOutputToSpend
	(*TokenTransferInput)(nil),                              // 43: spark.TokenTransferInput
	(*TokenMintInput)(nil),                                  // 44: spark.TokenMintInput
	(*TokenCreateInput)(nil),                                // 45: spark.TokenCreateInput
	(*TokenOutput)(nil),                                     // 46: spark.TokenOutput
	(*TokenTransaction)(nil),                                // 47: spark.TokenTransaction
	(*SpentTokenOutputMetadata)(nil),                        // 48: spark.SpentTokenOutputMetadata
	(*TokenTransactionConfirmationMetadata)(nil),            // 49: spark.TokenTransactionConfirmationMetadata
	(*TokenTransactionWithStatus)(nil),                      // 50: spark.TokenTransactionWithStatus
	(*SignatureWithIndex)(nil),                              // 51: spark.SignatureWithIndex
	(*TokenTransactionSignatures)(nil),                      // 52: spark.TokenTransactionSignatures
	(*StartTokenTransactionRequest)(nil),                    // 53: spark.StartTokenTransactionRequest
	(*StartTokenTransactionResponse)(nil),                   // 54: spark.StartTokenTransactionResponse
	(*OperatorSpecificTokenTransactionSignablePayload)(nil), // 55: spark.OperatorSpecificTokenTransactionSignablePayload
	(*OperatorSpecificOwnerSignature)(nil),                  // 56: spark.OperatorSpecificOwnerSignature
	(*SignTokenTransactionRequest)(nil),                     // 57: spark.SignTokenTransactionRequest
	(*KeyshareWithIndex)(nil),                               // 58: spark.KeyshareWithIndex
	(*SignTokenTransactionResponse)(nil),                    // 59: spark.SignTokenTransactionResponse
	(*RevocationSecretWithIndex)(nil),                       // 60: spark.RevocationSecretWithIndex
	(*FinalizeTokenTransactionRequest)(nil),                 // 61: spark.FinalizeTokenTransactionRequest
	(*FreezeTokensPayload)(nil),                             // 62: spark.FreezeTokensPayload
	(*FreezeTokensRequest)(nil),                             // 63: spark.FreezeTokensRequest
	(*FreezeTokensResponse)(nil),                            // 64: spark.FreezeTokensResponse
	(*QueryTokenOutputsRequest)(nil),                        // 65: spark.QueryTokenOutputsRequest
	(*QueryTokenTransactionsRequest)(nil),                   // 66: spark.QueryTokenTransactionsRequest
	(*QueryTokenTransactionsResponse)(nil),                  // 67: spark.QueryTokenTransactionsResponse
	(*OutputWithPreviousTransactionData)(nil),               // 68: spark.OutputWithPreviousTransactionData
	(*QueryTokenOutputsResponse)(nil),                       // 69: spark.QueryTokenOutputsResponse
	(*TreeNode)(nil),                                        // 70: spark.TreeNode
	(*FinalizeNodeSignaturesRequest)(nil),                   // 71: spark.FinalizeNodeSignaturesRequest
	(*FinalizeNodeSignaturesResponse)(nil),                  // 72: spark.FinalizeNodeSignaturesResponse
	(*SecretShare)(nil),                                     // 73: spark.SecretShare
	(*SecretProof)(nil),                                     // 74: spark.SecretProof
	(*LeafRefundTxSigningJob)(nil),                          // 75: spark.LeafRefundTxSigningJob
	(*UserSignedTxSigningJob)(nil),                          // 76: spark.UserSignedTxSigningJob
	(*LeafRefundTxSigningResult)(nil),                       // 77: spark.LeafRefundTxSigningResult
	(*StartUserSignedTransferRequest)(nil),                  // 78: spark.StartUserSignedTransferRequest
	(*StartTransferRequest)(nil),                            // 79: spark.StartTransferRequest
	(*StartTransferResponse)(nil),                           // 80: spark.StartTransferResponse
	(*TransferPackage)(nil),                                 // 81: spark.TransferPackage
	(*SendLeafKeyTweaks)(nil),                               // 82: spark.SendLeafKeyTweaks
	(*SendLeafKeyTweak)(nil),                                // 83: spark.SendLeafKeyTweak
	(*FinalizeTransferRequest)(nil),                         // 84: spark.FinalizeTransferRequest
	(*FinalizeTransferWithTransferPackageRequest)(nil),      // 85: spark.FinalizeTransferWithTransferPackageRequest
	(*FinalizeTransferResponse)(nil),                        // 86: spark.FinalizeTransferResponse
	(*Transfer)(nil),                                        // 87: spark.Transfer
	(*TransferLeaf)(nil),                                    // 88: spark.TransferLeaf
	(*TransferFilter)(nil),                                  // 89: spark.TransferFilter
	(*QueryTransfersResponse)(nil),                          // 90: spark.QueryTransfersResponse
	(*ClaimLeafKeyTweak)(nil),                               // 91: spark.ClaimLeafKeyTweak
	(*ClaimTransferTweakKeysRequest)(nil),                   // 92: spark.ClaimTransferTweakKeysRequest
	(*ClaimTransferSignRefundsRequest)(nil),                 // 93: spark.ClaimTransferSignRefundsRequest
	(*ClaimTransferSignRefundsResponse)(nil),                // 94: spark.ClaimTransferSignRefundsResponse
	(*StorePreimageShareRequest)(nil),                       // 95: spark.StorePreimageShareRequest
	(*RequestedSigningCommitments)(nil),                     // 96: spark.RequestedSigningCommitments
	(*GetSigningCommitmentsRequest)(nil),                    // 97: spark.GetSigningCommitmentsRequest
	(*GetSigningCommitmentsResponse)(nil),                   // 98: spark.GetSigningCommitmentsResponse
	(*SigningCommitments)(nil),                              // 99: spark.SigningCommitments
	(*UserSignedRefund)(nil),                                // 100: spark.UserSignedRefund
	(*InvoiceAmountProof)(nil),                              // 101: spark.InvoiceAmountProof
	(*InvoiceAmount)(nil),                                   // 102: spark.InvoiceAmount
	(*InitiatePreimageSwapRequest)(nil),                     // 103: spark.InitiatePreimageSwapRequest
	(*InitiatePreimageSwapResponse)(nil),                    // 104: spark.InitiatePreimageSwapResponse
	(*OutPoint)(nil),                                        // 105: spark.OutPoint
	(*CooperativeExitRequest)(nil),                          // 106: spark.CooperativeExitRequest
	(*CooperativeExitResponse)(nil),                         // 107: spark.CooperativeExitResponse
	(*CounterLeafSwapRequest)(nil),                          // 108: spark.CounterLeafSwapRequest
	(*CounterLeafSwapResponse)(nil),                         // 109: spark.CounterLeafSwapResponse
	(*RefreshTimelockRequest)(nil),                          // 110: spark.RefreshTimelockRequest
	(*RefreshTimelockSigningResult)(nil),                    // 111: spark.RefreshTimelockSigningResult
	(*RefreshTimelockResponse)(nil),                         // 112: spark.RefreshTimelockResponse
	(*ExtendLeafRequest)(nil),                               // 113: spark.ExtendLeafRequest
	(*ExtendLeafSigningResult)(nil),                         // 114: spark.ExtendLeafSigningResult
	(*ExtendLeafResponse)(nil),                              // 115: spark.ExtendLeafResponse
	(*AddressRequestNode)(nil),                              // 116: spark.AddressRequestNode
	(*PrepareTreeAddressRequest)(nil),                       // 117: spark.PrepareTreeAddressRequest
	(*AddressNode)(nil),                                     // 118: spark.AddressNode
	(*PrepareTreeAddressResponse)(nil),                      // 119: spark.PrepareTreeAddressResponse
	(*CreationNode)(nil),                                    // 120: spark.CreationNode
	(*CreateTreeRequest)(nil),                               // 121: spark.CreateTreeRequest
	(*CreationResponseNode)(nil),                            // 122: spark.CreationResponseNode
	(*CreateTreeResponse)(nil),                              // 123: spark.CreateTreeResponse
	(*SigningOperatorInfo)(nil),                             // 124: spark.SigningOperatorInfo
	(*GetSigningOperatorListResponse)(nil),                  // 125: spark.GetSigningOperatorListResponse
	(*QueryUserSignedRefundsRequest)(nil),                   // 126: spark.QueryUserSignedRefundsRequest
	(*QueryUserSignedRefundsResponse)(nil),                  // 127: spark.QueryUserSignedRefundsResponse
	(*PreimageRequestWithTransfer)(nil),                     // 128: spark.PreimageRequestWithTransfer
	(*QueryHtlcRequest)(nil),                                // 129: spark.QueryHtlcRequest
	(*QueryHtlcResponse)(nil),                               // 130: spark.QueryHtlcResponse
	(*ProvidePreimageRequest)(nil),                          // 131: spark.ProvidePreimageRequest
	(*ProvidePreimageResponse)(nil),                         // 132: spark.ProvidePreimageResponse
	(*ReturnLightningPaymentRequest)(nil),                   // 133: spark.ReturnLightningPaymentRequest
	(*TreeNodeIds)(nil),                                     // 134: spark.TreeNodeIds
	(*QueryNodesRequest)(nil),                               // 135: spark.QueryNodesRequest
	(*QueryNodesResponse)(nil),                              // 136: spark.QueryNodesResponse
	(*CancelTransferRequest)(nil),                           // 137: spark.CancelTransferRequest
	(*CancelTransferResponse)(nil),                          // 138: spark.CancelTransferResponse
	(*QueryUnusedDepositAddressesRequest)(nil),              // 139: spark.QueryUnusedDepositAddressesRequest
	(*QueryStaticDepositAddressesRequest)(nil),              // 140: spark.QueryStaticDepositAddressesRequest
	(*DepositAddressQueryResult)(nil),                       // 141: spark.DepositAddressQueryResult
	(*QueryUnusedDepositAddressesResponse)(nil),             // 142: spark.QueryUnusedDepositAddressesResponse
	(*QueryStaticDepositAddressesResponse)(nil),             // 143: spark.QueryStaticDepositAddressesResponse
	(*QueryBalanceRequest)(nil),                             // 144: spark.QueryBalanceRequest
	(*QueryBalanceResponse)(nil),                            // 145: spark.QueryBalanceResponse
	(*SparkAddress)(nil),                                    // 146: spark.SparkAddress
	(*SparkInvoiceFields)(nil),                              // 147: spark.SparkInvoiceFields
	(*SatsPayment)(nil),                                     // 148: spark.SatsPayment
	(*TokensPayment)(nil),                                   // 149: spark.TokensPayment
	(*InitiateStaticDepositUtxoRefundRequest)(nil),          // 150: spark.InitiateStaticDepositUtxoRefundRequest
	(*InitiateStaticDepositUtxoRefundResponse)(nil),         // 151: spark.InitiateStaticDepositUtxoRefundResponse
	(*InitiateUtxoSwapRequest)(nil),                         // 152: spark.InitiateUtxoSwapRequest
	(*InitiateUtxoSwapResponse)(nil),                        // 153: spark.InitiateUtxoSwapResponse
	(*ExitingTree)(nil),                                     // 154: spark.ExitingTree
	(*ExitSingleNodeTreeSigningResult)(nil),                 // 155: spark.ExitSingleNodeTreeSigningResult
	(*BitcoinTransactionOutput)(nil),                        // 156: spark.BitcoinTransactionOutput
	(*ExitSingleNodeTreesRequest)(nil),                      // 157: spark.ExitSingleNodeTreesRequest
	(*ExitSingleNodeTreesResponse)(nil),                     // 158: spark.ExitSingleNodeTreesResponse
	(*InvestigateLeavesRequest)(nil),                        // 159: spark.InvestigateLeavesRequest
	(*QueryNodesDistributionRequest)(nil),                   // 160: spark.QueryNodesDistributionRequest
	(*QueryNodesDistributionResponse)(nil),                  // 161: spark.QueryNodesDistributionResponse
	(*QueryNodesByValueRequest)(nil),                        // 162: spark.QueryNodesByValueRequest
	(*QueryNodesByValueResponse)(nil),                       // 163: spark.QueryNodesByValueResponse
	(*GetUtxosForAddressRequest)(nil),                       // 164: spark.GetUtxosForAddressRequest
	(*GetUtxosForAddressResponse)(nil),                      // 165: spark.GetUtxosForAddressResponse
	(*QuerySparkInvoicesRequest)(nil),                       // 166: spark.QuerySparkInvoicesRequest
	(*QuerySparkInvoicesResponse)(nil),                      // 167: spark.QuerySparkInvoicesResponse
	(*InvoiceResponse)(nil),                                 // 168: spark.InvoiceResponse
	(*SatsTransfer)(nil),                                    // 169: spark.SatsTransfer
	(*TokenTransfer)(nil),                                   // 170: spark.TokenTransfer
	(*InitiateSwapPrimaryTransferRequest)(nil),              // 171: spark.InitiateSwapPrimaryTransferRequest
	(*InitiateSwapPrimaryTransferResponse)(nil),             // 172: spark.InitiateSwapPrimaryTransferResponse
	(*AdaptorPublicKeyPackage)(nil),                         // 173: spark.AdaptorPublicKeyPackage
	nil,                                                     // 174: spark.DepositAddressProof.AddressSignaturesEntry
	nil,                                                     // 175: spark.SigningKeyshare.PublicSharesEntry
	nil,                                                     // 176: spark.SigningResult.PublicKeysEntry
	nil,                                                     // 177: spark.SigningResult.SigningNonceCommitmentsEntry
	nil,                                                     // 178: spark.SigningResult.SignatureSharesEntry
	nil,                                                     // 179: spark.TransferPackage.KeyTweakPackageEntry
	nil,                                                     // 180: spark.SendLeafKeyTweak.PubkeySharesTweakEntry
	nil,                                                     // 181: spark.ClaimLeafKeyTweak.PubkeySharesTweakEntry
	nil,                                                     // 182: spark.RequestedSigningCommitments.SigningNonceCommitmentsEntry
	nil,                                                     // 183: spark.SigningCommitments.SigningCommitmentsEntry
	nil,                                                     // 184: spark.GetSigningOperatorListResponse.SigningOperatorsEntry
	nil,                                                     // 185: spark.QueryNodesResponse.NodesEntry
	nil,                                                     // 186: spark.QueryBalanceResponse.NodeBalancesEntry
	nil,                                                     // 187: spark.QueryNodesDistributionResponse.NodeDistributionEntry
	nil,                                                     // 188: spark.QueryNodesByValueResponse.NodesEntry
	(*common.SigningCommitment)(nil),                        // 189: common.SigningCommitment
	(*timestamppb.Timestamp)(nil),                           // 190: google.protobuf.Timestamp
	(common.SignatureIntent)(0),                             // 191: common.SignatureIntent
	(*emptypb.Empty)(nil),                                   // 192: google.protobuf.Empty
}
var file_spark_proto_depIdxs = []int32{
	13,  // 0: spark.SubscribeToEventsResponse.transfer:type_name -> spark.TransferEvent
	14,  // 1: spark.SubscribeToEventsResponse.deposit:type_name -> spark.DepositEvent
	12,  // 2: spark.SubscribeToEventsResponse.connected:type_name -> spark.ConnectedEvent
	87,  // 3: spark.TransferEvent.transfer:type_name -> spark.Transfer
	70,  // 4: spark.DepositEvent.deposit:type_name -> spark.TreeNode
	1,   // 5: spark.PageRequest.direction:type_name -> spark.Direction
	174, // 6: spark.DepositAddressProof.address_signatures:type_name -> spark.DepositAddressProof.AddressSignaturesEntry
	0,   // 7: spark.GenerateDepositAddressRequest.network:type_name -> spark.Network
	17,  // 8: spark.Address.deposit_address_proof:type_name -> spark.DepositAddressProof
	19,  // 9: spark.GenerateDepositAddressResponse.deposit_address:type_name -> spark.Address
	0,   // 10: spark.GenerateStaticDepositAddressRequest.network:type_name -> spark.Network
	19,  // 11: spark.GenerateStaticDepositAddressResponse.deposit_address:type_name -> spark.Address
	0,   // 12: spark.UTXO.network:type_name -> spark.Network
	189, // 13: spark.SigningJob.signing_nonce_commitment:type_name -> common.SigningCommitment
	175, // 14: spark.SigningKeyshare.public_shares:type_name -> spark.SigningKeyshare.PublicSharesEntry
	190, // 15: spark.SigningKeyshare.updated_time:type_name -> google.protobuf.Timestamp
	176, // 16: spark.SigningResult.public_keys:type_name -> spark.SigningResult.PublicKeysEntry
	177, // 17: spark.SigningResult.signing_nonce_commitments:type_name -> spark.SigningResult.SigningNonceCommitmentsEntry
	178, // 18: spark.SigningResult.signature_shares:type_name -> spark.SigningResult.SignatureSharesEntry
	26,  // 19: spark.SigningResult.signing_keyshare:type_name -> spark.SigningKeyshare
	29,  // 20: spark.RenewLeafRequest.renew_node_timelock_signing_job:type_name -> spark.RenewNodeTimelockSigningJob
	30,  // 21: spark.RenewLeafRequest.renew_refund_timelock_signing_job:type_name -> spark.RenewRefundTimelockSigningJob
	31,  // 22: spark.RenewLeafRequest.renew_node_zero_timelock_signing_job:type_name -> spark.RenewNodeZeroTimelockSigningJob
	76,  // 23: spark.RenewNodeTimelockSigningJob.split_node_tx_signing_job:type_name -> spark.UserSignedTxSigningJob
	76,  // 24: spark.RenewNodeTimelockSigningJob.split_node_direct_tx_signing_job:type_name -> spark.UserSignedTxSigningJob
	76,  // 25: spark.RenewNodeTimelockSigningJob.node_tx_signing_job:type_name -> spark.UserSignedTxSigningJob
	76,  // 26: spark.RenewNodeTimelockSigningJob.refund_tx_signing_job:type_name -> spark.UserSignedTxSigningJob
	76,  // 27: spark.RenewNodeTimelockSigningJob.direct_node_tx_signing_job:type_name -> spark.UserSignedTxSigningJob
	76,  // 28: spark.RenewNodeTimelockSigningJob.direct_refund_tx_signing_job:type_name -> spark.UserSignedTxSigningJob
	76,  // 29: spark.RenewNodeTimelockSigningJob.direct_from_cpfp_refund_tx_signing_job:type_name -> spark.UserSignedTxSigningJob
	76,  // 30: spark.RenewRefundTimelockSigningJob.node_tx_signing_job:type_name -> spark.UserSignedTxSigningJob
	76,  // 31: spark.RenewRefundTimelockSigningJob.refund_tx_signing_job:type_name -> spark.UserSignedTxSigningJob
	76,  // 32: spark.RenewRefundTimelockSigningJob.direct_node_tx_signing_job:type_name -> spark.UserSignedTxSigningJob
	76,  // 33: spark.RenewRefundTimelockSigningJob.direct_refund_tx_signing_job:type_name -> spark.UserSignedTxSigningJob
	76,  // 34: spark.RenewRefundTimelockSigningJob.direct_from_cpfp_refund_tx_signing_job:type_name -> spark.UserSignedTxSigningJob
	76,  // 35: spark.RenewNodeZeroTimelockSigningJob.node_tx_signing_job:type_name -> spark.UserSignedTxSigningJob
	76,  // 36: spark.RenewNodeZeroTimelockSigningJob.refund_tx_signing_job:type_name -> spark.UserSignedTxSigningJob
	76,  // 37: spark.RenewNodeZeroTimelockSigningJob.direct_node_tx_signing_job:type_name -> spark.UserSignedTxSigningJob
	76,  // 38: spark.RenewNodeZeroTimelockSigningJob.direct_from_cpfp_refund_tx_signing_job:type_name -> spark.UserSignedTxSigningJob
	33,  // 39: spark.RenewLeafResponse.renew_node_timelock_result:type_name -> spark.RenewNodeTimelockResult
	34,  // 40: spark.RenewLeafResponse.renew_refund_timelock_result:type_name -> spark.RenewRefundTimelockResult
	35,  // 41: spark.RenewLeafResponse.renew_node_zero_timelock_result:type_name -> spark.RenewNodeZeroTimelockResult
	70,  // 42: spark.RenewNodeTimelockResult.split_node:type_name -> spark.TreeNode
	70,  // 43: spark.RenewNodeTimelockResult.node:type_name -> spark.TreeNode
	70,  // 44: spark.RenewRefundTimelockResult.node:type_name -> spark.TreeNode
	70,  // 45: spark.RenewNodeZeroTimelockResult.split_node:type_name -> spark.TreeNode
	70,  // 46: spark.RenewNodeZeroTimelockResult.node:type_name -> spark.TreeNode
	27,  // 47: spark.NodeSignatureShares.node_tx_signing_result:type_name -> spark.SigningResult
	27,  // 48: spark.NodeSignatureShares.refund_tx_signing_result:type_name -> spark.SigningResult
	27,  // 49: spark.NodeSignatureShares.direct_node_tx_signing_result:type_name -> spark.SigningResult
	27,  // 50: spark.NodeSignatureShares.direct_refund_tx_signing_result:type_name -> spark.SigningResult
	27,  // 51: spark.NodeSignatureShares.direct_from_cpfp_refund_tx_signing_result:type_name -> spark.SigningResult
	23,  // 52: spark.StartTreeCreationRequest.on_chain_utxo:type_name -> spark.UTXO
	25,  // 53: spark.StartTreeCreationRequest.root_tx_signing_job:type_name -> spark.SigningJob
	25,  // 54: spark.StartTreeCreationRequest.refund_tx_signing_job:type_name -> spark.SigningJob
	25,  // 55: spark.StartTreeCreationRequest.direct_root_tx_signing_job:type_name -> spark.SigningJob
	25,  // 56: spark.StartTreeCreationRequest.direct_refund_tx_signing_job:type_name -> spark.SigningJob
	25,  // 57: spark.StartTreeCreationRequest.direct_from_cpfp_refund_tx_signing_job:type_name -> spark.SigningJob
	36,  // 58: spark.StartTreeCreationResponse.root_node_signature_shares:type_name -> spark.NodeSignatureShares
	23,  // 59: spark.StartDepositTreeCreationRequest.on_chain_utxo:type_name -> spark.UTXO
	25,  // 60: spark.StartDepositTreeCreationRequest.root_tx_signing_job:type_name -> spark.SigningJob
	25,  // 61: spark.StartDepositTreeCreationRequest.refund_tx_signing_job:type_name -> spark.SigningJob
	25,  // 62: spark.StartDepositTreeCreationRequest.direct_root_tx_signing_job:type_name -> spark.SigningJob
	25,  // 63: spark.StartDepositTreeCreationRequest.direct_refund_tx_signing_job:type_name -> spark.SigningJob
	25,  // 64: spark.StartDepositTreeCreationRequest.direct_from_cpfp_refund_tx_signing_job:type_name -> spark.SigningJob
	36,  // 65: spark.StartDepositTreeCreationResponse.root_node_signature_shares:type_name -> spark.NodeSignatureShares
	42,  // 66: spark.TokenTransferInput.outputs_to_spend:type_name -> spark.TokenOutputToSpend
	44,  // 67: spark.TokenTransaction.mint_input:type_name -> spark.TokenMintInput
	43,  // 68: spark.TokenTransaction.transfer_input:type_name -> spark.TokenTransferInput
	45,  // 69: spark.TokenTransaction.create_input:type_name -> spark.TokenCreateInput
	46,  // 70: spark.TokenTransaction.token_outputs:type_name -> spark.TokenOutput
	0,   // 71: spark.TokenTransaction.network:type_name -> spark.Network
	48,  // 72: spark.TokenTransactionConfirmationMetadata.spent_token_outputs_metadata:type_name -> spark.SpentTokenOutputMetadata
	47,  // 73: spark.TokenTransactionWithStatus.token_transaction:type_name -> spark.TokenTransaction
	2,   // 74: spark.TokenTransactionWithStatus.status:type_name -> spark.TokenTransactionStatus
	49,  // 75: spark.TokenTransactionWithStatus.confirmation_metadata:type_name -> spark.TokenTransactionConfirmationMetadata
	51,  // 76: spark.TokenTransactionSignatures.owner_signatures:type_name -> spark.SignatureWithIndex
	47,  // 77: spark.StartTokenTransactionRequest.partial_token_transaction:type_name -> spark.TokenTransaction
	52,  // 78: spark.StartTokenTransactionRequest.token_transaction_signatures:type_name -> spark.TokenTransactionSignatures
	47,  // 79: spark.StartTokenTransactionResponse.final_token_transaction:type_name -> spark.TokenTransaction
	26,  // 80: spark.StartTokenTransactionResponse.keyshare_info:type_name -> spark.SigningKeyshare
	51,  // 81: spark.OperatorSpecificOwnerSignature.owner_signature:type_name -> spark.SignatureWithIndex
	55,  // 82: spark.OperatorSpecificOwnerSignature.payload:type_name -> spark.OperatorSpecificTokenTransactionSignablePayload
	47,  // 83: spark.SignTokenTransactionRequest.final_token_transaction:type_name -> spark.TokenTransaction
	56,  // 84: spark.SignTokenTransactionRequest.operator_specific_signatures:type_name -> spark.OperatorSpecificOwnerSignature
	58,  // 85: spark.SignTokenTransactionResponse.revocation_keyshares:type_name -> spark.KeyshareWithIndex
	47,  // 86: spark.FinalizeTokenTransactionRequest.final_token_transaction:type_name -> spark.TokenTransaction
	60,  // 87: spark.FinalizeTokenTransactionRequest.revocation_secrets:type_name -> spark.RevocationSecretWithIndex
	62,  // 88: spark.FreezeTokensRequest.freeze_tokens_payload:type_name -> spark.FreezeTokensPayload
	0,   // 89: spark.QueryTokenOutputsRequest.network:type_name -> spark.Network
	50,  // 90: spark.QueryTokenTransactionsResponse.token_transactions_with_status:type_name -> spark.TokenTransactionWithStatus
	46,  // 91: spark.OutputWithPreviousTransactionData.output:type_name -> spark.TokenOutput
	68,  // 92: spark.QueryTokenOutputsResponse.outputs_with_previous_transaction_data:type_name -> spark.OutputWithPreviousTransactionData
	26,  // 93: spark.TreeNode.signing_keyshare:type_name -> spark.SigningKeyshare
	0,   // 94: spark.TreeNode.network:type_name -> spark.Network
	190, // 95: spark.TreeNode.created_time:type_name -> google.protobuf.Timestamp
	190, // 96: spark.TreeNode.updated_time:type_name -> google.protobuf.Timestamp
	191, // 97: spark.FinalizeNodeSignaturesRequest.intent:type_name -> common.SignatureIntent
	37,  // 98: spark.FinalizeNodeSignaturesRequest.node_signatures:type_name -> spark.NodeSignatures
	70,  // 99: spark.FinalizeNodeSignaturesResponse.nodes:type_name -> spark.TreeNode
	25,  // 100: spark.LeafRefundTxSigningJob.refund_tx_signing_job:type_name -> spark.SigningJob
	25,  // 101: spark.LeafRefundTxSigningJob.direct_refund_tx_signing_job:type_name -> spark.SigningJob
	25,  // 102: spark.LeafRefundTxSigningJob.direct_from_cpfp_refund_tx_signing_job:type_name -> spark.SigningJob
	189, // 103: spark.UserSignedTxSigningJob.signing_nonce_commitment:type_name -> common.SigningCommitment
	99,  // 104: spark.UserSignedTxSigningJob.signing_commitments:type_name -> spark.SigningCommitments
	27,  // 105: spark.LeafRefundTxSigningResult.refund_tx_signing_result:type_name -> spark.SigningResult
	27,  // 106: spark.LeafRefundTxSigningResult.direct_refund_tx_signing_result:type_name -> spark.SigningResult
	27,  // 107: spark.LeafRefundTxSigningResult.direct_from_cpfp_refund_tx_signing_result:type_name -> spark.SigningResult
	76,  // 108: spark.StartUserSignedTransferRequest.leaves_to_send:type_name -> spark.UserSignedTxSigningJob
	190, // 109: spark.StartUserSignedTransferRequest.expiry_time:type_name -> google.protobuf.Timestamp
	76,  // 110: spark.StartUserSignedTransferRequest.direct_leaves_to_send:type_name -> spark.UserSignedTxSigningJob
	76,  // 111: spark.StartUserSignedTransferRequest.direct_from_cpfp_leaves_to_send:type_name -> spark.UserSignedTxSigningJob
	75,  // 112: spark.StartTransferRequest.leaves_to_send:type_name -> spark.LeafRefundTxSigningJob
	190, // 113: spark.StartTransferRequest.expiry_time:type_name -> google.protobuf.Timestamp
	81,  // 114: spark.StartTransferRequest.transfer_package:type_name -> spark.TransferPackage
	87,  // 115: spark.StartTransferResponse.transfer:type_name -> spark.Transfer
	77,  // 116: spark.StartTransferResponse.signing_results:type_name -> spark.LeafRefundTxSigningResult
	76,  // 117: spark.TransferPackage.leaves_to_send:type_name -> spark.UserSignedTxSigningJob
	179, // 118: spark.TransferPackage.key_tweak_package:type_name -> spark.TransferPackage.KeyTweakPackageEntry
	76,  // 119: spark.TransferPackage.direct_leaves_to_send:type_name -> spark.UserSignedTxSigningJob
	76,  // 120: spark.TransferPackage.direct_from_cpfp_leaves_to_send:type_name -> spark.UserSignedTxSigningJob
	83,  // 121: spark.SendLeafKeyTweaks.leaves_to_send:type_name -> spark.SendLeafKeyTweak
	73,  // 122: spark.SendLeafKeyTweak.secret_share_tweak:type_name -> spark.SecretShare
	180, // 123: spark.SendLeafKeyTweak.pubkey_shares_tweak:type_name -> spark.SendLeafKeyTweak.PubkeySharesTweakEntry
	83,  // 124: spark.FinalizeTransferRequest.leaves_to_send:type_name -> spark.SendLeafKeyTweak
	81,  // 125: spark.FinalizeTransferWithTransferPackageRequest.transfer_package:type_name -> spark.TransferPackage
	87,  // 126: spark.FinalizeTransferResponse.transfer:type_name -> spark.Transfer
	3,   // 127: spark.Transfer.status:type_name -> spark.TransferStatus
	190, // 128: spark.Transfer.expiry_time:type_name -> google.protobuf.Timestamp
	88,  // 129: spark.Transfer.leaves:type_name -> spark.TransferLeaf
	190, // 130: spark.Transfer.created_time:type_name -> google.protobuf.Timestamp
	190, // 131: spark.Transfer.updated_time:type_name -> google.protobuf.Timestamp
	4,   // 132: spark.Transfer.type:type_name -> spark.TransferType
	70,  // 133: spark.TransferLeaf.leaf:type_name -> spark.TreeNode
	4,   // 134: spark.TransferFilter.types:type_name -> spark.TransferType
	0,   // 135: spark.TransferFilter.network:type_name -> spark.Network
	3,   // 136: spark.TransferFilter.statuses:type_name -> spark.TransferStatus
	5,   // 137: spark.TransferFilter.order:type_name -> spark.Order
	87,  // 138: spark.QueryTransfersResponse.transfers:type_name -> spark.Transfer
	73,  // 139: spark.ClaimLeafKeyTweak.secret_share_tweak:type_name -> spark.SecretShare
	181, // 140: spark.ClaimLeafKeyTweak.pubkey_shares_tweak:type_name -> spark.ClaimLeafKeyTweak.PubkeySharesTweakEntry
	91,  // 141: spark.ClaimTransferTweakKeysRequest.leaves_to_receive:type_name -> spark.ClaimLeafKeyTweak
	75,  // 142: spark.ClaimTransferSignRefundsRequest.signing_jobs:type_name -> spark.LeafRefundTxSigningJob
	77,  // 143: spark.ClaimTransferSignRefundsResponse.signing_results:type_name -> spark.LeafRefundTxSigningResult
	73,  // 144: spark.StorePreimageShareRequest.preimage_share:type_name -> spark.SecretShare
	182, // 145: spark.RequestedSigningCommitments.signing_nonce_commitments:type_name -> spark.RequestedSigningCommitments.SigningNonceCommitmentsEntry
	96,  // 146: spark.GetSigningCommitmentsResponse.signing_commitments:type_name -> spark.RequestedSigningCommitments
	183, // 147: spark.SigningCommitments.signing_commitments:type_name -> spark.SigningCommitments.SigningCommitmentsEntry
	99,  // 148: spark.UserSignedRefund.signing_commitments:type_name -> spark.SigningCommitments
	189, // 149: spark.UserSignedRefund.user_signature_commitment:type_name -> common.SigningCommitment
	0,   // 150: spark.UserSignedRefund.network:type_name -> spark.Network
	101, // 151: spark.InvoiceAmount.invoice_amount_proof:type_name -> spark.InvoiceAmountProof
	102, // 152: spark.InitiatePreimageSwapRequest.invoice_amount:type_name -> spark.InvoiceAmount
	9,   // 153: spark.InitiatePreimageSwapRequest.reason:type_name -> spark.InitiatePreimageSwapRequest.Reason
	78,  // 154: spark.InitiatePreimageSwapRequest.transfer:type_name -> spark.StartUserSignedTransferRequest
	79,  // 155: spark.InitiatePreimageSwapRequest.transfer_request:type_name -> spark.StartTransferRequest
	87,  // 156: spark.InitiatePreimageSwapResponse.transfer:type_name -> spark.Transfer
	79,  // 157: spark.CooperativeExitRequest.transfer:type_name -> spark.StartTransferRequest
	87,  // 158: spark.CooperativeExitResponse.transfer:type_name -> spark.Transfer
	77,  // 159: spark.CooperativeExitResponse.signing_results:type_name -> spark.LeafRefundTxSigningResult
	79,  // 160: spark.CounterLeafSwapRequest.transfer:type_name -> spark.StartTransferRequest
	87,  // 161: spark.CounterLeafSwapResponse.transfer:type_name -> spark.Transfer
	77,  // 162: spark.CounterLeafSwapResponse.signing_results:type_name -> spark.LeafRefundTxSigningResult
	25,  // 163: spark.RefreshTimelockRequest.signing_jobs:type_name -> spark.SigningJob
	27,  // 164: spark.RefreshTimelockSigningResult.signing_result:type_name -> spark.SigningResult
	111, // 165: spark.RefreshTimelockResponse.signing_results:type_name -> spark.RefreshTimelockSigningResult
	25,  // 166: spark.ExtendLeafRequest.node_tx_signing_job:type_name -> spark.SigningJob
	25,  // 167: spark.ExtendLeafRequest.refund_tx_signing_job:type_name -> spark.SigningJob
	25,  // 168: spark.ExtendLeafRequest.direct_node_tx_signing_job:type_name -> spark.SigningJob
	25,  // 169: spark.ExtendLeafRequest.direct_refund_tx_signing_job:type_name -> spark.SigningJob
	25,  // 170: spark.ExtendLeafRequest.direct_from_cpfp_refund_tx_signing_job:type_name -> spark.SigningJob
	27,  // 171: spark.ExtendLeafSigningResult.signing_result:type_name -> spark.SigningResult
	114, // 172: spark.ExtendLeafResponse.node_tx_signing_result:type_name -> spark.ExtendLeafSigningResult
	114, // 173: spark.ExtendLeafResponse.refund_tx_signing_result:type_name -> spark.ExtendLeafSigningResult
	114, // 174: spark.ExtendLeafResponse.direct_node_tx_signing_result:type_name -> spark.ExtendLeafSigningResult
	114, // 175: spark.ExtendLeafResponse.direct_refund_tx_signing_result:type_name -> spark.ExtendLeafSigningResult
	114, // 176: spark.ExtendLeafResponse.direct_from_cpfp_refund_tx_signing_result:type_name -> spark.ExtendLeafSigningResult
	116, // 177: spark.AddressRequestNode.children:type_name -> spark.AddressRequestNode
	24,  // 178: spark.PrepareTreeAddressRequest.parent_node_output:type_name -> spark.NodeOutput
	23,  // 179: spark.PrepareTreeAddressRequest.on_chain_utxo:type_name -> spark.UTXO
	116, // 180: spark.PrepareTreeAddressRequest.node:type_name -> spark.AddressRequestNode
	19,  // 181: spark.AddressNode.address:type_name -> spark.Address
	118, // 182: spark.AddressNode.children:type_name -> spark.AddressNode
	118, // 183: spark.PrepareTreeAddressResponse.node:type_name -> spark.AddressNode
	25,  // 184: spark.CreationNode.node_tx_signing_job:type_name -> spark.SigningJob
	25,  // 185: spark.CreationNode.refund_tx_signing_job:type_name -> spark.SigningJob
	120, // 186: spark.CreationNode.children:type_name -> spark.CreationNode
	25,  // 187: spark.CreationNode.direct_node_tx_signing_job:type_name -> spark.SigningJob
	25,  // 188: spark.CreationNode.direct_refund_tx_signing_job:type_name -> spark.SigningJob
	25,  // 189: spark.CreationNode.direct_from_cpfp_refund_tx_signing_job:type_name -> spark.SigningJob
	24,  // 190: spark.CreateTreeRequest.parent_node_output:type_name -> spark.NodeOutput
	23,  // 191: spark.CreateTreeRequest.on_chain_utxo:type_name -> spark.UTXO
	120, // 192: spark.CreateTreeRequest.node:type_name -> spark.CreationNode
	27,  // 193: spark.CreationResponseNode.node_tx_signing_result:type_name -> spark.SigningResult
	27,  // 194: spark.CreationResponseNode.refund_tx_signing_result:type_name -> spark.SigningResult
	122, // 195: spark.CreationResponseNode.children:type_name -> spark.CreationResponseNode
	27,  // 196: spark.CreationResponseNode.direct_node_tx_signing_result:type_name -> spark.SigningResult
	27,  // 197: spark.CreationResponseNode.direct_refund_tx_signing_result:type_name -> spark.SigningResult
	27,  // 198: spark.CreationResponseNode.direct_from_cpfp_refund_tx_signing_result:type_name -> spark.SigningResult
	122, // 199: spark.CreateTreeResponse.node:type_name -> spark.CreationResponseNode
	184, // 200: spark.GetSigningOperatorListResponse.signing_operators:type_name -> spark.GetSigningOperatorListResponse.SigningOperatorsEntry
	100, // 201: spark.QueryUserSignedRefundsResponse.user_signed_refunds:type_name -> spark.UserSignedRefund
	87,  // 202: spark.QueryUserSignedRefundsResponse.transfer:type_name -> spark.Transfer
	6,   // 203: spark.PreimageRequestWithTransfer.status:type_name -> spark.PreimageRequestStatus
	190, // 204: spark.PreimageRequestWithTransfer.created_time:type_name -> google.protobuf.Timestamp
	87,  // 205: spark.PreimageRequestWithTransfer.transfer:type_name -> spark.Transfer
	6,   // 206: spark.QueryHtlcRequest.status:type_name -> spark.PreimageRequestStatus
	128, // 207: spark.QueryHtlcResponse.preimage_requests:type_name -> spark.PreimageRequestWithTransfer
	87,  // 208: spark.ProvidePreimageResponse.transfer:type_name -> spark.Transfer
	134, // 209: spark.QueryNodesRequest.node_ids:type_name -> spark.TreeNodeIds
	0,   // 210: spark.QueryNodesRequest.network:type_name -> spark.Network
	185, // 211: spark.QueryNodesResponse.nodes:type_name -> spark.QueryNodesResponse.NodesEntry
	87,  // 212: spark.CancelTransferResponse.transfer:type_name -> spark.Transfer
	0,   // 213: spark.QueryUnusedDepositAddressesRequest.network:type_name -> spark.Network
	0,   // 214: spark.QueryStaticDepositAddressesRequest.network:type_name -> spark.Network
	17,  // 215: spark.DepositAddressQueryResult.proof_of_possession:type_name -> spark.DepositAddressProof
	141, // 216: spark.QueryUnusedDepositAddressesResponse.deposit_addresses:type_name -> spark.DepositAddressQueryResult
	141, // 217: spark.QueryStaticDepositAddressesResponse.deposit_addresses:type_name -> spark.DepositAddressQueryResult
	0,   // 218: spark.QueryBalanceRequest.network:type_name -> spark.Network
	186, // 219: spark.QueryBalanceResponse.node_balances:type_name -> spark.QueryBalanceResponse.NodeBalancesEntry
	147, // 220: spark.SparkAddress.spark_invoice_fields:type_name -> spark.SparkInvoiceFields
	149, // 221: spark.SparkInvoiceFields.tokens_payment:type_name -> spark.TokensPayment
	148, // 222: spark.SparkInvoiceFields.sats_payment:type_name -> spark.SatsPayment
	190, // 223: spark.SparkInvoiceFields.expiry_time:type_name -> google.protobuf.Timestamp
	23,  // 224: spark.InitiateStaticDepositUtxoRefundRequest.on_chain_utxo:type_name -> spark.UTXO
	25,  // 225: spark.InitiateStaticDepositUtxoRefundRequest.refund_tx_signing_job:type_name -> spark.SigningJob
	27,  // 226: spark.InitiateStaticDepositUtxoRefundResponse.refund_tx_signing_result:type_name -> spark.SigningResult
	141, // 227: spark.InitiateStaticDepositUtxoRefundResponse.deposit_address:type_name -> spark.DepositAddressQueryResult
	23,  // 228: spark.InitiateUtxoSwapRequest.on_chain_utxo:type_name -> spark.UTXO
	7,   // 229: spark.InitiateUtxoSwapRequest.request_type:type_name -> spark.UtxoSwapRequestType
	79,  // 230: spark.InitiateUtxoSwapRequest.transfer:type_name -> spark.StartTransferRequest
	25,  // 231: spark.InitiateUtxoSwapRequest.spend_tx_signing_job:type_name -> spark.SigningJob
	27,  // 232: spark.InitiateUtxoSwapResponse.spend_tx_signing_result:type_name -> spark.SigningResult
	87,  // 233: spark.InitiateUtxoSwapResponse.transfer:type_name -> spark.Transfer
	141, // 234: spark.InitiateUtxoSwapResponse.deposit_address:type_name -> spark.DepositAddressQueryResult
	189, // 235: spark.ExitingTree.user_signing_commitment:type_name -> common.SigningCommitment
	27,  // 236: spark.ExitSingleNodeTreeSigningResult.signing_result:type_name -> spark.SigningResult
	154, // 237: spark.ExitSingleNodeTreesRequest.exiting_trees:type_name -> spark.ExitingTree
	156, // 238: spark.ExitSingleNodeTreesRequest.previous_outputs:type_name -> spark.BitcoinTransactionOutput
	155, // 239: spark.ExitSingleNodeTreesResponse.signing_results:type_name -> spark.ExitSingleNodeTreeSigningResult
	187, // 240: spark.QueryNodesDistributionResponse.node_distribution:type_name -> spark.QueryNodesDistributionResponse.NodeDistributionEntry
	188, // 241: spark.QueryNodesByValueResponse.nodes:type_name -> spark.QueryNodesByValueResponse.NodesEntry
	0,   // 242: spark.GetUtxosForAddressRequest.network:type_name -> spark.Network
	23,  // 243: spark.GetUtxosForAddressResponse.utxos:type_name -> spark.UTXO
	168, // 244: spark.QuerySparkInvoicesResponse.invoice_statuses:type_name -> spark.InvoiceResponse
	8,   // 245: spark.InvoiceResponse.status:type_name -> spark.InvoiceStatus
	169, // 246: spark.InvoiceResponse.sats_transfer:type_name -> spark.SatsTransfer
	170, // 247: spark.InvoiceResponse.token_transfer:type_name -> spark.TokenTransfer
	79,  // 248: spark.InitiateSwapPrimaryTransferRequest.transfer:type_name -> spark.StartTransferRequest
	173, // 249: spark.InitiateSwapPrimaryTransferRequest.adaptor_public_keys:type_name -> spark.AdaptorPublicKeyPackage
	87,  // 250: spark.InitiateSwapPrimaryTransferResponse.transfer:type_name -> spark.Transfer
	77,  // 251: spark.InitiateSwapPrimaryTransferResponse.signing_results:type_name -> spark.LeafRefundTxSigningResult
	189, // 252: spark.SigningResult.SigningNonceCommitmentsEntry.value:type_name -> common.SigningCommitment
	189, // 253: spark.RequestedSigningCommitments.SigningNonceCommitmentsEntry.value:type_name -> common.SigningCommitment
	189, // 254: spark.SigningCommitments.SigningCommitmentsEntry.value:type_name -> common.SigningCommitment
	124, // 255: spark.GetSigningOperatorListResponse.SigningOperatorsEntry.value:type_name -> spark.SigningOperatorInfo
	70,  // 256: spark.QueryNodesResponse.NodesEntry.value:type_name -> spark.TreeNode
	70,  // 257: spark.QueryNodesByValueResponse.NodesEntry.value:type_name -> spark.TreeNode
	18,  // 258: spark.SparkService.generate_deposit_address:input_type -> spark.GenerateDepositAddressRequest
	21,  // 259: spark.SparkService.generate_static_deposit_address:input_type -> spark.GenerateStaticDepositAddressRequest
	40,  // 260: spark.SparkService.start_deposit_tree_creation:input_type -> spark.StartDepositTreeCreationRequest
	38,  // 261: spark.SparkService.start_tree_creation:input_type -> spark.StartTreeCreationRequest
	71,  // 262: spark.SparkService.finalize_node_signatures:input_type -> spark.FinalizeNodeSignaturesRequest
	79,  // 263: spark.SparkService.start_transfer:input_type -> spark.StartTransferRequest
	84,  // 264: spark.SparkService.finalize_transfer:input_type -> spark.FinalizeTransferRequest
	85,  // 265: spark.SparkService.finalize_transfer_with_transfer_package:input_type -> spark.FinalizeTransferWithTransferPackageRequest
	137, // 266: spark.SparkService.cancel_transfer:input_type -> spark.CancelTransferRequest
	89,  // 267: spark.SparkService.query_pending_transfers:input_type -> spark.TransferFilter
	89,  // 268: spark.SparkService.query_all_transfers:input_type -> spark.TransferFilter
	92,  // 269: spark.SparkService.claim_transfer_tweak_keys:input_type -> spark.ClaimTransferTweakKeysRequest
	93,  // 270: spark.SparkService.claim_transfer_sign_refunds:input_type -> spark.ClaimTransferSignRefundsRequest
	95,  // 271: spark.SparkService.store_preimage_share:input_type -> spark.StorePreimageShareRequest
	97,  // 272: spark.SparkService.get_signing_commitments:input_type -> spark.GetSigningCommitmentsRequest
	106, // 273: spark.SparkService.cooperative_exit:input_type -> spark.CooperativeExitRequest
	103, // 274: spark.SparkService.initiate_preimage_swap:input_type -> spark.InitiatePreimageSwapRequest
	131, // 275: spark.SparkService.provide_preimage:input_type -> spark.ProvidePreimageRequest
	129, // 276: spark.SparkService.query_htlc:input_type -> spark.QueryHtlcRequest
	79,  // 277: spark.SparkService.start_leaf_swap:input_type -> spark.StartTransferRequest
	108, // 278: spark.SparkService.leaf_swap:input_type -> spark.CounterLeafSwapRequest
	108, // 279: spark.SparkService.counter_leaf_swap:input_type -> spark.CounterLeafSwapRequest
	110, // 280: spark.SparkService.refresh_timelock:input_type -> spark.RefreshTimelockRequest
	113, // 281: spark.SparkService.extend_leaf:input_type -> spark.ExtendLeafRequest
	28,  // 282: spark.SparkService.renew_leaf:input_type -> spark.RenewLeafRequest
	192, // 283: spark.SparkService.get_signing_operator_list:input_type -> google.protobuf.Empty
	135, // 284: spark.SparkService.query_nodes:input_type -> spark.QueryNodesRequest
	160, // 285: spark.SparkService.query_nodes_distribution:input_type -> spark.QueryNodesDistributionRequest
	162, // 286: spark.SparkService.query_nodes_by_value:input_type -> spark.QueryNodesByValueRequest
	144, // 287: spark.SparkService.query_balance:input_type -> spark.QueryBalanceRequest
	126, // 288: spark.SparkService.query_user_signed_refunds:input_type -> spark.QueryUserSignedRefundsRequest
	53,  // 289: spark.SparkService.start_token_transaction:input_type -> spark.StartTokenTransactionRequest
	57,  // 290: spark.SparkService.sign_token_transaction:input_type -> spark.SignTokenTransactionRequest
	61,  // 291: spark.SparkService.finalize_token_transaction:input_type -> spark.FinalizeTokenTransactionRequest
	63,  // 292: spark.SparkService.freeze_tokens:input_type -> spark.FreezeTokensRequest
	65,  // 293: spark.SparkService.query_token_outputs:input_type -> spark.QueryTokenOutputsRequest
	66,  // 294: spark.SparkService.query_token_transactions:input_type -> spark.QueryTokenTransactionsRequest
	133, // 295: spark.SparkService.return_lightning_payment:input_type -> spark.ReturnLightningPaymentRequest
	139, // 296: spark.SparkService.query_unused_deposit_addresses:input_type -> spark.QueryUnusedDepositAddressesRequest
	140, // 297: spark.SparkService.query_static_deposit_addresses:input_type -> spark.QueryStaticDepositAddressesRequest
	10,  // 298: spark.SparkService.subscribe_to_events:input_type -> spark.SubscribeToEventsRequest
	150, // 299: spark.SparkService.initiate_static_deposit_utxo_refund:input_type -> spark.InitiateStaticDepositUtxoRefundRequest
	152, // 300: spark.SparkService.initiate_utxo_swap:input_type -> spark.InitiateUtxoSwapRequest
	157, // 301: spark.SparkService.exit_single_node_trees:input_type -> spark.ExitSingleNodeTreesRequest
	106, // 302: spark.SparkService.cooperative_exit_v2:input_type -> spark.CooperativeExitRequest
	113, // 303: spark.SparkService.extend_leaf_v2:input_type -> spark.ExtendLeafRequest
	93,  // 304: spark.SparkService.claim_transfer_sign_refunds_v2:input_type -> spark.ClaimTransferSignRefundsRequest
	71,  // 305: spark.SparkService.finalize_node_signatures_v2:input_type -> spark.FinalizeNodeSignaturesRequest
	103, // 306: spark.SparkService.initiate_preimage_swap_v2:input_type -> spark.InitiatePreimageSwapRequest
	79,  // 307: spark.SparkService.start_leaf_swap_v2:input_type -> spark.StartTransferRequest
	108, // 308: spark.SparkService.counter_leaf_swap_v2:input_type -> spark.CounterLeafSwapRequest
	79,  // 309: spark.SparkService.start_transfer_v2:input_type -> spark.StartTransferRequest
	110, // 310: spark.SparkService.refresh_timelock_v2:input_type -> spark.RefreshTimelockRequest
	164, // 311: spark.SparkService.get_utxos_for_address:input_type -> spark.GetUtxosForAddressRequest
	166, // 312: spark.SparkService.query_spark_invoices:input_type -> spark.QuerySparkInvoicesRequest
	171, // 313: spark.SparkService.initiate_swap_primary_transfer:input_type -> spark.InitiateSwapPrimaryTransferRequest
	20,  // 314: spark.SparkService.generate_deposit_address:output_type -> spark.GenerateDepositAddressResponse
	22,  // 315: spark.SparkService.generate_static_deposit_address:output_type -> spark.GenerateStaticDepositAddressResponse
	41,  // 316: spark.SparkService.start_deposit_tree_creation:output_type -> spark.StartDepositTreeCreationResponse
	39,  // 317: spark.SparkService.start_tree_creation:output_type -> spark.StartTreeCreationResponse
	72,  // 318: spark.SparkService.finalize_node_signatures:output_type -> spark.FinalizeNodeSignaturesResponse
	80,  // 319: spark.SparkService.start_transfer:output_type -> spark.StartTransferResponse
	86,  // 320: spark.SparkService.finalize_transfer:output_type -> spark.FinalizeTransferResponse
	86,  // 321: spark.SparkService.finalize_transfer_with_transfer_package:output_type -> spark.FinalizeTransferResponse
	138, // 322: spark.SparkService.cancel_transfer:output_type -> spark.CancelTransferResponse
	90,  // 323: spark.SparkService.query_pending_transfers:output_type -> spark.QueryTransfersResponse
	90,  // 324: spark.SparkService.query_all_transfers:output_type -> spark.QueryTransfersResponse
	192, // 325: spark.SparkService.claim_transfer_tweak_keys:output_type -> google.protobuf.Empty
	94,  // 326: spark.SparkService.claim_transfer_sign_refunds:output_type -> spark.ClaimTransferSignRefundsResponse
	192, // 327: spark.SparkService.store_preimage_share:output_type -> google.protobuf.Empty
	98,  // 328: spark.SparkService.get_signing_commitments:output_type -> spark.GetSigningCommitmentsResponse
	107, // 329: spark.SparkService.cooperative_exit:output_type -> spark.CooperativeExitResponse
	104, // 330: spark.SparkService.initiate_preimage_swap:output_type -> spark.InitiatePreimageSwapResponse
	132, // 331: spark.SparkService.provide_preimage:output_type -> spark.ProvidePreimageResponse
	130, // 332: spark.SparkService.query_htlc:output_type -> spark.QueryHtlcResponse
	80,  // 333: spark.SparkService.start_leaf_swap:output_type -> spark.StartTransferResponse
	109, // 334: spark.SparkService.leaf_swap:output_type -> spark.CounterLeafSwapResponse
	109, // 335: spark.SparkService.counter_leaf_swap:output_type -> spark.CounterLeafSwapResponse
	112, // 336: spark.SparkService.refresh_timelock:output_type -> spark.RefreshTimelockResponse
	115, // 337: spark.SparkService.extend_leaf:output_type -> spark.ExtendLeafResponse
	32,  // 338: spark.SparkService.renew_leaf:output_type -> spark.RenewLeafResponse
	125, // 339: spark.SparkService.get_signing_operator_list:output_type -> spark.GetSigningOperatorListResponse
	136, // 340: spark.SparkService.query_nodes:output_type -> spark.QueryNodesResponse
	161, // 341: spark.SparkService.query_nodes_distribution:output_type -> spark.QueryNodesDistributionResponse
	163, // 342: spark.SparkService.query_nodes_by_value:output_type -> spark.QueryNodesByValueResponse
	145, // 343: spark.SparkService.query_balance:output_type -> spark.QueryBalanceResponse
	127, // 344: spark.SparkService.query_user_signed_refunds:output_type -> spark.QueryUserSignedRefundsResponse
	54,  // 345: spark.SparkService.start_token_transaction:output_type -> spark.StartTokenTransactionResponse
	59,  // 346: spark.SparkService.sign_token_transaction:output_type -> spark.SignTokenTransactionResponse
	192, // 347: spark.SparkService.finalize_token_transaction:output_type -> google.protobuf.Empty
	64,  // 348: spark.SparkService.freeze_tokens:output_type -> spark.FreezeTokensResponse
	69,  // 349: spark.SparkService.query_token_outputs:output_type -> spark.QueryTokenOutputsResponse
	67,  // 350: spark.SparkService.query_token_transactions:output_type -> spark.QueryTokenTransactionsResponse
	192, // 351: spark.SparkService.return_lightning_payment:output_type -> google.protobuf.Empty
	142, // 352: spark.SparkService.query_unused_deposit_addresses:output_type -> spark.QueryUnusedDepositAddressesResponse
	143, // 353: spark.SparkService.query_static_deposit_addresses:output_type -> spark.QueryStaticDepositAddressesResponse
	11,  // 354: spark.SparkService.subscribe_to_events:output_type -> spark.SubscribeToEventsResponse
	151, // 355: spark.SparkService.initiate_static_deposit_utxo_refund:output_type -> spark.InitiateStaticDepositUtxoRefundResponse
	153, // 356: spark.SparkService.initiate_utxo_swap:output_type -> spark.InitiateUtxoSwapResponse
	158, // 357: spark.SparkService.exit_single_node_trees:output_type -> spark.ExitSingleNodeTreesResponse
	107, // 358: spark.SparkService.cooperative_exit_v2:output_type -> spark.CooperativeExitResponse
	115, // 359: spark.SparkService.extend_leaf_v2:output_type -> spark.ExtendLeafResponse
	94,  // 360: spark.SparkService.claim_transfer_sign_refunds_v2:output_type -> spark.ClaimTransferSignRefundsResponse
	72,  // 361: spark.SparkService.finalize_node_signatures_v2:output_type -> spark.FinalizeNodeSignaturesResponse
	104, // 362: spark.SparkService.initiate_preimage_swap_v2:output_type -> spark.InitiatePreimageSwapResponse
	80,  // 363: spark.SparkService.start_leaf_swap_v2:output_type -> spark.StartTransferResponse
	109, // 364: spark.SparkService.counter_leaf_swap_v2:output_type -> spark.CounterLeafSwapResponse
	80,  // 365: spark.SparkService.start_transfer_v2:output_type -> spark.StartTransferResponse
	112, // 366: spark.SparkService.refresh_timelock_v2:output_type -> spark.RefreshTimelockResponse
	165, // 367: spark.SparkService.get_utxos_for_address:output_type -> spark.GetUtxosForAddressResponse
	167, // 368: spark.SparkService.query_spark_invoices:output_type -> spark.QuerySparkInvoicesResponse
	172, // 369: spark.SparkService.initiate_swap_primary_transfer:output_type -> spark.InitiateSwapPrimaryTransferResponse
	314, // [314:370] is the sub-list for method output_type
	258, // [258:314] is the sub-list for method input_type
	258, // [258:258] is the sub-list for extension type_name
	258, // [258:258] is the sub-list for extension extendee
	0,   // [0:258] is the sub-list for field type_name
}

func init() { file_spark_proto_init() }
func file_spark_proto_init() {
	if File_spark_proto != nil {
		return
	}
	file_spark_proto_msgTypes[1].OneofWrappers = []any{
		(*SubscribeToEventsResponse_Transfer)(nil),
		(*SubscribeToEventsResponse_Deposit)(nil),
		(*SubscribeToEventsResponse_Connected)(nil),
	}
	file_spark_proto_msgTypes[8].OneofWrappers = []any{}
	file_spark_proto_msgTypes[18].OneofWrappers = []any{
		(*RenewLeafRequest_RenewNodeTimelockSigningJob)(nil),
		(*RenewLeafRequest_RenewRefundTimelockSigningJob)(nil),
		(*RenewLeafRequest_RenewNodeZeroTimelockSigningJob)(nil),
	}
	file_spark_proto_msgTypes[22].OneofWrappers = []any{
		(*RenewLeafResponse_RenewNodeTimelockResult)(nil),
		(*RenewLeafResponse_RenewRefundTimelockResult)(nil),
		(*RenewLeafResponse_RenewNodeZeroTimelockResult)(nil),
	}
	file_spark_proto_msgTypes[34].OneofWrappers = []any{}
	file_spark_proto_msgTypes[35].OneofWrappers = []any{}
	file_spark_proto_msgTypes[36].OneofWrappers = []any{}
	file_spark_proto_msgTypes[37].OneofWrappers = []any{
		(*TokenTransaction_MintInput)(nil),
		(*TokenTransaction_TransferInput)(nil),
		(*TokenTransaction_CreateInput)(nil),
	}
	file_spark_proto_msgTypes[52].OneofWrappers = []any{}
	file_spark_proto_msgTypes[60].OneofWrappers = []any{}
	file_spark_proto_msgTypes[79].OneofWrappers = []any{
		(*TransferFilter_ReceiverIdentityPublicKey)(nil),
		(*TransferFilter_SenderIdentityPublicKey)(nil),
		(*TransferFilter_SenderOrReceiverIdentityPublicKey)(nil),
	}
	file_spark_proto_msgTypes[107].OneofWrappers = []any{
		(*PrepareTreeAddressRequest_ParentNodeOutput)(nil),
		(*PrepareTreeAddressRequest_OnChainUtxo)(nil),
	}
	file_spark_proto_msgTypes[111].OneofWrappers = []any{
		(*CreateTreeRequest_ParentNodeOutput)(nil),
		(*CreateTreeRequest_OnChainUtxo)(nil),
	}
	file_spark_proto_msgTypes[118].OneofWrappers = []any{}
	file_spark_proto_msgTypes[119].OneofWrappers = []any{}
	file_spark_proto_msgTypes[125].OneofWrappers = []any{
		(*QueryNodesRequest_OwnerIdentityPubkey)(nil),
		(*QueryNodesRequest_NodeIds)(nil),
	}
	file_spark_proto_msgTypes[130].OneofWrappers = []any{}
	file_spark_proto_msgTypes[131].OneofWrappers = []any{}
	file_spark_proto_msgTypes[136].OneofWrappers = []any{}
	file_spark_proto_msgTypes[137].OneofWrappers = []any{
		(*SparkInvoiceFields_TokensPayment)(nil),
		(*SparkInvoiceFields_SatsPayment)(nil),
	}
	file_spark_proto_msgTypes[138].OneofWrappers = []any{}
	file_spark_proto_msgTypes[139].OneofWrappers = []any{}
	file_spark_proto_msgTypes[142].OneofWrappers = []any{
		(*InitiateUtxoSwapRequest_CreditAmountSats)(nil),
		(*InitiateUtxoSwapRequest_MaxFeeSats)(nil),
	}
	file_spark_proto_msgTypes[158].OneofWrappers = []any{
		(*InvoiceResponse_SatsTransfer)(nil),
		(*InvoiceResponse_TokenTransfer)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_spark_proto_rawDesc), len(file_spark_proto_rawDesc)),
			NumEnums:      10,
			NumMessages:   179,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_spark_proto_goTypes,
		DependencyIndexes: file_spark_proto_depIdxs,
		EnumInfos:         file_spark_proto_enumTypes,
		MessageInfos:      file_spark_proto_msgTypes,
	}.Build()
	File_spark_proto = out.File
	file_spark_proto_goTypes = nil
	file_spark_proto_depIdxs = nil
}
