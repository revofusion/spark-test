// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
	"github.com/lightsparkdev/spark/common/keys"
	"github.com/lightsparkdev/spark/so/ent/paymentintent"
	"github.com/lightsparkdev/spark/so/ent/predicate"
	"github.com/lightsparkdev/spark/so/ent/schema/schematype"
	"github.com/lightsparkdev/spark/so/ent/sparkinvoice"
	"github.com/lightsparkdev/spark/so/ent/tokencreate"
	"github.com/lightsparkdev/spark/so/ent/tokenmint"
	"github.com/lightsparkdev/spark/so/ent/tokenoutput"
	"github.com/lightsparkdev/spark/so/ent/tokentransaction"
	"github.com/lightsparkdev/spark/so/ent/tokentransactionpeersignature"
)

// TokenTransactionUpdate is the builder for updating TokenTransaction entities.
type TokenTransactionUpdate struct {
	config
	hooks     []Hook
	mutation  *TokenTransactionMutation
	modifiers []func(*sql.UpdateBuilder)
}

// Where appends a list predicates to the TokenTransactionUpdate builder.
func (ttu *TokenTransactionUpdate) Where(ps ...predicate.TokenTransaction) *TokenTransactionUpdate {
	ttu.mutation.Where(ps...)
	return ttu
}

// SetUpdateTime sets the "update_time" field.
func (ttu *TokenTransactionUpdate) SetUpdateTime(t time.Time) *TokenTransactionUpdate {
	ttu.mutation.SetUpdateTime(t)
	return ttu
}

// SetPartialTokenTransactionHash sets the "partial_token_transaction_hash" field.
func (ttu *TokenTransactionUpdate) SetPartialTokenTransactionHash(b []byte) *TokenTransactionUpdate {
	ttu.mutation.SetPartialTokenTransactionHash(b)
	return ttu
}

// SetFinalizedTokenTransactionHash sets the "finalized_token_transaction_hash" field.
func (ttu *TokenTransactionUpdate) SetFinalizedTokenTransactionHash(b []byte) *TokenTransactionUpdate {
	ttu.mutation.SetFinalizedTokenTransactionHash(b)
	return ttu
}

// SetOperatorSignature sets the "operator_signature" field.
func (ttu *TokenTransactionUpdate) SetOperatorSignature(b []byte) *TokenTransactionUpdate {
	ttu.mutation.SetOperatorSignature(b)
	return ttu
}

// ClearOperatorSignature clears the value of the "operator_signature" field.
func (ttu *TokenTransactionUpdate) ClearOperatorSignature() *TokenTransactionUpdate {
	ttu.mutation.ClearOperatorSignature()
	return ttu
}

// SetStatus sets the "status" field.
func (ttu *TokenTransactionUpdate) SetStatus(sts schematype.TokenTransactionStatus) *TokenTransactionUpdate {
	ttu.mutation.SetStatus(sts)
	return ttu
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (ttu *TokenTransactionUpdate) SetNillableStatus(sts *schematype.TokenTransactionStatus) *TokenTransactionUpdate {
	if sts != nil {
		ttu.SetStatus(*sts)
	}
	return ttu
}

// ClearStatus clears the value of the "status" field.
func (ttu *TokenTransactionUpdate) ClearStatus() *TokenTransactionUpdate {
	ttu.mutation.ClearStatus()
	return ttu
}

// SetCoordinatorPublicKey sets the "coordinator_public_key" field.
func (ttu *TokenTransactionUpdate) SetCoordinatorPublicKey(k keys.Public) *TokenTransactionUpdate {
	ttu.mutation.SetCoordinatorPublicKey(k)
	return ttu
}

// SetNillableCoordinatorPublicKey sets the "coordinator_public_key" field if the given value is not nil.
func (ttu *TokenTransactionUpdate) SetNillableCoordinatorPublicKey(k *keys.Public) *TokenTransactionUpdate {
	if k != nil {
		ttu.SetCoordinatorPublicKey(*k)
	}
	return ttu
}

// ClearCoordinatorPublicKey clears the value of the "coordinator_public_key" field.
func (ttu *TokenTransactionUpdate) ClearCoordinatorPublicKey() *TokenTransactionUpdate {
	ttu.mutation.ClearCoordinatorPublicKey()
	return ttu
}

// SetClientCreatedTimestamp sets the "client_created_timestamp" field.
func (ttu *TokenTransactionUpdate) SetClientCreatedTimestamp(t time.Time) *TokenTransactionUpdate {
	ttu.mutation.SetClientCreatedTimestamp(t)
	return ttu
}

// SetNillableClientCreatedTimestamp sets the "client_created_timestamp" field if the given value is not nil.
func (ttu *TokenTransactionUpdate) SetNillableClientCreatedTimestamp(t *time.Time) *TokenTransactionUpdate {
	if t != nil {
		ttu.SetClientCreatedTimestamp(*t)
	}
	return ttu
}

// ClearClientCreatedTimestamp clears the value of the "client_created_timestamp" field.
func (ttu *TokenTransactionUpdate) ClearClientCreatedTimestamp() *TokenTransactionUpdate {
	ttu.mutation.ClearClientCreatedTimestamp()
	return ttu
}

// SetVersion sets the "version" field.
func (ttu *TokenTransactionUpdate) SetVersion(stv schematype.TokenTransactionVersion) *TokenTransactionUpdate {
	ttu.mutation.ResetVersion()
	ttu.mutation.SetVersion(stv)
	return ttu
}

// SetNillableVersion sets the "version" field if the given value is not nil.
func (ttu *TokenTransactionUpdate) SetNillableVersion(stv *schematype.TokenTransactionVersion) *TokenTransactionUpdate {
	if stv != nil {
		ttu.SetVersion(*stv)
	}
	return ttu
}

// AddVersion adds stv to the "version" field.
func (ttu *TokenTransactionUpdate) AddVersion(stv schematype.TokenTransactionVersion) *TokenTransactionUpdate {
	ttu.mutation.AddVersion(stv)
	return ttu
}

// AddSpentOutputIDs adds the "spent_output" edge to the TokenOutput entity by IDs.
func (ttu *TokenTransactionUpdate) AddSpentOutputIDs(ids ...uuid.UUID) *TokenTransactionUpdate {
	ttu.mutation.AddSpentOutputIDs(ids...)
	return ttu
}

// AddSpentOutput adds the "spent_output" edges to the TokenOutput entity.
func (ttu *TokenTransactionUpdate) AddSpentOutput(t ...*TokenOutput) *TokenTransactionUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttu.AddSpentOutputIDs(ids...)
}

// AddSpentOutputV2IDs adds the "spent_output_v2" edge to the TokenOutput entity by IDs.
func (ttu *TokenTransactionUpdate) AddSpentOutputV2IDs(ids ...uuid.UUID) *TokenTransactionUpdate {
	ttu.mutation.AddSpentOutputV2IDs(ids...)
	return ttu
}

// AddSpentOutputV2 adds the "spent_output_v2" edges to the TokenOutput entity.
func (ttu *TokenTransactionUpdate) AddSpentOutputV2(t ...*TokenOutput) *TokenTransactionUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttu.AddSpentOutputV2IDs(ids...)
}

// AddCreatedOutputIDs adds the "created_output" edge to the TokenOutput entity by IDs.
func (ttu *TokenTransactionUpdate) AddCreatedOutputIDs(ids ...uuid.UUID) *TokenTransactionUpdate {
	ttu.mutation.AddCreatedOutputIDs(ids...)
	return ttu
}

// AddCreatedOutput adds the "created_output" edges to the TokenOutput entity.
func (ttu *TokenTransactionUpdate) AddCreatedOutput(t ...*TokenOutput) *TokenTransactionUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttu.AddCreatedOutputIDs(ids...)
}

// SetMintID sets the "mint" edge to the TokenMint entity by ID.
func (ttu *TokenTransactionUpdate) SetMintID(id uuid.UUID) *TokenTransactionUpdate {
	ttu.mutation.SetMintID(id)
	return ttu
}

// SetNillableMintID sets the "mint" edge to the TokenMint entity by ID if the given value is not nil.
func (ttu *TokenTransactionUpdate) SetNillableMintID(id *uuid.UUID) *TokenTransactionUpdate {
	if id != nil {
		ttu = ttu.SetMintID(*id)
	}
	return ttu
}

// SetMint sets the "mint" edge to the TokenMint entity.
func (ttu *TokenTransactionUpdate) SetMint(t *TokenMint) *TokenTransactionUpdate {
	return ttu.SetMintID(t.ID)
}

// SetCreateID sets the "create" edge to the TokenCreate entity by ID.
func (ttu *TokenTransactionUpdate) SetCreateID(id uuid.UUID) *TokenTransactionUpdate {
	ttu.mutation.SetCreateID(id)
	return ttu
}

// SetNillableCreateID sets the "create" edge to the TokenCreate entity by ID if the given value is not nil.
func (ttu *TokenTransactionUpdate) SetNillableCreateID(id *uuid.UUID) *TokenTransactionUpdate {
	if id != nil {
		ttu = ttu.SetCreateID(*id)
	}
	return ttu
}

// SetCreate sets the "create" edge to the TokenCreate entity.
func (ttu *TokenTransactionUpdate) SetCreate(t *TokenCreate) *TokenTransactionUpdate {
	return ttu.SetCreateID(t.ID)
}

// SetPaymentIntentID sets the "payment_intent" edge to the PaymentIntent entity by ID.
func (ttu *TokenTransactionUpdate) SetPaymentIntentID(id uuid.UUID) *TokenTransactionUpdate {
	ttu.mutation.SetPaymentIntentID(id)
	return ttu
}

// SetNillablePaymentIntentID sets the "payment_intent" edge to the PaymentIntent entity by ID if the given value is not nil.
func (ttu *TokenTransactionUpdate) SetNillablePaymentIntentID(id *uuid.UUID) *TokenTransactionUpdate {
	if id != nil {
		ttu = ttu.SetPaymentIntentID(*id)
	}
	return ttu
}

// SetPaymentIntent sets the "payment_intent" edge to the PaymentIntent entity.
func (ttu *TokenTransactionUpdate) SetPaymentIntent(p *PaymentIntent) *TokenTransactionUpdate {
	return ttu.SetPaymentIntentID(p.ID)
}

// AddPeerSignatureIDs adds the "peer_signatures" edge to the TokenTransactionPeerSignature entity by IDs.
func (ttu *TokenTransactionUpdate) AddPeerSignatureIDs(ids ...uuid.UUID) *TokenTransactionUpdate {
	ttu.mutation.AddPeerSignatureIDs(ids...)
	return ttu
}

// AddPeerSignatures adds the "peer_signatures" edges to the TokenTransactionPeerSignature entity.
func (ttu *TokenTransactionUpdate) AddPeerSignatures(t ...*TokenTransactionPeerSignature) *TokenTransactionUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttu.AddPeerSignatureIDs(ids...)
}

// AddSparkInvoiceIDs adds the "spark_invoice" edge to the SparkInvoice entity by IDs.
func (ttu *TokenTransactionUpdate) AddSparkInvoiceIDs(ids ...uuid.UUID) *TokenTransactionUpdate {
	ttu.mutation.AddSparkInvoiceIDs(ids...)
	return ttu
}

// AddSparkInvoice adds the "spark_invoice" edges to the SparkInvoice entity.
func (ttu *TokenTransactionUpdate) AddSparkInvoice(s ...*SparkInvoice) *TokenTransactionUpdate {
	ids := make([]uuid.UUID, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return ttu.AddSparkInvoiceIDs(ids...)
}

// Mutation returns the TokenTransactionMutation object of the builder.
func (ttu *TokenTransactionUpdate) Mutation() *TokenTransactionMutation {
	return ttu.mutation
}

// ClearSpentOutput clears all "spent_output" edges to the TokenOutput entity.
func (ttu *TokenTransactionUpdate) ClearSpentOutput() *TokenTransactionUpdate {
	ttu.mutation.ClearSpentOutput()
	return ttu
}

// RemoveSpentOutputIDs removes the "spent_output" edge to TokenOutput entities by IDs.
func (ttu *TokenTransactionUpdate) RemoveSpentOutputIDs(ids ...uuid.UUID) *TokenTransactionUpdate {
	ttu.mutation.RemoveSpentOutputIDs(ids...)
	return ttu
}

// RemoveSpentOutput removes "spent_output" edges to TokenOutput entities.
func (ttu *TokenTransactionUpdate) RemoveSpentOutput(t ...*TokenOutput) *TokenTransactionUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttu.RemoveSpentOutputIDs(ids...)
}

// ClearSpentOutputV2 clears all "spent_output_v2" edges to the TokenOutput entity.
func (ttu *TokenTransactionUpdate) ClearSpentOutputV2() *TokenTransactionUpdate {
	ttu.mutation.ClearSpentOutputV2()
	return ttu
}

// RemoveSpentOutputV2IDs removes the "spent_output_v2" edge to TokenOutput entities by IDs.
func (ttu *TokenTransactionUpdate) RemoveSpentOutputV2IDs(ids ...uuid.UUID) *TokenTransactionUpdate {
	ttu.mutation.RemoveSpentOutputV2IDs(ids...)
	return ttu
}

// RemoveSpentOutputV2 removes "spent_output_v2" edges to TokenOutput entities.
func (ttu *TokenTransactionUpdate) RemoveSpentOutputV2(t ...*TokenOutput) *TokenTransactionUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttu.RemoveSpentOutputV2IDs(ids...)
}

// ClearCreatedOutput clears all "created_output" edges to the TokenOutput entity.
func (ttu *TokenTransactionUpdate) ClearCreatedOutput() *TokenTransactionUpdate {
	ttu.mutation.ClearCreatedOutput()
	return ttu
}

// RemoveCreatedOutputIDs removes the "created_output" edge to TokenOutput entities by IDs.
func (ttu *TokenTransactionUpdate) RemoveCreatedOutputIDs(ids ...uuid.UUID) *TokenTransactionUpdate {
	ttu.mutation.RemoveCreatedOutputIDs(ids...)
	return ttu
}

// RemoveCreatedOutput removes "created_output" edges to TokenOutput entities.
func (ttu *TokenTransactionUpdate) RemoveCreatedOutput(t ...*TokenOutput) *TokenTransactionUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttu.RemoveCreatedOutputIDs(ids...)
}

// ClearMint clears the "mint" edge to the TokenMint entity.
func (ttu *TokenTransactionUpdate) ClearMint() *TokenTransactionUpdate {
	ttu.mutation.ClearMint()
	return ttu
}

// ClearCreate clears the "create" edge to the TokenCreate entity.
func (ttu *TokenTransactionUpdate) ClearCreate() *TokenTransactionUpdate {
	ttu.mutation.ClearCreate()
	return ttu
}

// ClearPaymentIntent clears the "payment_intent" edge to the PaymentIntent entity.
func (ttu *TokenTransactionUpdate) ClearPaymentIntent() *TokenTransactionUpdate {
	ttu.mutation.ClearPaymentIntent()
	return ttu
}

// ClearPeerSignatures clears all "peer_signatures" edges to the TokenTransactionPeerSignature entity.
func (ttu *TokenTransactionUpdate) ClearPeerSignatures() *TokenTransactionUpdate {
	ttu.mutation.ClearPeerSignatures()
	return ttu
}

// RemovePeerSignatureIDs removes the "peer_signatures" edge to TokenTransactionPeerSignature entities by IDs.
func (ttu *TokenTransactionUpdate) RemovePeerSignatureIDs(ids ...uuid.UUID) *TokenTransactionUpdate {
	ttu.mutation.RemovePeerSignatureIDs(ids...)
	return ttu
}

// RemovePeerSignatures removes "peer_signatures" edges to TokenTransactionPeerSignature entities.
func (ttu *TokenTransactionUpdate) RemovePeerSignatures(t ...*TokenTransactionPeerSignature) *TokenTransactionUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttu.RemovePeerSignatureIDs(ids...)
}

// ClearSparkInvoice clears all "spark_invoice" edges to the SparkInvoice entity.
func (ttu *TokenTransactionUpdate) ClearSparkInvoice() *TokenTransactionUpdate {
	ttu.mutation.ClearSparkInvoice()
	return ttu
}

// RemoveSparkInvoiceIDs removes the "spark_invoice" edge to SparkInvoice entities by IDs.
func (ttu *TokenTransactionUpdate) RemoveSparkInvoiceIDs(ids ...uuid.UUID) *TokenTransactionUpdate {
	ttu.mutation.RemoveSparkInvoiceIDs(ids...)
	return ttu
}

// RemoveSparkInvoice removes "spark_invoice" edges to SparkInvoice entities.
func (ttu *TokenTransactionUpdate) RemoveSparkInvoice(s ...*SparkInvoice) *TokenTransactionUpdate {
	ids := make([]uuid.UUID, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return ttu.RemoveSparkInvoiceIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (ttu *TokenTransactionUpdate) Save(ctx context.Context) (int, error) {
	if err := ttu.defaults(); err != nil {
		return 0, err
	}
	return withHooks(ctx, ttu.sqlSave, ttu.mutation, ttu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (ttu *TokenTransactionUpdate) SaveX(ctx context.Context) int {
	affected, err := ttu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (ttu *TokenTransactionUpdate) Exec(ctx context.Context) error {
	_, err := ttu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ttu *TokenTransactionUpdate) ExecX(ctx context.Context) {
	if err := ttu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (ttu *TokenTransactionUpdate) defaults() error {
	if _, ok := ttu.mutation.UpdateTime(); !ok {
		if tokentransaction.UpdateDefaultUpdateTime == nil {
			return fmt.Errorf("ent: uninitialized tokentransaction.UpdateDefaultUpdateTime (forgotten import ent/runtime?)")
		}
		v := tokentransaction.UpdateDefaultUpdateTime()
		ttu.mutation.SetUpdateTime(v)
	}
	return nil
}

// check runs all checks and user-defined validators on the builder.
func (ttu *TokenTransactionUpdate) check() error {
	if v, ok := ttu.mutation.PartialTokenTransactionHash(); ok {
		if err := tokentransaction.PartialTokenTransactionHashValidator(v); err != nil {
			return &ValidationError{Name: "partial_token_transaction_hash", err: fmt.Errorf(`ent: validator failed for field "TokenTransaction.partial_token_transaction_hash": %w`, err)}
		}
	}
	if v, ok := ttu.mutation.FinalizedTokenTransactionHash(); ok {
		if err := tokentransaction.FinalizedTokenTransactionHashValidator(v); err != nil {
			return &ValidationError{Name: "finalized_token_transaction_hash", err: fmt.Errorf(`ent: validator failed for field "TokenTransaction.finalized_token_transaction_hash": %w`, err)}
		}
	}
	if v, ok := ttu.mutation.Status(); ok {
		if err := tokentransaction.StatusValidator(v); err != nil {
			return &ValidationError{Name: "status", err: fmt.Errorf(`ent: validator failed for field "TokenTransaction.status": %w`, err)}
		}
	}
	if v, ok := ttu.mutation.Version(); ok {
		if err := tokentransaction.VersionValidator(int(v)); err != nil {
			return &ValidationError{Name: "version", err: fmt.Errorf(`ent: validator failed for field "TokenTransaction.version": %w`, err)}
		}
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (ttu *TokenTransactionUpdate) Modify(modifiers ...func(u *sql.UpdateBuilder)) *TokenTransactionUpdate {
	ttu.modifiers = append(ttu.modifiers, modifiers...)
	return ttu
}

func (ttu *TokenTransactionUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := ttu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(tokentransaction.Table, tokentransaction.Columns, sqlgraph.NewFieldSpec(tokentransaction.FieldID, field.TypeUUID))
	if ps := ttu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := ttu.mutation.UpdateTime(); ok {
		_spec.SetField(tokentransaction.FieldUpdateTime, field.TypeTime, value)
	}
	if value, ok := ttu.mutation.PartialTokenTransactionHash(); ok {
		_spec.SetField(tokentransaction.FieldPartialTokenTransactionHash, field.TypeBytes, value)
	}
	if value, ok := ttu.mutation.FinalizedTokenTransactionHash(); ok {
		_spec.SetField(tokentransaction.FieldFinalizedTokenTransactionHash, field.TypeBytes, value)
	}
	if value, ok := ttu.mutation.OperatorSignature(); ok {
		_spec.SetField(tokentransaction.FieldOperatorSignature, field.TypeBytes, value)
	}
	if ttu.mutation.OperatorSignatureCleared() {
		_spec.ClearField(tokentransaction.FieldOperatorSignature, field.TypeBytes)
	}
	if value, ok := ttu.mutation.Status(); ok {
		_spec.SetField(tokentransaction.FieldStatus, field.TypeEnum, value)
	}
	if ttu.mutation.StatusCleared() {
		_spec.ClearField(tokentransaction.FieldStatus, field.TypeEnum)
	}
	if ttu.mutation.ExpiryTimeCleared() {
		_spec.ClearField(tokentransaction.FieldExpiryTime, field.TypeTime)
	}
	if value, ok := ttu.mutation.CoordinatorPublicKey(); ok {
		_spec.SetField(tokentransaction.FieldCoordinatorPublicKey, field.TypeBytes, value)
	}
	if ttu.mutation.CoordinatorPublicKeyCleared() {
		_spec.ClearField(tokentransaction.FieldCoordinatorPublicKey, field.TypeBytes)
	}
	if value, ok := ttu.mutation.ClientCreatedTimestamp(); ok {
		_spec.SetField(tokentransaction.FieldClientCreatedTimestamp, field.TypeTime, value)
	}
	if ttu.mutation.ClientCreatedTimestampCleared() {
		_spec.ClearField(tokentransaction.FieldClientCreatedTimestamp, field.TypeTime)
	}
	if value, ok := ttu.mutation.Version(); ok {
		_spec.SetField(tokentransaction.FieldVersion, field.TypeInt, value)
	}
	if value, ok := ttu.mutation.AddedVersion(); ok {
		_spec.AddField(tokentransaction.FieldVersion, field.TypeInt, value)
	}
	if ttu.mutation.SpentOutputCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.SpentOutputTable,
			Columns: []string{tokentransaction.SpentOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttu.mutation.RemovedSpentOutputIDs(); len(nodes) > 0 && !ttu.mutation.SpentOutputCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.SpentOutputTable,
			Columns: []string{tokentransaction.SpentOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttu.mutation.SpentOutputIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.SpentOutputTable,
			Columns: []string{tokentransaction.SpentOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ttu.mutation.SpentOutputV2Cleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   tokentransaction.SpentOutputV2Table,
			Columns: tokentransaction.SpentOutputV2PrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttu.mutation.RemovedSpentOutputV2IDs(); len(nodes) > 0 && !ttu.mutation.SpentOutputV2Cleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   tokentransaction.SpentOutputV2Table,
			Columns: tokentransaction.SpentOutputV2PrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttu.mutation.SpentOutputV2IDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   tokentransaction.SpentOutputV2Table,
			Columns: tokentransaction.SpentOutputV2PrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ttu.mutation.CreatedOutputCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.CreatedOutputTable,
			Columns: []string{tokentransaction.CreatedOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttu.mutation.RemovedCreatedOutputIDs(); len(nodes) > 0 && !ttu.mutation.CreatedOutputCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.CreatedOutputTable,
			Columns: []string{tokentransaction.CreatedOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttu.mutation.CreatedOutputIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.CreatedOutputTable,
			Columns: []string{tokentransaction.CreatedOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ttu.mutation.MintCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   tokentransaction.MintTable,
			Columns: []string{tokentransaction.MintColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenmint.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttu.mutation.MintIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   tokentransaction.MintTable,
			Columns: []string{tokentransaction.MintColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenmint.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ttu.mutation.CreateCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   tokentransaction.CreateTable,
			Columns: []string{tokentransaction.CreateColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokencreate.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttu.mutation.CreateIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   tokentransaction.CreateTable,
			Columns: []string{tokentransaction.CreateColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokencreate.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ttu.mutation.PaymentIntentCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   tokentransaction.PaymentIntentTable,
			Columns: []string{tokentransaction.PaymentIntentColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(paymentintent.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttu.mutation.PaymentIntentIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   tokentransaction.PaymentIntentTable,
			Columns: []string{tokentransaction.PaymentIntentColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(paymentintent.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ttu.mutation.PeerSignaturesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tokentransaction.PeerSignaturesTable,
			Columns: []string{tokentransaction.PeerSignaturesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokentransactionpeersignature.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttu.mutation.RemovedPeerSignaturesIDs(); len(nodes) > 0 && !ttu.mutation.PeerSignaturesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tokentransaction.PeerSignaturesTable,
			Columns: []string{tokentransaction.PeerSignaturesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokentransactionpeersignature.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttu.mutation.PeerSignaturesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tokentransaction.PeerSignaturesTable,
			Columns: []string{tokentransaction.PeerSignaturesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokentransactionpeersignature.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ttu.mutation.SparkInvoiceCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   tokentransaction.SparkInvoiceTable,
			Columns: tokentransaction.SparkInvoicePrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sparkinvoice.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttu.mutation.RemovedSparkInvoiceIDs(); len(nodes) > 0 && !ttu.mutation.SparkInvoiceCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   tokentransaction.SparkInvoiceTable,
			Columns: tokentransaction.SparkInvoicePrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sparkinvoice.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttu.mutation.SparkInvoiceIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   tokentransaction.SparkInvoiceTable,
			Columns: tokentransaction.SparkInvoicePrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sparkinvoice.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.AddModifiers(ttu.modifiers...)
	if n, err = sqlgraph.UpdateNodes(ctx, ttu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{tokentransaction.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	ttu.mutation.done = true
	return n, nil
}

// TokenTransactionUpdateOne is the builder for updating a single TokenTransaction entity.
type TokenTransactionUpdateOne struct {
	config
	fields    []string
	hooks     []Hook
	mutation  *TokenTransactionMutation
	modifiers []func(*sql.UpdateBuilder)
}

// SetUpdateTime sets the "update_time" field.
func (ttuo *TokenTransactionUpdateOne) SetUpdateTime(t time.Time) *TokenTransactionUpdateOne {
	ttuo.mutation.SetUpdateTime(t)
	return ttuo
}

// SetPartialTokenTransactionHash sets the "partial_token_transaction_hash" field.
func (ttuo *TokenTransactionUpdateOne) SetPartialTokenTransactionHash(b []byte) *TokenTransactionUpdateOne {
	ttuo.mutation.SetPartialTokenTransactionHash(b)
	return ttuo
}

// SetFinalizedTokenTransactionHash sets the "finalized_token_transaction_hash" field.
func (ttuo *TokenTransactionUpdateOne) SetFinalizedTokenTransactionHash(b []byte) *TokenTransactionUpdateOne {
	ttuo.mutation.SetFinalizedTokenTransactionHash(b)
	return ttuo
}

// SetOperatorSignature sets the "operator_signature" field.
func (ttuo *TokenTransactionUpdateOne) SetOperatorSignature(b []byte) *TokenTransactionUpdateOne {
	ttuo.mutation.SetOperatorSignature(b)
	return ttuo
}

// ClearOperatorSignature clears the value of the "operator_signature" field.
func (ttuo *TokenTransactionUpdateOne) ClearOperatorSignature() *TokenTransactionUpdateOne {
	ttuo.mutation.ClearOperatorSignature()
	return ttuo
}

// SetStatus sets the "status" field.
func (ttuo *TokenTransactionUpdateOne) SetStatus(sts schematype.TokenTransactionStatus) *TokenTransactionUpdateOne {
	ttuo.mutation.SetStatus(sts)
	return ttuo
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (ttuo *TokenTransactionUpdateOne) SetNillableStatus(sts *schematype.TokenTransactionStatus) *TokenTransactionUpdateOne {
	if sts != nil {
		ttuo.SetStatus(*sts)
	}
	return ttuo
}

// ClearStatus clears the value of the "status" field.
func (ttuo *TokenTransactionUpdateOne) ClearStatus() *TokenTransactionUpdateOne {
	ttuo.mutation.ClearStatus()
	return ttuo
}

// SetCoordinatorPublicKey sets the "coordinator_public_key" field.
func (ttuo *TokenTransactionUpdateOne) SetCoordinatorPublicKey(k keys.Public) *TokenTransactionUpdateOne {
	ttuo.mutation.SetCoordinatorPublicKey(k)
	return ttuo
}

// SetNillableCoordinatorPublicKey sets the "coordinator_public_key" field if the given value is not nil.
func (ttuo *TokenTransactionUpdateOne) SetNillableCoordinatorPublicKey(k *keys.Public) *TokenTransactionUpdateOne {
	if k != nil {
		ttuo.SetCoordinatorPublicKey(*k)
	}
	return ttuo
}

// ClearCoordinatorPublicKey clears the value of the "coordinator_public_key" field.
func (ttuo *TokenTransactionUpdateOne) ClearCoordinatorPublicKey() *TokenTransactionUpdateOne {
	ttuo.mutation.ClearCoordinatorPublicKey()
	return ttuo
}

// SetClientCreatedTimestamp sets the "client_created_timestamp" field.
func (ttuo *TokenTransactionUpdateOne) SetClientCreatedTimestamp(t time.Time) *TokenTransactionUpdateOne {
	ttuo.mutation.SetClientCreatedTimestamp(t)
	return ttuo
}

// SetNillableClientCreatedTimestamp sets the "client_created_timestamp" field if the given value is not nil.
func (ttuo *TokenTransactionUpdateOne) SetNillableClientCreatedTimestamp(t *time.Time) *TokenTransactionUpdateOne {
	if t != nil {
		ttuo.SetClientCreatedTimestamp(*t)
	}
	return ttuo
}

// ClearClientCreatedTimestamp clears the value of the "client_created_timestamp" field.
func (ttuo *TokenTransactionUpdateOne) ClearClientCreatedTimestamp() *TokenTransactionUpdateOne {
	ttuo.mutation.ClearClientCreatedTimestamp()
	return ttuo
}

// SetVersion sets the "version" field.
func (ttuo *TokenTransactionUpdateOne) SetVersion(stv schematype.TokenTransactionVersion) *TokenTransactionUpdateOne {
	ttuo.mutation.ResetVersion()
	ttuo.mutation.SetVersion(stv)
	return ttuo
}

// SetNillableVersion sets the "version" field if the given value is not nil.
func (ttuo *TokenTransactionUpdateOne) SetNillableVersion(stv *schematype.TokenTransactionVersion) *TokenTransactionUpdateOne {
	if stv != nil {
		ttuo.SetVersion(*stv)
	}
	return ttuo
}

// AddVersion adds stv to the "version" field.
func (ttuo *TokenTransactionUpdateOne) AddVersion(stv schematype.TokenTransactionVersion) *TokenTransactionUpdateOne {
	ttuo.mutation.AddVersion(stv)
	return ttuo
}

// AddSpentOutputIDs adds the "spent_output" edge to the TokenOutput entity by IDs.
func (ttuo *TokenTransactionUpdateOne) AddSpentOutputIDs(ids ...uuid.UUID) *TokenTransactionUpdateOne {
	ttuo.mutation.AddSpentOutputIDs(ids...)
	return ttuo
}

// AddSpentOutput adds the "spent_output" edges to the TokenOutput entity.
func (ttuo *TokenTransactionUpdateOne) AddSpentOutput(t ...*TokenOutput) *TokenTransactionUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttuo.AddSpentOutputIDs(ids...)
}

// AddSpentOutputV2IDs adds the "spent_output_v2" edge to the TokenOutput entity by IDs.
func (ttuo *TokenTransactionUpdateOne) AddSpentOutputV2IDs(ids ...uuid.UUID) *TokenTransactionUpdateOne {
	ttuo.mutation.AddSpentOutputV2IDs(ids...)
	return ttuo
}

// AddSpentOutputV2 adds the "spent_output_v2" edges to the TokenOutput entity.
func (ttuo *TokenTransactionUpdateOne) AddSpentOutputV2(t ...*TokenOutput) *TokenTransactionUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttuo.AddSpentOutputV2IDs(ids...)
}

// AddCreatedOutputIDs adds the "created_output" edge to the TokenOutput entity by IDs.
func (ttuo *TokenTransactionUpdateOne) AddCreatedOutputIDs(ids ...uuid.UUID) *TokenTransactionUpdateOne {
	ttuo.mutation.AddCreatedOutputIDs(ids...)
	return ttuo
}

// AddCreatedOutput adds the "created_output" edges to the TokenOutput entity.
func (ttuo *TokenTransactionUpdateOne) AddCreatedOutput(t ...*TokenOutput) *TokenTransactionUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttuo.AddCreatedOutputIDs(ids...)
}

// SetMintID sets the "mint" edge to the TokenMint entity by ID.
func (ttuo *TokenTransactionUpdateOne) SetMintID(id uuid.UUID) *TokenTransactionUpdateOne {
	ttuo.mutation.SetMintID(id)
	return ttuo
}

// SetNillableMintID sets the "mint" edge to the TokenMint entity by ID if the given value is not nil.
func (ttuo *TokenTransactionUpdateOne) SetNillableMintID(id *uuid.UUID) *TokenTransactionUpdateOne {
	if id != nil {
		ttuo = ttuo.SetMintID(*id)
	}
	return ttuo
}

// SetMint sets the "mint" edge to the TokenMint entity.
func (ttuo *TokenTransactionUpdateOne) SetMint(t *TokenMint) *TokenTransactionUpdateOne {
	return ttuo.SetMintID(t.ID)
}

// SetCreateID sets the "create" edge to the TokenCreate entity by ID.
func (ttuo *TokenTransactionUpdateOne) SetCreateID(id uuid.UUID) *TokenTransactionUpdateOne {
	ttuo.mutation.SetCreateID(id)
	return ttuo
}

// SetNillableCreateID sets the "create" edge to the TokenCreate entity by ID if the given value is not nil.
func (ttuo *TokenTransactionUpdateOne) SetNillableCreateID(id *uuid.UUID) *TokenTransactionUpdateOne {
	if id != nil {
		ttuo = ttuo.SetCreateID(*id)
	}
	return ttuo
}

// SetCreate sets the "create" edge to the TokenCreate entity.
func (ttuo *TokenTransactionUpdateOne) SetCreate(t *TokenCreate) *TokenTransactionUpdateOne {
	return ttuo.SetCreateID(t.ID)
}

// SetPaymentIntentID sets the "payment_intent" edge to the PaymentIntent entity by ID.
func (ttuo *TokenTransactionUpdateOne) SetPaymentIntentID(id uuid.UUID) *TokenTransactionUpdateOne {
	ttuo.mutation.SetPaymentIntentID(id)
	return ttuo
}

// SetNillablePaymentIntentID sets the "payment_intent" edge to the PaymentIntent entity by ID if the given value is not nil.
func (ttuo *TokenTransactionUpdateOne) SetNillablePaymentIntentID(id *uuid.UUID) *TokenTransactionUpdateOne {
	if id != nil {
		ttuo = ttuo.SetPaymentIntentID(*id)
	}
	return ttuo
}

// SetPaymentIntent sets the "payment_intent" edge to the PaymentIntent entity.
func (ttuo *TokenTransactionUpdateOne) SetPaymentIntent(p *PaymentIntent) *TokenTransactionUpdateOne {
	return ttuo.SetPaymentIntentID(p.ID)
}

// AddPeerSignatureIDs adds the "peer_signatures" edge to the TokenTransactionPeerSignature entity by IDs.
func (ttuo *TokenTransactionUpdateOne) AddPeerSignatureIDs(ids ...uuid.UUID) *TokenTransactionUpdateOne {
	ttuo.mutation.AddPeerSignatureIDs(ids...)
	return ttuo
}

// AddPeerSignatures adds the "peer_signatures" edges to the TokenTransactionPeerSignature entity.
func (ttuo *TokenTransactionUpdateOne) AddPeerSignatures(t ...*TokenTransactionPeerSignature) *TokenTransactionUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttuo.AddPeerSignatureIDs(ids...)
}

// AddSparkInvoiceIDs adds the "spark_invoice" edge to the SparkInvoice entity by IDs.
func (ttuo *TokenTransactionUpdateOne) AddSparkInvoiceIDs(ids ...uuid.UUID) *TokenTransactionUpdateOne {
	ttuo.mutation.AddSparkInvoiceIDs(ids...)
	return ttuo
}

// AddSparkInvoice adds the "spark_invoice" edges to the SparkInvoice entity.
func (ttuo *TokenTransactionUpdateOne) AddSparkInvoice(s ...*SparkInvoice) *TokenTransactionUpdateOne {
	ids := make([]uuid.UUID, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return ttuo.AddSparkInvoiceIDs(ids...)
}

// Mutation returns the TokenTransactionMutation object of the builder.
func (ttuo *TokenTransactionUpdateOne) Mutation() *TokenTransactionMutation {
	return ttuo.mutation
}

// ClearSpentOutput clears all "spent_output" edges to the TokenOutput entity.
func (ttuo *TokenTransactionUpdateOne) ClearSpentOutput() *TokenTransactionUpdateOne {
	ttuo.mutation.ClearSpentOutput()
	return ttuo
}

// RemoveSpentOutputIDs removes the "spent_output" edge to TokenOutput entities by IDs.
func (ttuo *TokenTransactionUpdateOne) RemoveSpentOutputIDs(ids ...uuid.UUID) *TokenTransactionUpdateOne {
	ttuo.mutation.RemoveSpentOutputIDs(ids...)
	return ttuo
}

// RemoveSpentOutput removes "spent_output" edges to TokenOutput entities.
func (ttuo *TokenTransactionUpdateOne) RemoveSpentOutput(t ...*TokenOutput) *TokenTransactionUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttuo.RemoveSpentOutputIDs(ids...)
}

// ClearSpentOutputV2 clears all "spent_output_v2" edges to the TokenOutput entity.
func (ttuo *TokenTransactionUpdateOne) ClearSpentOutputV2() *TokenTransactionUpdateOne {
	ttuo.mutation.ClearSpentOutputV2()
	return ttuo
}

// RemoveSpentOutputV2IDs removes the "spent_output_v2" edge to TokenOutput entities by IDs.
func (ttuo *TokenTransactionUpdateOne) RemoveSpentOutputV2IDs(ids ...uuid.UUID) *TokenTransactionUpdateOne {
	ttuo.mutation.RemoveSpentOutputV2IDs(ids...)
	return ttuo
}

// RemoveSpentOutputV2 removes "spent_output_v2" edges to TokenOutput entities.
func (ttuo *TokenTransactionUpdateOne) RemoveSpentOutputV2(t ...*TokenOutput) *TokenTransactionUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttuo.RemoveSpentOutputV2IDs(ids...)
}

// ClearCreatedOutput clears all "created_output" edges to the TokenOutput entity.
func (ttuo *TokenTransactionUpdateOne) ClearCreatedOutput() *TokenTransactionUpdateOne {
	ttuo.mutation.ClearCreatedOutput()
	return ttuo
}

// RemoveCreatedOutputIDs removes the "created_output" edge to TokenOutput entities by IDs.
func (ttuo *TokenTransactionUpdateOne) RemoveCreatedOutputIDs(ids ...uuid.UUID) *TokenTransactionUpdateOne {
	ttuo.mutation.RemoveCreatedOutputIDs(ids...)
	return ttuo
}

// RemoveCreatedOutput removes "created_output" edges to TokenOutput entities.
func (ttuo *TokenTransactionUpdateOne) RemoveCreatedOutput(t ...*TokenOutput) *TokenTransactionUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttuo.RemoveCreatedOutputIDs(ids...)
}

// ClearMint clears the "mint" edge to the TokenMint entity.
func (ttuo *TokenTransactionUpdateOne) ClearMint() *TokenTransactionUpdateOne {
	ttuo.mutation.ClearMint()
	return ttuo
}

// ClearCreate clears the "create" edge to the TokenCreate entity.
func (ttuo *TokenTransactionUpdateOne) ClearCreate() *TokenTransactionUpdateOne {
	ttuo.mutation.ClearCreate()
	return ttuo
}

// ClearPaymentIntent clears the "payment_intent" edge to the PaymentIntent entity.
func (ttuo *TokenTransactionUpdateOne) ClearPaymentIntent() *TokenTransactionUpdateOne {
	ttuo.mutation.ClearPaymentIntent()
	return ttuo
}

// ClearPeerSignatures clears all "peer_signatures" edges to the TokenTransactionPeerSignature entity.
func (ttuo *TokenTransactionUpdateOne) ClearPeerSignatures() *TokenTransactionUpdateOne {
	ttuo.mutation.ClearPeerSignatures()
	return ttuo
}

// RemovePeerSignatureIDs removes the "peer_signatures" edge to TokenTransactionPeerSignature entities by IDs.
func (ttuo *TokenTransactionUpdateOne) RemovePeerSignatureIDs(ids ...uuid.UUID) *TokenTransactionUpdateOne {
	ttuo.mutation.RemovePeerSignatureIDs(ids...)
	return ttuo
}

// RemovePeerSignatures removes "peer_signatures" edges to TokenTransactionPeerSignature entities.
func (ttuo *TokenTransactionUpdateOne) RemovePeerSignatures(t ...*TokenTransactionPeerSignature) *TokenTransactionUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return ttuo.RemovePeerSignatureIDs(ids...)
}

// ClearSparkInvoice clears all "spark_invoice" edges to the SparkInvoice entity.
func (ttuo *TokenTransactionUpdateOne) ClearSparkInvoice() *TokenTransactionUpdateOne {
	ttuo.mutation.ClearSparkInvoice()
	return ttuo
}

// RemoveSparkInvoiceIDs removes the "spark_invoice" edge to SparkInvoice entities by IDs.
func (ttuo *TokenTransactionUpdateOne) RemoveSparkInvoiceIDs(ids ...uuid.UUID) *TokenTransactionUpdateOne {
	ttuo.mutation.RemoveSparkInvoiceIDs(ids...)
	return ttuo
}

// RemoveSparkInvoice removes "spark_invoice" edges to SparkInvoice entities.
func (ttuo *TokenTransactionUpdateOne) RemoveSparkInvoice(s ...*SparkInvoice) *TokenTransactionUpdateOne {
	ids := make([]uuid.UUID, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return ttuo.RemoveSparkInvoiceIDs(ids...)
}

// Where appends a list predicates to the TokenTransactionUpdate builder.
func (ttuo *TokenTransactionUpdateOne) Where(ps ...predicate.TokenTransaction) *TokenTransactionUpdateOne {
	ttuo.mutation.Where(ps...)
	return ttuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (ttuo *TokenTransactionUpdateOne) Select(field string, fields ...string) *TokenTransactionUpdateOne {
	ttuo.fields = append([]string{field}, fields...)
	return ttuo
}

// Save executes the query and returns the updated TokenTransaction entity.
func (ttuo *TokenTransactionUpdateOne) Save(ctx context.Context) (*TokenTransaction, error) {
	if err := ttuo.defaults(); err != nil {
		return nil, err
	}
	return withHooks(ctx, ttuo.sqlSave, ttuo.mutation, ttuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (ttuo *TokenTransactionUpdateOne) SaveX(ctx context.Context) *TokenTransaction {
	node, err := ttuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (ttuo *TokenTransactionUpdateOne) Exec(ctx context.Context) error {
	_, err := ttuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ttuo *TokenTransactionUpdateOne) ExecX(ctx context.Context) {
	if err := ttuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (ttuo *TokenTransactionUpdateOne) defaults() error {
	if _, ok := ttuo.mutation.UpdateTime(); !ok {
		if tokentransaction.UpdateDefaultUpdateTime == nil {
			return fmt.Errorf("ent: uninitialized tokentransaction.UpdateDefaultUpdateTime (forgotten import ent/runtime?)")
		}
		v := tokentransaction.UpdateDefaultUpdateTime()
		ttuo.mutation.SetUpdateTime(v)
	}
	return nil
}

// check runs all checks and user-defined validators on the builder.
func (ttuo *TokenTransactionUpdateOne) check() error {
	if v, ok := ttuo.mutation.PartialTokenTransactionHash(); ok {
		if err := tokentransaction.PartialTokenTransactionHashValidator(v); err != nil {
			return &ValidationError{Name: "partial_token_transaction_hash", err: fmt.Errorf(`ent: validator failed for field "TokenTransaction.partial_token_transaction_hash": %w`, err)}
		}
	}
	if v, ok := ttuo.mutation.FinalizedTokenTransactionHash(); ok {
		if err := tokentransaction.FinalizedTokenTransactionHashValidator(v); err != nil {
			return &ValidationError{Name: "finalized_token_transaction_hash", err: fmt.Errorf(`ent: validator failed for field "TokenTransaction.finalized_token_transaction_hash": %w`, err)}
		}
	}
	if v, ok := ttuo.mutation.Status(); ok {
		if err := tokentransaction.StatusValidator(v); err != nil {
			return &ValidationError{Name: "status", err: fmt.Errorf(`ent: validator failed for field "TokenTransaction.status": %w`, err)}
		}
	}
	if v, ok := ttuo.mutation.Version(); ok {
		if err := tokentransaction.VersionValidator(int(v)); err != nil {
			return &ValidationError{Name: "version", err: fmt.Errorf(`ent: validator failed for field "TokenTransaction.version": %w`, err)}
		}
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (ttuo *TokenTransactionUpdateOne) Modify(modifiers ...func(u *sql.UpdateBuilder)) *TokenTransactionUpdateOne {
	ttuo.modifiers = append(ttuo.modifiers, modifiers...)
	return ttuo
}

func (ttuo *TokenTransactionUpdateOne) sqlSave(ctx context.Context) (_node *TokenTransaction, err error) {
	if err := ttuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(tokentransaction.Table, tokentransaction.Columns, sqlgraph.NewFieldSpec(tokentransaction.FieldID, field.TypeUUID))
	id, ok := ttuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "TokenTransaction.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := ttuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, tokentransaction.FieldID)
		for _, f := range fields {
			if !tokentransaction.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != tokentransaction.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := ttuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := ttuo.mutation.UpdateTime(); ok {
		_spec.SetField(tokentransaction.FieldUpdateTime, field.TypeTime, value)
	}
	if value, ok := ttuo.mutation.PartialTokenTransactionHash(); ok {
		_spec.SetField(tokentransaction.FieldPartialTokenTransactionHash, field.TypeBytes, value)
	}
	if value, ok := ttuo.mutation.FinalizedTokenTransactionHash(); ok {
		_spec.SetField(tokentransaction.FieldFinalizedTokenTransactionHash, field.TypeBytes, value)
	}
	if value, ok := ttuo.mutation.OperatorSignature(); ok {
		_spec.SetField(tokentransaction.FieldOperatorSignature, field.TypeBytes, value)
	}
	if ttuo.mutation.OperatorSignatureCleared() {
		_spec.ClearField(tokentransaction.FieldOperatorSignature, field.TypeBytes)
	}
	if value, ok := ttuo.mutation.Status(); ok {
		_spec.SetField(tokentransaction.FieldStatus, field.TypeEnum, value)
	}
	if ttuo.mutation.StatusCleared() {
		_spec.ClearField(tokentransaction.FieldStatus, field.TypeEnum)
	}
	if ttuo.mutation.ExpiryTimeCleared() {
		_spec.ClearField(tokentransaction.FieldExpiryTime, field.TypeTime)
	}
	if value, ok := ttuo.mutation.CoordinatorPublicKey(); ok {
		_spec.SetField(tokentransaction.FieldCoordinatorPublicKey, field.TypeBytes, value)
	}
	if ttuo.mutation.CoordinatorPublicKeyCleared() {
		_spec.ClearField(tokentransaction.FieldCoordinatorPublicKey, field.TypeBytes)
	}
	if value, ok := ttuo.mutation.ClientCreatedTimestamp(); ok {
		_spec.SetField(tokentransaction.FieldClientCreatedTimestamp, field.TypeTime, value)
	}
	if ttuo.mutation.ClientCreatedTimestampCleared() {
		_spec.ClearField(tokentransaction.FieldClientCreatedTimestamp, field.TypeTime)
	}
	if value, ok := ttuo.mutation.Version(); ok {
		_spec.SetField(tokentransaction.FieldVersion, field.TypeInt, value)
	}
	if value, ok := ttuo.mutation.AddedVersion(); ok {
		_spec.AddField(tokentransaction.FieldVersion, field.TypeInt, value)
	}
	if ttuo.mutation.SpentOutputCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.SpentOutputTable,
			Columns: []string{tokentransaction.SpentOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttuo.mutation.RemovedSpentOutputIDs(); len(nodes) > 0 && !ttuo.mutation.SpentOutputCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.SpentOutputTable,
			Columns: []string{tokentransaction.SpentOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttuo.mutation.SpentOutputIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.SpentOutputTable,
			Columns: []string{tokentransaction.SpentOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ttuo.mutation.SpentOutputV2Cleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   tokentransaction.SpentOutputV2Table,
			Columns: tokentransaction.SpentOutputV2PrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttuo.mutation.RemovedSpentOutputV2IDs(); len(nodes) > 0 && !ttuo.mutation.SpentOutputV2Cleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   tokentransaction.SpentOutputV2Table,
			Columns: tokentransaction.SpentOutputV2PrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttuo.mutation.SpentOutputV2IDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   tokentransaction.SpentOutputV2Table,
			Columns: tokentransaction.SpentOutputV2PrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ttuo.mutation.CreatedOutputCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.CreatedOutputTable,
			Columns: []string{tokentransaction.CreatedOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttuo.mutation.RemovedCreatedOutputIDs(); len(nodes) > 0 && !ttuo.mutation.CreatedOutputCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.CreatedOutputTable,
			Columns: []string{tokentransaction.CreatedOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttuo.mutation.CreatedOutputIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   tokentransaction.CreatedOutputTable,
			Columns: []string{tokentransaction.CreatedOutputColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenoutput.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ttuo.mutation.MintCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   tokentransaction.MintTable,
			Columns: []string{tokentransaction.MintColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenmint.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttuo.mutation.MintIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   tokentransaction.MintTable,
			Columns: []string{tokentransaction.MintColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokenmint.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ttuo.mutation.CreateCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   tokentransaction.CreateTable,
			Columns: []string{tokentransaction.CreateColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokencreate.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttuo.mutation.CreateIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   tokentransaction.CreateTable,
			Columns: []string{tokentransaction.CreateColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokencreate.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ttuo.mutation.PaymentIntentCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   tokentransaction.PaymentIntentTable,
			Columns: []string{tokentransaction.PaymentIntentColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(paymentintent.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttuo.mutation.PaymentIntentIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   tokentransaction.PaymentIntentTable,
			Columns: []string{tokentransaction.PaymentIntentColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(paymentintent.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ttuo.mutation.PeerSignaturesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tokentransaction.PeerSignaturesTable,
			Columns: []string{tokentransaction.PeerSignaturesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokentransactionpeersignature.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttuo.mutation.RemovedPeerSignaturesIDs(); len(nodes) > 0 && !ttuo.mutation.PeerSignaturesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tokentransaction.PeerSignaturesTable,
			Columns: []string{tokentransaction.PeerSignaturesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokentransactionpeersignature.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttuo.mutation.PeerSignaturesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tokentransaction.PeerSignaturesTable,
			Columns: []string{tokentransaction.PeerSignaturesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tokentransactionpeersignature.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if ttuo.mutation.SparkInvoiceCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   tokentransaction.SparkInvoiceTable,
			Columns: tokentransaction.SparkInvoicePrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sparkinvoice.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttuo.mutation.RemovedSparkInvoiceIDs(); len(nodes) > 0 && !ttuo.mutation.SparkInvoiceCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   tokentransaction.SparkInvoiceTable,
			Columns: tokentransaction.SparkInvoicePrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sparkinvoice.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ttuo.mutation.SparkInvoiceIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   tokentransaction.SparkInvoiceTable,
			Columns: tokentransaction.SparkInvoicePrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sparkinvoice.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.AddModifiers(ttuo.modifiers...)
	_node = &TokenTransaction{config: ttuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, ttuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{tokentransaction.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	ttuo.mutation.done = true
	return _node, nil
}
