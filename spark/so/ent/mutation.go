// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/lightsparkdev/spark/common/keys"
	"github.com/lightsparkdev/spark/so/ent/blockheight"
	"github.com/lightsparkdev/spark/so/ent/cooperativeexit"
	"github.com/lightsparkdev/spark/so/ent/depositaddress"
	"github.com/lightsparkdev/spark/so/ent/entitydkgkey"
	"github.com/lightsparkdev/spark/so/ent/gossip"
	"github.com/lightsparkdev/spark/so/ent/l1tokencreate"
	"github.com/lightsparkdev/spark/so/ent/paymentintent"
	"github.com/lightsparkdev/spark/so/ent/pendingsendtransfer"
	"github.com/lightsparkdev/spark/so/ent/predicate"
	"github.com/lightsparkdev/spark/so/ent/preimagerequest"
	"github.com/lightsparkdev/spark/so/ent/preimageshare"
	"github.com/lightsparkdev/spark/so/ent/schema/schematype"
	"github.com/lightsparkdev/spark/so/ent/signingcommitment"
	"github.com/lightsparkdev/spark/so/ent/signingkeyshare"
	"github.com/lightsparkdev/spark/so/ent/signingnonce"
	"github.com/lightsparkdev/spark/so/ent/sparkinvoice"
	"github.com/lightsparkdev/spark/so/ent/tokencreate"
	"github.com/lightsparkdev/spark/so/ent/tokenfreeze"
	"github.com/lightsparkdev/spark/so/ent/tokenmint"
	"github.com/lightsparkdev/spark/so/ent/tokenoutput"
	"github.com/lightsparkdev/spark/so/ent/tokenpartialrevocationsecretshare"
	"github.com/lightsparkdev/spark/so/ent/tokentransaction"
	"github.com/lightsparkdev/spark/so/ent/tokentransactionpeersignature"
	"github.com/lightsparkdev/spark/so/ent/transfer"
	"github.com/lightsparkdev/spark/so/ent/transferleaf"
	"github.com/lightsparkdev/spark/so/ent/tree"
	"github.com/lightsparkdev/spark/so/ent/treenode"
	"github.com/lightsparkdev/spark/so/ent/usersignedtransaction"
	"github.com/lightsparkdev/spark/so/ent/utxo"
	"github.com/lightsparkdev/spark/so/ent/utxoswap"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBlockHeight                       = "BlockHeight"
	TypeCooperativeExit                   = "CooperativeExit"
	TypeDepositAddress                    = "DepositAddress"
	TypeEntityDkgKey                      = "EntityDkgKey"
	TypeGossip                            = "Gossip"
	TypeL1TokenCreate                     = "L1TokenCreate"
	TypePaymentIntent                     = "PaymentIntent"
	TypePendingSendTransfer               = "PendingSendTransfer"
	TypePreimageRequest                   = "PreimageRequest"
	TypePreimageShare                     = "PreimageShare"
	TypeSigningCommitment                 = "SigningCommitment"
	TypeSigningKeyshare                   = "SigningKeyshare"
	TypeSigningNonce                      = "SigningNonce"
	TypeSparkInvoice                      = "SparkInvoice"
	TypeTokenCreate                       = "TokenCreate"
	TypeTokenFreeze                       = "TokenFreeze"
	TypeTokenMint                         = "TokenMint"
	TypeTokenOutput                       = "TokenOutput"
	TypeTokenPartialRevocationSecretShare = "TokenPartialRevocationSecretShare"
	TypeTokenTransaction                  = "TokenTransaction"
	TypeTokenTransactionPeerSignature     = "TokenTransactionPeerSignature"
	TypeTransfer                          = "Transfer"
	TypeTransferLeaf                      = "TransferLeaf"
	TypeTree                              = "Tree"
	TypeTreeNode                          = "TreeNode"
	TypeUserSignedTransaction             = "UserSignedTransaction"
	TypeUtxo                              = "Utxo"
	TypeUtxoSwap                          = "UtxoSwap"
)

// BlockHeightMutation represents an operation that mutates the BlockHeight nodes in the graph.
type BlockHeightMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	create_time   *time.Time
	update_time   *time.Time
	height        *int64
	addheight     *int64
	network       *schematype.Network
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BlockHeight, error)
	predicates    []predicate.BlockHeight
}

var _ ent.Mutation = (*BlockHeightMutation)(nil)

// blockheightOption allows management of the mutation configuration using functional options.
type blockheightOption func(*BlockHeightMutation)

// newBlockHeightMutation creates new mutation for the BlockHeight entity.
func newBlockHeightMutation(c config, op Op, opts ...blockheightOption) *BlockHeightMutation {
	m := &BlockHeightMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockHeight,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockHeightID sets the ID field of the mutation.
func withBlockHeightID(id uuid.UUID) blockheightOption {
	return func(m *BlockHeightMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockHeight
		)
		m.oldValue = func(ctx context.Context) (*BlockHeight, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockHeight.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockHeight sets the old BlockHeight of the mutation.
func withBlockHeight(node *BlockHeight) blockheightOption {
	return func(m *BlockHeightMutation) {
		m.oldValue = func(context.Context) (*BlockHeight, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockHeightMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockHeightMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlockHeight entities.
func (m *BlockHeightMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockHeightMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockHeightMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockHeight.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *BlockHeightMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *BlockHeightMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the BlockHeight entity.
// If the BlockHeight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockHeightMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *BlockHeightMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *BlockHeightMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *BlockHeightMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the BlockHeight entity.
// If the BlockHeight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockHeightMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *BlockHeightMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetHeight sets the "height" field.
func (m *BlockHeightMutation) SetHeight(i int64) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *BlockHeightMutation) Height() (r int64, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the BlockHeight entity.
// If the BlockHeight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockHeightMutation) OldHeight(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *BlockHeightMutation) AddHeight(i int64) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *BlockHeightMutation) AddedHeight() (r int64, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *BlockHeightMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetNetwork sets the "network" field.
func (m *BlockHeightMutation) SetNetwork(s schematype.Network) {
	m.network = &s
}

// Network returns the value of the "network" field in the mutation.
func (m *BlockHeightMutation) Network() (r schematype.Network, exists bool) {
	v := m.network
	if v == nil {
		return
	}
	return *v, true
}

// OldNetwork returns the old "network" field's value of the BlockHeight entity.
// If the BlockHeight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockHeightMutation) OldNetwork(ctx context.Context) (v schematype.Network, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetwork is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetwork requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetwork: %w", err)
	}
	return oldValue.Network, nil
}

// ResetNetwork resets all changes to the "network" field.
func (m *BlockHeightMutation) ResetNetwork() {
	m.network = nil
}

// Where appends a list predicates to the BlockHeightMutation builder.
func (m *BlockHeightMutation) Where(ps ...predicate.BlockHeight) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockHeightMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockHeightMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockHeight, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockHeightMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockHeightMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockHeight).
func (m *BlockHeightMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockHeightMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, blockheight.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, blockheight.FieldUpdateTime)
	}
	if m.height != nil {
		fields = append(fields, blockheight.FieldHeight)
	}
	if m.network != nil {
		fields = append(fields, blockheight.FieldNetwork)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockHeightMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockheight.FieldCreateTime:
		return m.CreateTime()
	case blockheight.FieldUpdateTime:
		return m.UpdateTime()
	case blockheight.FieldHeight:
		return m.Height()
	case blockheight.FieldNetwork:
		return m.Network()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockHeightMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockheight.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case blockheight.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case blockheight.FieldHeight:
		return m.OldHeight(ctx)
	case blockheight.FieldNetwork:
		return m.OldNetwork(ctx)
	}
	return nil, fmt.Errorf("unknown BlockHeight field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockHeightMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockheight.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case blockheight.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case blockheight.FieldHeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case blockheight.FieldNetwork:
		v, ok := value.(schematype.Network)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetwork(v)
		return nil
	}
	return fmt.Errorf("unknown BlockHeight field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockHeightMutation) AddedFields() []string {
	var fields []string
	if m.addheight != nil {
		fields = append(fields, blockheight.FieldHeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockHeightMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blockheight.FieldHeight:
		return m.AddedHeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockHeightMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blockheight.FieldHeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	}
	return fmt.Errorf("unknown BlockHeight numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockHeightMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockHeightMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockHeightMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BlockHeight nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockHeightMutation) ResetField(name string) error {
	switch name {
	case blockheight.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case blockheight.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case blockheight.FieldHeight:
		m.ResetHeight()
		return nil
	case blockheight.FieldNetwork:
		m.ResetNetwork()
		return nil
	}
	return fmt.Errorf("unknown BlockHeight field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockHeightMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockHeightMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockHeightMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockHeightMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockHeightMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockHeightMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockHeightMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BlockHeight unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockHeightMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BlockHeight edge %s", name)
}

// CooperativeExitMutation represents an operation that mutates the CooperativeExit nodes in the graph.
type CooperativeExitMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	create_time            *time.Time
	update_time            *time.Time
	exit_txid              *[]byte
	confirmation_height    *int64
	addconfirmation_height *int64
	clearedFields          map[string]struct{}
	transfer               *uuid.UUID
	clearedtransfer        bool
	done                   bool
	oldValue               func(context.Context) (*CooperativeExit, error)
	predicates             []predicate.CooperativeExit
}

var _ ent.Mutation = (*CooperativeExitMutation)(nil)

// cooperativeexitOption allows management of the mutation configuration using functional options.
type cooperativeexitOption func(*CooperativeExitMutation)

// newCooperativeExitMutation creates new mutation for the CooperativeExit entity.
func newCooperativeExitMutation(c config, op Op, opts ...cooperativeexitOption) *CooperativeExitMutation {
	m := &CooperativeExitMutation{
		config:        c,
		op:            op,
		typ:           TypeCooperativeExit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCooperativeExitID sets the ID field of the mutation.
func withCooperativeExitID(id uuid.UUID) cooperativeexitOption {
	return func(m *CooperativeExitMutation) {
		var (
			err   error
			once  sync.Once
			value *CooperativeExit
		)
		m.oldValue = func(ctx context.Context) (*CooperativeExit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CooperativeExit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCooperativeExit sets the old CooperativeExit of the mutation.
func withCooperativeExit(node *CooperativeExit) cooperativeexitOption {
	return func(m *CooperativeExitMutation) {
		m.oldValue = func(context.Context) (*CooperativeExit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CooperativeExitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CooperativeExitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CooperativeExit entities.
func (m *CooperativeExitMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CooperativeExitMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CooperativeExitMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CooperativeExit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CooperativeExitMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CooperativeExitMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CooperativeExit entity.
// If the CooperativeExit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CooperativeExitMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CooperativeExitMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CooperativeExitMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CooperativeExitMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CooperativeExit entity.
// If the CooperativeExit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CooperativeExitMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CooperativeExitMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetExitTxid sets the "exit_txid" field.
func (m *CooperativeExitMutation) SetExitTxid(b []byte) {
	m.exit_txid = &b
}

// ExitTxid returns the value of the "exit_txid" field in the mutation.
func (m *CooperativeExitMutation) ExitTxid() (r []byte, exists bool) {
	v := m.exit_txid
	if v == nil {
		return
	}
	return *v, true
}

// OldExitTxid returns the old "exit_txid" field's value of the CooperativeExit entity.
// If the CooperativeExit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CooperativeExitMutation) OldExitTxid(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExitTxid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExitTxid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExitTxid: %w", err)
	}
	return oldValue.ExitTxid, nil
}

// ResetExitTxid resets all changes to the "exit_txid" field.
func (m *CooperativeExitMutation) ResetExitTxid() {
	m.exit_txid = nil
}

// SetConfirmationHeight sets the "confirmation_height" field.
func (m *CooperativeExitMutation) SetConfirmationHeight(i int64) {
	m.confirmation_height = &i
	m.addconfirmation_height = nil
}

// ConfirmationHeight returns the value of the "confirmation_height" field in the mutation.
func (m *CooperativeExitMutation) ConfirmationHeight() (r int64, exists bool) {
	v := m.confirmation_height
	if v == nil {
		return
	}
	return *v, true
}

// OldConfirmationHeight returns the old "confirmation_height" field's value of the CooperativeExit entity.
// If the CooperativeExit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CooperativeExitMutation) OldConfirmationHeight(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfirmationHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfirmationHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfirmationHeight: %w", err)
	}
	return oldValue.ConfirmationHeight, nil
}

// AddConfirmationHeight adds i to the "confirmation_height" field.
func (m *CooperativeExitMutation) AddConfirmationHeight(i int64) {
	if m.addconfirmation_height != nil {
		*m.addconfirmation_height += i
	} else {
		m.addconfirmation_height = &i
	}
}

// AddedConfirmationHeight returns the value that was added to the "confirmation_height" field in this mutation.
func (m *CooperativeExitMutation) AddedConfirmationHeight() (r int64, exists bool) {
	v := m.addconfirmation_height
	if v == nil {
		return
	}
	return *v, true
}

// ClearConfirmationHeight clears the value of the "confirmation_height" field.
func (m *CooperativeExitMutation) ClearConfirmationHeight() {
	m.confirmation_height = nil
	m.addconfirmation_height = nil
	m.clearedFields[cooperativeexit.FieldConfirmationHeight] = struct{}{}
}

// ConfirmationHeightCleared returns if the "confirmation_height" field was cleared in this mutation.
func (m *CooperativeExitMutation) ConfirmationHeightCleared() bool {
	_, ok := m.clearedFields[cooperativeexit.FieldConfirmationHeight]
	return ok
}

// ResetConfirmationHeight resets all changes to the "confirmation_height" field.
func (m *CooperativeExitMutation) ResetConfirmationHeight() {
	m.confirmation_height = nil
	m.addconfirmation_height = nil
	delete(m.clearedFields, cooperativeexit.FieldConfirmationHeight)
}

// SetTransferID sets the "transfer" edge to the Transfer entity by id.
func (m *CooperativeExitMutation) SetTransferID(id uuid.UUID) {
	m.transfer = &id
}

// ClearTransfer clears the "transfer" edge to the Transfer entity.
func (m *CooperativeExitMutation) ClearTransfer() {
	m.clearedtransfer = true
}

// TransferCleared reports if the "transfer" edge to the Transfer entity was cleared.
func (m *CooperativeExitMutation) TransferCleared() bool {
	return m.clearedtransfer
}

// TransferID returns the "transfer" edge ID in the mutation.
func (m *CooperativeExitMutation) TransferID() (id uuid.UUID, exists bool) {
	if m.transfer != nil {
		return *m.transfer, true
	}
	return
}

// TransferIDs returns the "transfer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransferID instead. It exists only for internal usage by the builders.
func (m *CooperativeExitMutation) TransferIDs() (ids []uuid.UUID) {
	if id := m.transfer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransfer resets all changes to the "transfer" edge.
func (m *CooperativeExitMutation) ResetTransfer() {
	m.transfer = nil
	m.clearedtransfer = false
}

// Where appends a list predicates to the CooperativeExitMutation builder.
func (m *CooperativeExitMutation) Where(ps ...predicate.CooperativeExit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CooperativeExitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CooperativeExitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CooperativeExit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CooperativeExitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CooperativeExitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CooperativeExit).
func (m *CooperativeExitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CooperativeExitMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, cooperativeexit.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, cooperativeexit.FieldUpdateTime)
	}
	if m.exit_txid != nil {
		fields = append(fields, cooperativeexit.FieldExitTxid)
	}
	if m.confirmation_height != nil {
		fields = append(fields, cooperativeexit.FieldConfirmationHeight)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CooperativeExitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cooperativeexit.FieldCreateTime:
		return m.CreateTime()
	case cooperativeexit.FieldUpdateTime:
		return m.UpdateTime()
	case cooperativeexit.FieldExitTxid:
		return m.ExitTxid()
	case cooperativeexit.FieldConfirmationHeight:
		return m.ConfirmationHeight()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CooperativeExitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cooperativeexit.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case cooperativeexit.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case cooperativeexit.FieldExitTxid:
		return m.OldExitTxid(ctx)
	case cooperativeexit.FieldConfirmationHeight:
		return m.OldConfirmationHeight(ctx)
	}
	return nil, fmt.Errorf("unknown CooperativeExit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CooperativeExitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cooperativeexit.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case cooperativeexit.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case cooperativeexit.FieldExitTxid:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExitTxid(v)
		return nil
	case cooperativeexit.FieldConfirmationHeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfirmationHeight(v)
		return nil
	}
	return fmt.Errorf("unknown CooperativeExit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CooperativeExitMutation) AddedFields() []string {
	var fields []string
	if m.addconfirmation_height != nil {
		fields = append(fields, cooperativeexit.FieldConfirmationHeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CooperativeExitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cooperativeexit.FieldConfirmationHeight:
		return m.AddedConfirmationHeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CooperativeExitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cooperativeexit.FieldConfirmationHeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfirmationHeight(v)
		return nil
	}
	return fmt.Errorf("unknown CooperativeExit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CooperativeExitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cooperativeexit.FieldConfirmationHeight) {
		fields = append(fields, cooperativeexit.FieldConfirmationHeight)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CooperativeExitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CooperativeExitMutation) ClearField(name string) error {
	switch name {
	case cooperativeexit.FieldConfirmationHeight:
		m.ClearConfirmationHeight()
		return nil
	}
	return fmt.Errorf("unknown CooperativeExit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CooperativeExitMutation) ResetField(name string) error {
	switch name {
	case cooperativeexit.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case cooperativeexit.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case cooperativeexit.FieldExitTxid:
		m.ResetExitTxid()
		return nil
	case cooperativeexit.FieldConfirmationHeight:
		m.ResetConfirmationHeight()
		return nil
	}
	return fmt.Errorf("unknown CooperativeExit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CooperativeExitMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.transfer != nil {
		edges = append(edges, cooperativeexit.EdgeTransfer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CooperativeExitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cooperativeexit.EdgeTransfer:
		if id := m.transfer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CooperativeExitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CooperativeExitMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CooperativeExitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtransfer {
		edges = append(edges, cooperativeexit.EdgeTransfer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CooperativeExitMutation) EdgeCleared(name string) bool {
	switch name {
	case cooperativeexit.EdgeTransfer:
		return m.clearedtransfer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CooperativeExitMutation) ClearEdge(name string) error {
	switch name {
	case cooperativeexit.EdgeTransfer:
		m.ClearTransfer()
		return nil
	}
	return fmt.Errorf("unknown CooperativeExit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CooperativeExitMutation) ResetEdge(name string) error {
	switch name {
	case cooperativeexit.EdgeTransfer:
		m.ResetTransfer()
		return nil
	}
	return fmt.Errorf("unknown CooperativeExit edge %s", name)
}

// DepositAddressMutation represents an operation that mutates the DepositAddress nodes in the graph.
type DepositAddressMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	create_time             *time.Time
	update_time             *time.Time
	address                 *string
	network                 *schematype.Network
	owner_identity_pubkey   *keys.Public
	owner_signing_pubkey    *keys.Public
	confirmation_height     *int64
	addconfirmation_height  *int64
	confirmation_txid       *string
	address_signatures      *map[string][]uint8
	possession_signature    *[]byte
	node_id                 *uuid.UUID
	is_static               *bool
	is_default              *bool
	clearedFields           map[string]struct{}
	signing_keyshare        *uuid.UUID
	clearedsigning_keyshare bool
	utxo                    map[uuid.UUID]struct{}
	removedutxo             map[uuid.UUID]struct{}
	clearedutxo             bool
	utxoswaps               map[uuid.UUID]struct{}
	removedutxoswaps        map[uuid.UUID]struct{}
	clearedutxoswaps        bool
	tree                    *uuid.UUID
	clearedtree             bool
	done                    bool
	oldValue                func(context.Context) (*DepositAddress, error)
	predicates              []predicate.DepositAddress
}

var _ ent.Mutation = (*DepositAddressMutation)(nil)

// depositaddressOption allows management of the mutation configuration using functional options.
type depositaddressOption func(*DepositAddressMutation)

// newDepositAddressMutation creates new mutation for the DepositAddress entity.
func newDepositAddressMutation(c config, op Op, opts ...depositaddressOption) *DepositAddressMutation {
	m := &DepositAddressMutation{
		config:        c,
		op:            op,
		typ:           TypeDepositAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepositAddressID sets the ID field of the mutation.
func withDepositAddressID(id uuid.UUID) depositaddressOption {
	return func(m *DepositAddressMutation) {
		var (
			err   error
			once  sync.Once
			value *DepositAddress
		)
		m.oldValue = func(ctx context.Context) (*DepositAddress, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DepositAddress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepositAddress sets the old DepositAddress of the mutation.
func withDepositAddress(node *DepositAddress) depositaddressOption {
	return func(m *DepositAddressMutation) {
		m.oldValue = func(context.Context) (*DepositAddress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepositAddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepositAddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DepositAddress entities.
func (m *DepositAddressMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepositAddressMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepositAddressMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DepositAddress.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *DepositAddressMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DepositAddressMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DepositAddressMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *DepositAddressMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DepositAddressMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DepositAddressMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetAddress sets the "address" field.
func (m *DepositAddressMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *DepositAddressMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *DepositAddressMutation) ResetAddress() {
	m.address = nil
}

// SetNetwork sets the "network" field.
func (m *DepositAddressMutation) SetNetwork(s schematype.Network) {
	m.network = &s
}

// Network returns the value of the "network" field in the mutation.
func (m *DepositAddressMutation) Network() (r schematype.Network, exists bool) {
	v := m.network
	if v == nil {
		return
	}
	return *v, true
}

// OldNetwork returns the old "network" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldNetwork(ctx context.Context) (v schematype.Network, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetwork is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetwork requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetwork: %w", err)
	}
	return oldValue.Network, nil
}

// ClearNetwork clears the value of the "network" field.
func (m *DepositAddressMutation) ClearNetwork() {
	m.network = nil
	m.clearedFields[depositaddress.FieldNetwork] = struct{}{}
}

// NetworkCleared returns if the "network" field was cleared in this mutation.
func (m *DepositAddressMutation) NetworkCleared() bool {
	_, ok := m.clearedFields[depositaddress.FieldNetwork]
	return ok
}

// ResetNetwork resets all changes to the "network" field.
func (m *DepositAddressMutation) ResetNetwork() {
	m.network = nil
	delete(m.clearedFields, depositaddress.FieldNetwork)
}

// SetOwnerIdentityPubkey sets the "owner_identity_pubkey" field.
func (m *DepositAddressMutation) SetOwnerIdentityPubkey(k keys.Public) {
	m.owner_identity_pubkey = &k
}

// OwnerIdentityPubkey returns the value of the "owner_identity_pubkey" field in the mutation.
func (m *DepositAddressMutation) OwnerIdentityPubkey() (r keys.Public, exists bool) {
	v := m.owner_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerIdentityPubkey returns the old "owner_identity_pubkey" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldOwnerIdentityPubkey(ctx context.Context) (v keys.Public, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerIdentityPubkey: %w", err)
	}
	return oldValue.OwnerIdentityPubkey, nil
}

// ResetOwnerIdentityPubkey resets all changes to the "owner_identity_pubkey" field.
func (m *DepositAddressMutation) ResetOwnerIdentityPubkey() {
	m.owner_identity_pubkey = nil
}

// SetOwnerSigningPubkey sets the "owner_signing_pubkey" field.
func (m *DepositAddressMutation) SetOwnerSigningPubkey(k keys.Public) {
	m.owner_signing_pubkey = &k
}

// OwnerSigningPubkey returns the value of the "owner_signing_pubkey" field in the mutation.
func (m *DepositAddressMutation) OwnerSigningPubkey() (r keys.Public, exists bool) {
	v := m.owner_signing_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerSigningPubkey returns the old "owner_signing_pubkey" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldOwnerSigningPubkey(ctx context.Context) (v keys.Public, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerSigningPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerSigningPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerSigningPubkey: %w", err)
	}
	return oldValue.OwnerSigningPubkey, nil
}

// ResetOwnerSigningPubkey resets all changes to the "owner_signing_pubkey" field.
func (m *DepositAddressMutation) ResetOwnerSigningPubkey() {
	m.owner_signing_pubkey = nil
}

// SetConfirmationHeight sets the "confirmation_height" field.
func (m *DepositAddressMutation) SetConfirmationHeight(i int64) {
	m.confirmation_height = &i
	m.addconfirmation_height = nil
}

// ConfirmationHeight returns the value of the "confirmation_height" field in the mutation.
func (m *DepositAddressMutation) ConfirmationHeight() (r int64, exists bool) {
	v := m.confirmation_height
	if v == nil {
		return
	}
	return *v, true
}

// OldConfirmationHeight returns the old "confirmation_height" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldConfirmationHeight(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfirmationHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfirmationHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfirmationHeight: %w", err)
	}
	return oldValue.ConfirmationHeight, nil
}

// AddConfirmationHeight adds i to the "confirmation_height" field.
func (m *DepositAddressMutation) AddConfirmationHeight(i int64) {
	if m.addconfirmation_height != nil {
		*m.addconfirmation_height += i
	} else {
		m.addconfirmation_height = &i
	}
}

// AddedConfirmationHeight returns the value that was added to the "confirmation_height" field in this mutation.
func (m *DepositAddressMutation) AddedConfirmationHeight() (r int64, exists bool) {
	v := m.addconfirmation_height
	if v == nil {
		return
	}
	return *v, true
}

// ClearConfirmationHeight clears the value of the "confirmation_height" field.
func (m *DepositAddressMutation) ClearConfirmationHeight() {
	m.confirmation_height = nil
	m.addconfirmation_height = nil
	m.clearedFields[depositaddress.FieldConfirmationHeight] = struct{}{}
}

// ConfirmationHeightCleared returns if the "confirmation_height" field was cleared in this mutation.
func (m *DepositAddressMutation) ConfirmationHeightCleared() bool {
	_, ok := m.clearedFields[depositaddress.FieldConfirmationHeight]
	return ok
}

// ResetConfirmationHeight resets all changes to the "confirmation_height" field.
func (m *DepositAddressMutation) ResetConfirmationHeight() {
	m.confirmation_height = nil
	m.addconfirmation_height = nil
	delete(m.clearedFields, depositaddress.FieldConfirmationHeight)
}

// SetConfirmationTxid sets the "confirmation_txid" field.
func (m *DepositAddressMutation) SetConfirmationTxid(s string) {
	m.confirmation_txid = &s
}

// ConfirmationTxid returns the value of the "confirmation_txid" field in the mutation.
func (m *DepositAddressMutation) ConfirmationTxid() (r string, exists bool) {
	v := m.confirmation_txid
	if v == nil {
		return
	}
	return *v, true
}

// OldConfirmationTxid returns the old "confirmation_txid" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldConfirmationTxid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfirmationTxid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfirmationTxid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfirmationTxid: %w", err)
	}
	return oldValue.ConfirmationTxid, nil
}

// ClearConfirmationTxid clears the value of the "confirmation_txid" field.
func (m *DepositAddressMutation) ClearConfirmationTxid() {
	m.confirmation_txid = nil
	m.clearedFields[depositaddress.FieldConfirmationTxid] = struct{}{}
}

// ConfirmationTxidCleared returns if the "confirmation_txid" field was cleared in this mutation.
func (m *DepositAddressMutation) ConfirmationTxidCleared() bool {
	_, ok := m.clearedFields[depositaddress.FieldConfirmationTxid]
	return ok
}

// ResetConfirmationTxid resets all changes to the "confirmation_txid" field.
func (m *DepositAddressMutation) ResetConfirmationTxid() {
	m.confirmation_txid = nil
	delete(m.clearedFields, depositaddress.FieldConfirmationTxid)
}

// SetAddressSignatures sets the "address_signatures" field.
func (m *DepositAddressMutation) SetAddressSignatures(value map[string][]uint8) {
	m.address_signatures = &value
}

// AddressSignatures returns the value of the "address_signatures" field in the mutation.
func (m *DepositAddressMutation) AddressSignatures() (r map[string][]uint8, exists bool) {
	v := m.address_signatures
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressSignatures returns the old "address_signatures" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldAddressSignatures(ctx context.Context) (v map[string][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressSignatures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressSignatures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressSignatures: %w", err)
	}
	return oldValue.AddressSignatures, nil
}

// ClearAddressSignatures clears the value of the "address_signatures" field.
func (m *DepositAddressMutation) ClearAddressSignatures() {
	m.address_signatures = nil
	m.clearedFields[depositaddress.FieldAddressSignatures] = struct{}{}
}

// AddressSignaturesCleared returns if the "address_signatures" field was cleared in this mutation.
func (m *DepositAddressMutation) AddressSignaturesCleared() bool {
	_, ok := m.clearedFields[depositaddress.FieldAddressSignatures]
	return ok
}

// ResetAddressSignatures resets all changes to the "address_signatures" field.
func (m *DepositAddressMutation) ResetAddressSignatures() {
	m.address_signatures = nil
	delete(m.clearedFields, depositaddress.FieldAddressSignatures)
}

// SetPossessionSignature sets the "possession_signature" field.
func (m *DepositAddressMutation) SetPossessionSignature(b []byte) {
	m.possession_signature = &b
}

// PossessionSignature returns the value of the "possession_signature" field in the mutation.
func (m *DepositAddressMutation) PossessionSignature() (r []byte, exists bool) {
	v := m.possession_signature
	if v == nil {
		return
	}
	return *v, true
}

// OldPossessionSignature returns the old "possession_signature" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldPossessionSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPossessionSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPossessionSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPossessionSignature: %w", err)
	}
	return oldValue.PossessionSignature, nil
}

// ClearPossessionSignature clears the value of the "possession_signature" field.
func (m *DepositAddressMutation) ClearPossessionSignature() {
	m.possession_signature = nil
	m.clearedFields[depositaddress.FieldPossessionSignature] = struct{}{}
}

// PossessionSignatureCleared returns if the "possession_signature" field was cleared in this mutation.
func (m *DepositAddressMutation) PossessionSignatureCleared() bool {
	_, ok := m.clearedFields[depositaddress.FieldPossessionSignature]
	return ok
}

// ResetPossessionSignature resets all changes to the "possession_signature" field.
func (m *DepositAddressMutation) ResetPossessionSignature() {
	m.possession_signature = nil
	delete(m.clearedFields, depositaddress.FieldPossessionSignature)
}

// SetNodeID sets the "node_id" field.
func (m *DepositAddressMutation) SetNodeID(u uuid.UUID) {
	m.node_id = &u
}

// NodeID returns the value of the "node_id" field in the mutation.
func (m *DepositAddressMutation) NodeID() (r uuid.UUID, exists bool) {
	v := m.node_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeID returns the old "node_id" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldNodeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeID: %w", err)
	}
	return oldValue.NodeID, nil
}

// ClearNodeID clears the value of the "node_id" field.
func (m *DepositAddressMutation) ClearNodeID() {
	m.node_id = nil
	m.clearedFields[depositaddress.FieldNodeID] = struct{}{}
}

// NodeIDCleared returns if the "node_id" field was cleared in this mutation.
func (m *DepositAddressMutation) NodeIDCleared() bool {
	_, ok := m.clearedFields[depositaddress.FieldNodeID]
	return ok
}

// ResetNodeID resets all changes to the "node_id" field.
func (m *DepositAddressMutation) ResetNodeID() {
	m.node_id = nil
	delete(m.clearedFields, depositaddress.FieldNodeID)
}

// SetIsStatic sets the "is_static" field.
func (m *DepositAddressMutation) SetIsStatic(b bool) {
	m.is_static = &b
}

// IsStatic returns the value of the "is_static" field in the mutation.
func (m *DepositAddressMutation) IsStatic() (r bool, exists bool) {
	v := m.is_static
	if v == nil {
		return
	}
	return *v, true
}

// OldIsStatic returns the old "is_static" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldIsStatic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsStatic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsStatic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsStatic: %w", err)
	}
	return oldValue.IsStatic, nil
}

// ResetIsStatic resets all changes to the "is_static" field.
func (m *DepositAddressMutation) ResetIsStatic() {
	m.is_static = nil
}

// SetIsDefault sets the "is_default" field.
func (m *DepositAddressMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *DepositAddressMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *DepositAddressMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetSigningKeyshareID sets the "signing_keyshare" edge to the SigningKeyshare entity by id.
func (m *DepositAddressMutation) SetSigningKeyshareID(id uuid.UUID) {
	m.signing_keyshare = &id
}

// ClearSigningKeyshare clears the "signing_keyshare" edge to the SigningKeyshare entity.
func (m *DepositAddressMutation) ClearSigningKeyshare() {
	m.clearedsigning_keyshare = true
}

// SigningKeyshareCleared reports if the "signing_keyshare" edge to the SigningKeyshare entity was cleared.
func (m *DepositAddressMutation) SigningKeyshareCleared() bool {
	return m.clearedsigning_keyshare
}

// SigningKeyshareID returns the "signing_keyshare" edge ID in the mutation.
func (m *DepositAddressMutation) SigningKeyshareID() (id uuid.UUID, exists bool) {
	if m.signing_keyshare != nil {
		return *m.signing_keyshare, true
	}
	return
}

// SigningKeyshareIDs returns the "signing_keyshare" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SigningKeyshareID instead. It exists only for internal usage by the builders.
func (m *DepositAddressMutation) SigningKeyshareIDs() (ids []uuid.UUID) {
	if id := m.signing_keyshare; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSigningKeyshare resets all changes to the "signing_keyshare" edge.
func (m *DepositAddressMutation) ResetSigningKeyshare() {
	m.signing_keyshare = nil
	m.clearedsigning_keyshare = false
}

// AddUtxoIDs adds the "utxo" edge to the Utxo entity by ids.
func (m *DepositAddressMutation) AddUtxoIDs(ids ...uuid.UUID) {
	if m.utxo == nil {
		m.utxo = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.utxo[ids[i]] = struct{}{}
	}
}

// ClearUtxo clears the "utxo" edge to the Utxo entity.
func (m *DepositAddressMutation) ClearUtxo() {
	m.clearedutxo = true
}

// UtxoCleared reports if the "utxo" edge to the Utxo entity was cleared.
func (m *DepositAddressMutation) UtxoCleared() bool {
	return m.clearedutxo
}

// RemoveUtxoIDs removes the "utxo" edge to the Utxo entity by IDs.
func (m *DepositAddressMutation) RemoveUtxoIDs(ids ...uuid.UUID) {
	if m.removedutxo == nil {
		m.removedutxo = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.utxo, ids[i])
		m.removedutxo[ids[i]] = struct{}{}
	}
}

// RemovedUtxo returns the removed IDs of the "utxo" edge to the Utxo entity.
func (m *DepositAddressMutation) RemovedUtxoIDs() (ids []uuid.UUID) {
	for id := range m.removedutxo {
		ids = append(ids, id)
	}
	return
}

// UtxoIDs returns the "utxo" edge IDs in the mutation.
func (m *DepositAddressMutation) UtxoIDs() (ids []uuid.UUID) {
	for id := range m.utxo {
		ids = append(ids, id)
	}
	return
}

// ResetUtxo resets all changes to the "utxo" edge.
func (m *DepositAddressMutation) ResetUtxo() {
	m.utxo = nil
	m.clearedutxo = false
	m.removedutxo = nil
}

// AddUtxoswapIDs adds the "utxoswaps" edge to the UtxoSwap entity by ids.
func (m *DepositAddressMutation) AddUtxoswapIDs(ids ...uuid.UUID) {
	if m.utxoswaps == nil {
		m.utxoswaps = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.utxoswaps[ids[i]] = struct{}{}
	}
}

// ClearUtxoswaps clears the "utxoswaps" edge to the UtxoSwap entity.
func (m *DepositAddressMutation) ClearUtxoswaps() {
	m.clearedutxoswaps = true
}

// UtxoswapsCleared reports if the "utxoswaps" edge to the UtxoSwap entity was cleared.
func (m *DepositAddressMutation) UtxoswapsCleared() bool {
	return m.clearedutxoswaps
}

// RemoveUtxoswapIDs removes the "utxoswaps" edge to the UtxoSwap entity by IDs.
func (m *DepositAddressMutation) RemoveUtxoswapIDs(ids ...uuid.UUID) {
	if m.removedutxoswaps == nil {
		m.removedutxoswaps = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.utxoswaps, ids[i])
		m.removedutxoswaps[ids[i]] = struct{}{}
	}
}

// RemovedUtxoswaps returns the removed IDs of the "utxoswaps" edge to the UtxoSwap entity.
func (m *DepositAddressMutation) RemovedUtxoswapsIDs() (ids []uuid.UUID) {
	for id := range m.removedutxoswaps {
		ids = append(ids, id)
	}
	return
}

// UtxoswapsIDs returns the "utxoswaps" edge IDs in the mutation.
func (m *DepositAddressMutation) UtxoswapsIDs() (ids []uuid.UUID) {
	for id := range m.utxoswaps {
		ids = append(ids, id)
	}
	return
}

// ResetUtxoswaps resets all changes to the "utxoswaps" edge.
func (m *DepositAddressMutation) ResetUtxoswaps() {
	m.utxoswaps = nil
	m.clearedutxoswaps = false
	m.removedutxoswaps = nil
}

// SetTreeID sets the "tree" edge to the Tree entity by id.
func (m *DepositAddressMutation) SetTreeID(id uuid.UUID) {
	m.tree = &id
}

// ClearTree clears the "tree" edge to the Tree entity.
func (m *DepositAddressMutation) ClearTree() {
	m.clearedtree = true
}

// TreeCleared reports if the "tree" edge to the Tree entity was cleared.
func (m *DepositAddressMutation) TreeCleared() bool {
	return m.clearedtree
}

// TreeID returns the "tree" edge ID in the mutation.
func (m *DepositAddressMutation) TreeID() (id uuid.UUID, exists bool) {
	if m.tree != nil {
		return *m.tree, true
	}
	return
}

// TreeIDs returns the "tree" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TreeID instead. It exists only for internal usage by the builders.
func (m *DepositAddressMutation) TreeIDs() (ids []uuid.UUID) {
	if id := m.tree; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTree resets all changes to the "tree" edge.
func (m *DepositAddressMutation) ResetTree() {
	m.tree = nil
	m.clearedtree = false
}

// Where appends a list predicates to the DepositAddressMutation builder.
func (m *DepositAddressMutation) Where(ps ...predicate.DepositAddress) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepositAddressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepositAddressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DepositAddress, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepositAddressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepositAddressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DepositAddress).
func (m *DepositAddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepositAddressMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.create_time != nil {
		fields = append(fields, depositaddress.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, depositaddress.FieldUpdateTime)
	}
	if m.address != nil {
		fields = append(fields, depositaddress.FieldAddress)
	}
	if m.network != nil {
		fields = append(fields, depositaddress.FieldNetwork)
	}
	if m.owner_identity_pubkey != nil {
		fields = append(fields, depositaddress.FieldOwnerIdentityPubkey)
	}
	if m.owner_signing_pubkey != nil {
		fields = append(fields, depositaddress.FieldOwnerSigningPubkey)
	}
	if m.confirmation_height != nil {
		fields = append(fields, depositaddress.FieldConfirmationHeight)
	}
	if m.confirmation_txid != nil {
		fields = append(fields, depositaddress.FieldConfirmationTxid)
	}
	if m.address_signatures != nil {
		fields = append(fields, depositaddress.FieldAddressSignatures)
	}
	if m.possession_signature != nil {
		fields = append(fields, depositaddress.FieldPossessionSignature)
	}
	if m.node_id != nil {
		fields = append(fields, depositaddress.FieldNodeID)
	}
	if m.is_static != nil {
		fields = append(fields, depositaddress.FieldIsStatic)
	}
	if m.is_default != nil {
		fields = append(fields, depositaddress.FieldIsDefault)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepositAddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case depositaddress.FieldCreateTime:
		return m.CreateTime()
	case depositaddress.FieldUpdateTime:
		return m.UpdateTime()
	case depositaddress.FieldAddress:
		return m.Address()
	case depositaddress.FieldNetwork:
		return m.Network()
	case depositaddress.FieldOwnerIdentityPubkey:
		return m.OwnerIdentityPubkey()
	case depositaddress.FieldOwnerSigningPubkey:
		return m.OwnerSigningPubkey()
	case depositaddress.FieldConfirmationHeight:
		return m.ConfirmationHeight()
	case depositaddress.FieldConfirmationTxid:
		return m.ConfirmationTxid()
	case depositaddress.FieldAddressSignatures:
		return m.AddressSignatures()
	case depositaddress.FieldPossessionSignature:
		return m.PossessionSignature()
	case depositaddress.FieldNodeID:
		return m.NodeID()
	case depositaddress.FieldIsStatic:
		return m.IsStatic()
	case depositaddress.FieldIsDefault:
		return m.IsDefault()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepositAddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case depositaddress.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case depositaddress.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case depositaddress.FieldAddress:
		return m.OldAddress(ctx)
	case depositaddress.FieldNetwork:
		return m.OldNetwork(ctx)
	case depositaddress.FieldOwnerIdentityPubkey:
		return m.OldOwnerIdentityPubkey(ctx)
	case depositaddress.FieldOwnerSigningPubkey:
		return m.OldOwnerSigningPubkey(ctx)
	case depositaddress.FieldConfirmationHeight:
		return m.OldConfirmationHeight(ctx)
	case depositaddress.FieldConfirmationTxid:
		return m.OldConfirmationTxid(ctx)
	case depositaddress.FieldAddressSignatures:
		return m.OldAddressSignatures(ctx)
	case depositaddress.FieldPossessionSignature:
		return m.OldPossessionSignature(ctx)
	case depositaddress.FieldNodeID:
		return m.OldNodeID(ctx)
	case depositaddress.FieldIsStatic:
		return m.OldIsStatic(ctx)
	case depositaddress.FieldIsDefault:
		return m.OldIsDefault(ctx)
	}
	return nil, fmt.Errorf("unknown DepositAddress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepositAddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case depositaddress.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case depositaddress.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case depositaddress.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case depositaddress.FieldNetwork:
		v, ok := value.(schematype.Network)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetwork(v)
		return nil
	case depositaddress.FieldOwnerIdentityPubkey:
		v, ok := value.(keys.Public)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerIdentityPubkey(v)
		return nil
	case depositaddress.FieldOwnerSigningPubkey:
		v, ok := value.(keys.Public)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerSigningPubkey(v)
		return nil
	case depositaddress.FieldConfirmationHeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfirmationHeight(v)
		return nil
	case depositaddress.FieldConfirmationTxid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfirmationTxid(v)
		return nil
	case depositaddress.FieldAddressSignatures:
		v, ok := value.(map[string][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressSignatures(v)
		return nil
	case depositaddress.FieldPossessionSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPossessionSignature(v)
		return nil
	case depositaddress.FieldNodeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeID(v)
		return nil
	case depositaddress.FieldIsStatic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsStatic(v)
		return nil
	case depositaddress.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	}
	return fmt.Errorf("unknown DepositAddress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepositAddressMutation) AddedFields() []string {
	var fields []string
	if m.addconfirmation_height != nil {
		fields = append(fields, depositaddress.FieldConfirmationHeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepositAddressMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case depositaddress.FieldConfirmationHeight:
		return m.AddedConfirmationHeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepositAddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	case depositaddress.FieldConfirmationHeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfirmationHeight(v)
		return nil
	}
	return fmt.Errorf("unknown DepositAddress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepositAddressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(depositaddress.FieldNetwork) {
		fields = append(fields, depositaddress.FieldNetwork)
	}
	if m.FieldCleared(depositaddress.FieldConfirmationHeight) {
		fields = append(fields, depositaddress.FieldConfirmationHeight)
	}
	if m.FieldCleared(depositaddress.FieldConfirmationTxid) {
		fields = append(fields, depositaddress.FieldConfirmationTxid)
	}
	if m.FieldCleared(depositaddress.FieldAddressSignatures) {
		fields = append(fields, depositaddress.FieldAddressSignatures)
	}
	if m.FieldCleared(depositaddress.FieldPossessionSignature) {
		fields = append(fields, depositaddress.FieldPossessionSignature)
	}
	if m.FieldCleared(depositaddress.FieldNodeID) {
		fields = append(fields, depositaddress.FieldNodeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepositAddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepositAddressMutation) ClearField(name string) error {
	switch name {
	case depositaddress.FieldNetwork:
		m.ClearNetwork()
		return nil
	case depositaddress.FieldConfirmationHeight:
		m.ClearConfirmationHeight()
		return nil
	case depositaddress.FieldConfirmationTxid:
		m.ClearConfirmationTxid()
		return nil
	case depositaddress.FieldAddressSignatures:
		m.ClearAddressSignatures()
		return nil
	case depositaddress.FieldPossessionSignature:
		m.ClearPossessionSignature()
		return nil
	case depositaddress.FieldNodeID:
		m.ClearNodeID()
		return nil
	}
	return fmt.Errorf("unknown DepositAddress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepositAddressMutation) ResetField(name string) error {
	switch name {
	case depositaddress.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case depositaddress.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case depositaddress.FieldAddress:
		m.ResetAddress()
		return nil
	case depositaddress.FieldNetwork:
		m.ResetNetwork()
		return nil
	case depositaddress.FieldOwnerIdentityPubkey:
		m.ResetOwnerIdentityPubkey()
		return nil
	case depositaddress.FieldOwnerSigningPubkey:
		m.ResetOwnerSigningPubkey()
		return nil
	case depositaddress.FieldConfirmationHeight:
		m.ResetConfirmationHeight()
		return nil
	case depositaddress.FieldConfirmationTxid:
		m.ResetConfirmationTxid()
		return nil
	case depositaddress.FieldAddressSignatures:
		m.ResetAddressSignatures()
		return nil
	case depositaddress.FieldPossessionSignature:
		m.ResetPossessionSignature()
		return nil
	case depositaddress.FieldNodeID:
		m.ResetNodeID()
		return nil
	case depositaddress.FieldIsStatic:
		m.ResetIsStatic()
		return nil
	case depositaddress.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	}
	return fmt.Errorf("unknown DepositAddress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepositAddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.signing_keyshare != nil {
		edges = append(edges, depositaddress.EdgeSigningKeyshare)
	}
	if m.utxo != nil {
		edges = append(edges, depositaddress.EdgeUtxo)
	}
	if m.utxoswaps != nil {
		edges = append(edges, depositaddress.EdgeUtxoswaps)
	}
	if m.tree != nil {
		edges = append(edges, depositaddress.EdgeTree)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepositAddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case depositaddress.EdgeSigningKeyshare:
		if id := m.signing_keyshare; id != nil {
			return []ent.Value{*id}
		}
	case depositaddress.EdgeUtxo:
		ids := make([]ent.Value, 0, len(m.utxo))
		for id := range m.utxo {
			ids = append(ids, id)
		}
		return ids
	case depositaddress.EdgeUtxoswaps:
		ids := make([]ent.Value, 0, len(m.utxoswaps))
		for id := range m.utxoswaps {
			ids = append(ids, id)
		}
		return ids
	case depositaddress.EdgeTree:
		if id := m.tree; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepositAddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedutxo != nil {
		edges = append(edges, depositaddress.EdgeUtxo)
	}
	if m.removedutxoswaps != nil {
		edges = append(edges, depositaddress.EdgeUtxoswaps)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepositAddressMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case depositaddress.EdgeUtxo:
		ids := make([]ent.Value, 0, len(m.removedutxo))
		for id := range m.removedutxo {
			ids = append(ids, id)
		}
		return ids
	case depositaddress.EdgeUtxoswaps:
		ids := make([]ent.Value, 0, len(m.removedutxoswaps))
		for id := range m.removedutxoswaps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepositAddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsigning_keyshare {
		edges = append(edges, depositaddress.EdgeSigningKeyshare)
	}
	if m.clearedutxo {
		edges = append(edges, depositaddress.EdgeUtxo)
	}
	if m.clearedutxoswaps {
		edges = append(edges, depositaddress.EdgeUtxoswaps)
	}
	if m.clearedtree {
		edges = append(edges, depositaddress.EdgeTree)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepositAddressMutation) EdgeCleared(name string) bool {
	switch name {
	case depositaddress.EdgeSigningKeyshare:
		return m.clearedsigning_keyshare
	case depositaddress.EdgeUtxo:
		return m.clearedutxo
	case depositaddress.EdgeUtxoswaps:
		return m.clearedutxoswaps
	case depositaddress.EdgeTree:
		return m.clearedtree
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepositAddressMutation) ClearEdge(name string) error {
	switch name {
	case depositaddress.EdgeSigningKeyshare:
		m.ClearSigningKeyshare()
		return nil
	case depositaddress.EdgeTree:
		m.ClearTree()
		return nil
	}
	return fmt.Errorf("unknown DepositAddress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepositAddressMutation) ResetEdge(name string) error {
	switch name {
	case depositaddress.EdgeSigningKeyshare:
		m.ResetSigningKeyshare()
		return nil
	case depositaddress.EdgeUtxo:
		m.ResetUtxo()
		return nil
	case depositaddress.EdgeUtxoswaps:
		m.ResetUtxoswaps()
		return nil
	case depositaddress.EdgeTree:
		m.ResetTree()
		return nil
	}
	return fmt.Errorf("unknown DepositAddress edge %s", name)
}

// EntityDkgKeyMutation represents an operation that mutates the EntityDkgKey nodes in the graph.
type EntityDkgKeyMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	create_time             *time.Time
	update_time             *time.Time
	key_type                *string
	clearedFields           map[string]struct{}
	signing_keyshare        *uuid.UUID
	clearedsigning_keyshare bool
	done                    bool
	oldValue                func(context.Context) (*EntityDkgKey, error)
	predicates              []predicate.EntityDkgKey
}

var _ ent.Mutation = (*EntityDkgKeyMutation)(nil)

// entitydkgkeyOption allows management of the mutation configuration using functional options.
type entitydkgkeyOption func(*EntityDkgKeyMutation)

// newEntityDkgKeyMutation creates new mutation for the EntityDkgKey entity.
func newEntityDkgKeyMutation(c config, op Op, opts ...entitydkgkeyOption) *EntityDkgKeyMutation {
	m := &EntityDkgKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeEntityDkgKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntityDkgKeyID sets the ID field of the mutation.
func withEntityDkgKeyID(id uuid.UUID) entitydkgkeyOption {
	return func(m *EntityDkgKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *EntityDkgKey
		)
		m.oldValue = func(ctx context.Context) (*EntityDkgKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntityDkgKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntityDkgKey sets the old EntityDkgKey of the mutation.
func withEntityDkgKey(node *EntityDkgKey) entitydkgkeyOption {
	return func(m *EntityDkgKeyMutation) {
		m.oldValue = func(context.Context) (*EntityDkgKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntityDkgKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntityDkgKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EntityDkgKey entities.
func (m *EntityDkgKeyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntityDkgKeyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntityDkgKeyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntityDkgKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *EntityDkgKeyMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *EntityDkgKeyMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the EntityDkgKey entity.
// If the EntityDkgKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityDkgKeyMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *EntityDkgKeyMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *EntityDkgKeyMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *EntityDkgKeyMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the EntityDkgKey entity.
// If the EntityDkgKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityDkgKeyMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *EntityDkgKeyMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetKeyType sets the "key_type" field.
func (m *EntityDkgKeyMutation) SetKeyType(s string) {
	m.key_type = &s
}

// KeyType returns the value of the "key_type" field in the mutation.
func (m *EntityDkgKeyMutation) KeyType() (r string, exists bool) {
	v := m.key_type
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyType returns the old "key_type" field's value of the EntityDkgKey entity.
// If the EntityDkgKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityDkgKeyMutation) OldKeyType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyType: %w", err)
	}
	return oldValue.KeyType, nil
}

// ResetKeyType resets all changes to the "key_type" field.
func (m *EntityDkgKeyMutation) ResetKeyType() {
	m.key_type = nil
}

// SetSigningKeyshareID sets the "signing_keyshare" edge to the SigningKeyshare entity by id.
func (m *EntityDkgKeyMutation) SetSigningKeyshareID(id uuid.UUID) {
	m.signing_keyshare = &id
}

// ClearSigningKeyshare clears the "signing_keyshare" edge to the SigningKeyshare entity.
func (m *EntityDkgKeyMutation) ClearSigningKeyshare() {
	m.clearedsigning_keyshare = true
}

// SigningKeyshareCleared reports if the "signing_keyshare" edge to the SigningKeyshare entity was cleared.
func (m *EntityDkgKeyMutation) SigningKeyshareCleared() bool {
	return m.clearedsigning_keyshare
}

// SigningKeyshareID returns the "signing_keyshare" edge ID in the mutation.
func (m *EntityDkgKeyMutation) SigningKeyshareID() (id uuid.UUID, exists bool) {
	if m.signing_keyshare != nil {
		return *m.signing_keyshare, true
	}
	return
}

// SigningKeyshareIDs returns the "signing_keyshare" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SigningKeyshareID instead. It exists only for internal usage by the builders.
func (m *EntityDkgKeyMutation) SigningKeyshareIDs() (ids []uuid.UUID) {
	if id := m.signing_keyshare; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSigningKeyshare resets all changes to the "signing_keyshare" edge.
func (m *EntityDkgKeyMutation) ResetSigningKeyshare() {
	m.signing_keyshare = nil
	m.clearedsigning_keyshare = false
}

// Where appends a list predicates to the EntityDkgKeyMutation builder.
func (m *EntityDkgKeyMutation) Where(ps ...predicate.EntityDkgKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntityDkgKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntityDkgKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EntityDkgKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntityDkgKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntityDkgKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EntityDkgKey).
func (m *EntityDkgKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntityDkgKeyMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, entitydkgkey.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, entitydkgkey.FieldUpdateTime)
	}
	if m.key_type != nil {
		fields = append(fields, entitydkgkey.FieldKeyType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntityDkgKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entitydkgkey.FieldCreateTime:
		return m.CreateTime()
	case entitydkgkey.FieldUpdateTime:
		return m.UpdateTime()
	case entitydkgkey.FieldKeyType:
		return m.KeyType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntityDkgKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entitydkgkey.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case entitydkgkey.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case entitydkgkey.FieldKeyType:
		return m.OldKeyType(ctx)
	}
	return nil, fmt.Errorf("unknown EntityDkgKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityDkgKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entitydkgkey.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case entitydkgkey.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case entitydkgkey.FieldKeyType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyType(v)
		return nil
	}
	return fmt.Errorf("unknown EntityDkgKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntityDkgKeyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntityDkgKeyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityDkgKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EntityDkgKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntityDkgKeyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntityDkgKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntityDkgKeyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EntityDkgKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntityDkgKeyMutation) ResetField(name string) error {
	switch name {
	case entitydkgkey.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case entitydkgkey.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case entitydkgkey.FieldKeyType:
		m.ResetKeyType()
		return nil
	}
	return fmt.Errorf("unknown EntityDkgKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntityDkgKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.signing_keyshare != nil {
		edges = append(edges, entitydkgkey.EdgeSigningKeyshare)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntityDkgKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entitydkgkey.EdgeSigningKeyshare:
		if id := m.signing_keyshare; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntityDkgKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntityDkgKeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntityDkgKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsigning_keyshare {
		edges = append(edges, entitydkgkey.EdgeSigningKeyshare)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntityDkgKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case entitydkgkey.EdgeSigningKeyshare:
		return m.clearedsigning_keyshare
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntityDkgKeyMutation) ClearEdge(name string) error {
	switch name {
	case entitydkgkey.EdgeSigningKeyshare:
		m.ClearSigningKeyshare()
		return nil
	}
	return fmt.Errorf("unknown EntityDkgKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntityDkgKeyMutation) ResetEdge(name string) error {
	switch name {
	case entitydkgkey.EdgeSigningKeyshare:
		m.ResetSigningKeyshare()
		return nil
	}
	return fmt.Errorf("unknown EntityDkgKey edge %s", name)
}

// GossipMutation represents an operation that mutates the Gossip nodes in the graph.
type GossipMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	create_time        *time.Time
	update_time        *time.Time
	participants       *[]string
	appendparticipants []string
	message            *[]byte
	receipts           *[]byte
	status             *schematype.GossipStatus
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Gossip, error)
	predicates         []predicate.Gossip
}

var _ ent.Mutation = (*GossipMutation)(nil)

// gossipOption allows management of the mutation configuration using functional options.
type gossipOption func(*GossipMutation)

// newGossipMutation creates new mutation for the Gossip entity.
func newGossipMutation(c config, op Op, opts ...gossipOption) *GossipMutation {
	m := &GossipMutation{
		config:        c,
		op:            op,
		typ:           TypeGossip,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGossipID sets the ID field of the mutation.
func withGossipID(id uuid.UUID) gossipOption {
	return func(m *GossipMutation) {
		var (
			err   error
			once  sync.Once
			value *Gossip
		)
		m.oldValue = func(ctx context.Context) (*Gossip, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Gossip.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGossip sets the old Gossip of the mutation.
func withGossip(node *Gossip) gossipOption {
	return func(m *GossipMutation) {
		m.oldValue = func(context.Context) (*Gossip, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GossipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GossipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Gossip entities.
func (m *GossipMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GossipMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GossipMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Gossip.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *GossipMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *GossipMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Gossip entity.
// If the Gossip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GossipMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *GossipMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *GossipMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *GossipMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Gossip entity.
// If the Gossip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GossipMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *GossipMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetParticipants sets the "participants" field.
func (m *GossipMutation) SetParticipants(s []string) {
	m.participants = &s
	m.appendparticipants = nil
}

// Participants returns the value of the "participants" field in the mutation.
func (m *GossipMutation) Participants() (r []string, exists bool) {
	v := m.participants
	if v == nil {
		return
	}
	return *v, true
}

// OldParticipants returns the old "participants" field's value of the Gossip entity.
// If the Gossip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GossipMutation) OldParticipants(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParticipants is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParticipants requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParticipants: %w", err)
	}
	return oldValue.Participants, nil
}

// AppendParticipants adds s to the "participants" field.
func (m *GossipMutation) AppendParticipants(s []string) {
	m.appendparticipants = append(m.appendparticipants, s...)
}

// AppendedParticipants returns the list of values that were appended to the "participants" field in this mutation.
func (m *GossipMutation) AppendedParticipants() ([]string, bool) {
	if len(m.appendparticipants) == 0 {
		return nil, false
	}
	return m.appendparticipants, true
}

// ResetParticipants resets all changes to the "participants" field.
func (m *GossipMutation) ResetParticipants() {
	m.participants = nil
	m.appendparticipants = nil
}

// SetMessage sets the "message" field.
func (m *GossipMutation) SetMessage(b []byte) {
	m.message = &b
}

// Message returns the value of the "message" field in the mutation.
func (m *GossipMutation) Message() (r []byte, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Gossip entity.
// If the Gossip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GossipMutation) OldMessage(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *GossipMutation) ResetMessage() {
	m.message = nil
}

// SetReceipts sets the "receipts" field.
func (m *GossipMutation) SetReceipts(b []byte) {
	m.receipts = &b
}

// Receipts returns the value of the "receipts" field in the mutation.
func (m *GossipMutation) Receipts() (r []byte, exists bool) {
	v := m.receipts
	if v == nil {
		return
	}
	return *v, true
}

// OldReceipts returns the old "receipts" field's value of the Gossip entity.
// If the Gossip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GossipMutation) OldReceipts(ctx context.Context) (v *[]byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceipts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceipts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceipts: %w", err)
	}
	return oldValue.Receipts, nil
}

// ResetReceipts resets all changes to the "receipts" field.
func (m *GossipMutation) ResetReceipts() {
	m.receipts = nil
}

// SetStatus sets the "status" field.
func (m *GossipMutation) SetStatus(ss schematype.GossipStatus) {
	m.status = &ss
}

// Status returns the value of the "status" field in the mutation.
func (m *GossipMutation) Status() (r schematype.GossipStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Gossip entity.
// If the Gossip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GossipMutation) OldStatus(ctx context.Context) (v schematype.GossipStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GossipMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the GossipMutation builder.
func (m *GossipMutation) Where(ps ...predicate.Gossip) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GossipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GossipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Gossip, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GossipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GossipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Gossip).
func (m *GossipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GossipMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, gossip.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, gossip.FieldUpdateTime)
	}
	if m.participants != nil {
		fields = append(fields, gossip.FieldParticipants)
	}
	if m.message != nil {
		fields = append(fields, gossip.FieldMessage)
	}
	if m.receipts != nil {
		fields = append(fields, gossip.FieldReceipts)
	}
	if m.status != nil {
		fields = append(fields, gossip.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GossipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gossip.FieldCreateTime:
		return m.CreateTime()
	case gossip.FieldUpdateTime:
		return m.UpdateTime()
	case gossip.FieldParticipants:
		return m.Participants()
	case gossip.FieldMessage:
		return m.Message()
	case gossip.FieldReceipts:
		return m.Receipts()
	case gossip.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GossipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gossip.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case gossip.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case gossip.FieldParticipants:
		return m.OldParticipants(ctx)
	case gossip.FieldMessage:
		return m.OldMessage(ctx)
	case gossip.FieldReceipts:
		return m.OldReceipts(ctx)
	case gossip.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Gossip field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GossipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gossip.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case gossip.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case gossip.FieldParticipants:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParticipants(v)
		return nil
	case gossip.FieldMessage:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case gossip.FieldReceipts:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceipts(v)
		return nil
	case gossip.FieldStatus:
		v, ok := value.(schematype.GossipStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Gossip field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GossipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GossipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GossipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Gossip numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GossipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GossipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GossipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Gossip nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GossipMutation) ResetField(name string) error {
	switch name {
	case gossip.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case gossip.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case gossip.FieldParticipants:
		m.ResetParticipants()
		return nil
	case gossip.FieldMessage:
		m.ResetMessage()
		return nil
	case gossip.FieldReceipts:
		m.ResetReceipts()
		return nil
	case gossip.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Gossip field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GossipMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GossipMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GossipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GossipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GossipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GossipMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GossipMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Gossip unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GossipMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Gossip edge %s", name)
}

// L1TokenCreateMutation represents an operation that mutates the L1TokenCreate nodes in the graph.
type L1TokenCreateMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	create_time       *time.Time
	update_time       *time.Time
	issuer_public_key *keys.Public
	token_name        *string
	token_ticker      *string
	decimals          *uint8
	adddecimals       *int8
	max_supply        *[]byte
	is_freezable      *bool
	network           *schematype.Network
	token_identifier  *[]byte
	transaction_id    *[]byte
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*L1TokenCreate, error)
	predicates        []predicate.L1TokenCreate
}

var _ ent.Mutation = (*L1TokenCreateMutation)(nil)

// l1tokencreateOption allows management of the mutation configuration using functional options.
type l1tokencreateOption func(*L1TokenCreateMutation)

// newL1TokenCreateMutation creates new mutation for the L1TokenCreate entity.
func newL1TokenCreateMutation(c config, op Op, opts ...l1tokencreateOption) *L1TokenCreateMutation {
	m := &L1TokenCreateMutation{
		config:        c,
		op:            op,
		typ:           TypeL1TokenCreate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withL1TokenCreateID sets the ID field of the mutation.
func withL1TokenCreateID(id uuid.UUID) l1tokencreateOption {
	return func(m *L1TokenCreateMutation) {
		var (
			err   error
			once  sync.Once
			value *L1TokenCreate
		)
		m.oldValue = func(ctx context.Context) (*L1TokenCreate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().L1TokenCreate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withL1TokenCreate sets the old L1TokenCreate of the mutation.
func withL1TokenCreate(node *L1TokenCreate) l1tokencreateOption {
	return func(m *L1TokenCreateMutation) {
		m.oldValue = func(context.Context) (*L1TokenCreate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m L1TokenCreateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m L1TokenCreateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of L1TokenCreate entities.
func (m *L1TokenCreateMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *L1TokenCreateMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *L1TokenCreateMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().L1TokenCreate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *L1TokenCreateMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *L1TokenCreateMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the L1TokenCreate entity.
// If the L1TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *L1TokenCreateMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *L1TokenCreateMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *L1TokenCreateMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *L1TokenCreateMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the L1TokenCreate entity.
// If the L1TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *L1TokenCreateMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *L1TokenCreateMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetIssuerPublicKey sets the "issuer_public_key" field.
func (m *L1TokenCreateMutation) SetIssuerPublicKey(k keys.Public) {
	m.issuer_public_key = &k
}

// IssuerPublicKey returns the value of the "issuer_public_key" field in the mutation.
func (m *L1TokenCreateMutation) IssuerPublicKey() (r keys.Public, exists bool) {
	v := m.issuer_public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuerPublicKey returns the old "issuer_public_key" field's value of the L1TokenCreate entity.
// If the L1TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *L1TokenCreateMutation) OldIssuerPublicKey(ctx context.Context) (v keys.Public, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuerPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuerPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuerPublicKey: %w", err)
	}
	return oldValue.IssuerPublicKey, nil
}

// ResetIssuerPublicKey resets all changes to the "issuer_public_key" field.
func (m *L1TokenCreateMutation) ResetIssuerPublicKey() {
	m.issuer_public_key = nil
}

// SetTokenName sets the "token_name" field.
func (m *L1TokenCreateMutation) SetTokenName(s string) {
	m.token_name = &s
}

// TokenName returns the value of the "token_name" field in the mutation.
func (m *L1TokenCreateMutation) TokenName() (r string, exists bool) {
	v := m.token_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenName returns the old "token_name" field's value of the L1TokenCreate entity.
// If the L1TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *L1TokenCreateMutation) OldTokenName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenName: %w", err)
	}
	return oldValue.TokenName, nil
}

// ResetTokenName resets all changes to the "token_name" field.
func (m *L1TokenCreateMutation) ResetTokenName() {
	m.token_name = nil
}

// SetTokenTicker sets the "token_ticker" field.
func (m *L1TokenCreateMutation) SetTokenTicker(s string) {
	m.token_ticker = &s
}

// TokenTicker returns the value of the "token_ticker" field in the mutation.
func (m *L1TokenCreateMutation) TokenTicker() (r string, exists bool) {
	v := m.token_ticker
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenTicker returns the old "token_ticker" field's value of the L1TokenCreate entity.
// If the L1TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *L1TokenCreateMutation) OldTokenTicker(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenTicker is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenTicker requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenTicker: %w", err)
	}
	return oldValue.TokenTicker, nil
}

// ResetTokenTicker resets all changes to the "token_ticker" field.
func (m *L1TokenCreateMutation) ResetTokenTicker() {
	m.token_ticker = nil
}

// SetDecimals sets the "decimals" field.
func (m *L1TokenCreateMutation) SetDecimals(u uint8) {
	m.decimals = &u
	m.adddecimals = nil
}

// Decimals returns the value of the "decimals" field in the mutation.
func (m *L1TokenCreateMutation) Decimals() (r uint8, exists bool) {
	v := m.decimals
	if v == nil {
		return
	}
	return *v, true
}

// OldDecimals returns the old "decimals" field's value of the L1TokenCreate entity.
// If the L1TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *L1TokenCreateMutation) OldDecimals(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDecimals is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDecimals requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDecimals: %w", err)
	}
	return oldValue.Decimals, nil
}

// AddDecimals adds u to the "decimals" field.
func (m *L1TokenCreateMutation) AddDecimals(u int8) {
	if m.adddecimals != nil {
		*m.adddecimals += u
	} else {
		m.adddecimals = &u
	}
}

// AddedDecimals returns the value that was added to the "decimals" field in this mutation.
func (m *L1TokenCreateMutation) AddedDecimals() (r int8, exists bool) {
	v := m.adddecimals
	if v == nil {
		return
	}
	return *v, true
}

// ResetDecimals resets all changes to the "decimals" field.
func (m *L1TokenCreateMutation) ResetDecimals() {
	m.decimals = nil
	m.adddecimals = nil
}

// SetMaxSupply sets the "max_supply" field.
func (m *L1TokenCreateMutation) SetMaxSupply(b []byte) {
	m.max_supply = &b
}

// MaxSupply returns the value of the "max_supply" field in the mutation.
func (m *L1TokenCreateMutation) MaxSupply() (r []byte, exists bool) {
	v := m.max_supply
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxSupply returns the old "max_supply" field's value of the L1TokenCreate entity.
// If the L1TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *L1TokenCreateMutation) OldMaxSupply(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxSupply is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxSupply requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxSupply: %w", err)
	}
	return oldValue.MaxSupply, nil
}

// ResetMaxSupply resets all changes to the "max_supply" field.
func (m *L1TokenCreateMutation) ResetMaxSupply() {
	m.max_supply = nil
}

// SetIsFreezable sets the "is_freezable" field.
func (m *L1TokenCreateMutation) SetIsFreezable(b bool) {
	m.is_freezable = &b
}

// IsFreezable returns the value of the "is_freezable" field in the mutation.
func (m *L1TokenCreateMutation) IsFreezable() (r bool, exists bool) {
	v := m.is_freezable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFreezable returns the old "is_freezable" field's value of the L1TokenCreate entity.
// If the L1TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *L1TokenCreateMutation) OldIsFreezable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFreezable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFreezable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFreezable: %w", err)
	}
	return oldValue.IsFreezable, nil
}

// ResetIsFreezable resets all changes to the "is_freezable" field.
func (m *L1TokenCreateMutation) ResetIsFreezable() {
	m.is_freezable = nil
}

// SetNetwork sets the "network" field.
func (m *L1TokenCreateMutation) SetNetwork(s schematype.Network) {
	m.network = &s
}

// Network returns the value of the "network" field in the mutation.
func (m *L1TokenCreateMutation) Network() (r schematype.Network, exists bool) {
	v := m.network
	if v == nil {
		return
	}
	return *v, true
}

// OldNetwork returns the old "network" field's value of the L1TokenCreate entity.
// If the L1TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *L1TokenCreateMutation) OldNetwork(ctx context.Context) (v schematype.Network, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetwork is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetwork requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetwork: %w", err)
	}
	return oldValue.Network, nil
}

// ResetNetwork resets all changes to the "network" field.
func (m *L1TokenCreateMutation) ResetNetwork() {
	m.network = nil
}

// SetTokenIdentifier sets the "token_identifier" field.
func (m *L1TokenCreateMutation) SetTokenIdentifier(b []byte) {
	m.token_identifier = &b
}

// TokenIdentifier returns the value of the "token_identifier" field in the mutation.
func (m *L1TokenCreateMutation) TokenIdentifier() (r []byte, exists bool) {
	v := m.token_identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenIdentifier returns the old "token_identifier" field's value of the L1TokenCreate entity.
// If the L1TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *L1TokenCreateMutation) OldTokenIdentifier(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenIdentifier: %w", err)
	}
	return oldValue.TokenIdentifier, nil
}

// ResetTokenIdentifier resets all changes to the "token_identifier" field.
func (m *L1TokenCreateMutation) ResetTokenIdentifier() {
	m.token_identifier = nil
}

// SetTransactionID sets the "transaction_id" field.
func (m *L1TokenCreateMutation) SetTransactionID(b []byte) {
	m.transaction_id = &b
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *L1TokenCreateMutation) TransactionID() (r []byte, exists bool) {
	v := m.transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the L1TokenCreate entity.
// If the L1TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *L1TokenCreateMutation) OldTransactionID(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *L1TokenCreateMutation) ResetTransactionID() {
	m.transaction_id = nil
}

// Where appends a list predicates to the L1TokenCreateMutation builder.
func (m *L1TokenCreateMutation) Where(ps ...predicate.L1TokenCreate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the L1TokenCreateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *L1TokenCreateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.L1TokenCreate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *L1TokenCreateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *L1TokenCreateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (L1TokenCreate).
func (m *L1TokenCreateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *L1TokenCreateMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.create_time != nil {
		fields = append(fields, l1tokencreate.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, l1tokencreate.FieldUpdateTime)
	}
	if m.issuer_public_key != nil {
		fields = append(fields, l1tokencreate.FieldIssuerPublicKey)
	}
	if m.token_name != nil {
		fields = append(fields, l1tokencreate.FieldTokenName)
	}
	if m.token_ticker != nil {
		fields = append(fields, l1tokencreate.FieldTokenTicker)
	}
	if m.decimals != nil {
		fields = append(fields, l1tokencreate.FieldDecimals)
	}
	if m.max_supply != nil {
		fields = append(fields, l1tokencreate.FieldMaxSupply)
	}
	if m.is_freezable != nil {
		fields = append(fields, l1tokencreate.FieldIsFreezable)
	}
	if m.network != nil {
		fields = append(fields, l1tokencreate.FieldNetwork)
	}
	if m.token_identifier != nil {
		fields = append(fields, l1tokencreate.FieldTokenIdentifier)
	}
	if m.transaction_id != nil {
		fields = append(fields, l1tokencreate.FieldTransactionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *L1TokenCreateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case l1tokencreate.FieldCreateTime:
		return m.CreateTime()
	case l1tokencreate.FieldUpdateTime:
		return m.UpdateTime()
	case l1tokencreate.FieldIssuerPublicKey:
		return m.IssuerPublicKey()
	case l1tokencreate.FieldTokenName:
		return m.TokenName()
	case l1tokencreate.FieldTokenTicker:
		return m.TokenTicker()
	case l1tokencreate.FieldDecimals:
		return m.Decimals()
	case l1tokencreate.FieldMaxSupply:
		return m.MaxSupply()
	case l1tokencreate.FieldIsFreezable:
		return m.IsFreezable()
	case l1tokencreate.FieldNetwork:
		return m.Network()
	case l1tokencreate.FieldTokenIdentifier:
		return m.TokenIdentifier()
	case l1tokencreate.FieldTransactionID:
		return m.TransactionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *L1TokenCreateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case l1tokencreate.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case l1tokencreate.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case l1tokencreate.FieldIssuerPublicKey:
		return m.OldIssuerPublicKey(ctx)
	case l1tokencreate.FieldTokenName:
		return m.OldTokenName(ctx)
	case l1tokencreate.FieldTokenTicker:
		return m.OldTokenTicker(ctx)
	case l1tokencreate.FieldDecimals:
		return m.OldDecimals(ctx)
	case l1tokencreate.FieldMaxSupply:
		return m.OldMaxSupply(ctx)
	case l1tokencreate.FieldIsFreezable:
		return m.OldIsFreezable(ctx)
	case l1tokencreate.FieldNetwork:
		return m.OldNetwork(ctx)
	case l1tokencreate.FieldTokenIdentifier:
		return m.OldTokenIdentifier(ctx)
	case l1tokencreate.FieldTransactionID:
		return m.OldTransactionID(ctx)
	}
	return nil, fmt.Errorf("unknown L1TokenCreate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *L1TokenCreateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case l1tokencreate.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case l1tokencreate.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case l1tokencreate.FieldIssuerPublicKey:
		v, ok := value.(keys.Public)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuerPublicKey(v)
		return nil
	case l1tokencreate.FieldTokenName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenName(v)
		return nil
	case l1tokencreate.FieldTokenTicker:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenTicker(v)
		return nil
	case l1tokencreate.FieldDecimals:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDecimals(v)
		return nil
	case l1tokencreate.FieldMaxSupply:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxSupply(v)
		return nil
	case l1tokencreate.FieldIsFreezable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFreezable(v)
		return nil
	case l1tokencreate.FieldNetwork:
		v, ok := value.(schematype.Network)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetwork(v)
		return nil
	case l1tokencreate.FieldTokenIdentifier:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenIdentifier(v)
		return nil
	case l1tokencreate.FieldTransactionID:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	}
	return fmt.Errorf("unknown L1TokenCreate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *L1TokenCreateMutation) AddedFields() []string {
	var fields []string
	if m.adddecimals != nil {
		fields = append(fields, l1tokencreate.FieldDecimals)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *L1TokenCreateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case l1tokencreate.FieldDecimals:
		return m.AddedDecimals()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *L1TokenCreateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case l1tokencreate.FieldDecimals:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDecimals(v)
		return nil
	}
	return fmt.Errorf("unknown L1TokenCreate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *L1TokenCreateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *L1TokenCreateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *L1TokenCreateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown L1TokenCreate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *L1TokenCreateMutation) ResetField(name string) error {
	switch name {
	case l1tokencreate.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case l1tokencreate.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case l1tokencreate.FieldIssuerPublicKey:
		m.ResetIssuerPublicKey()
		return nil
	case l1tokencreate.FieldTokenName:
		m.ResetTokenName()
		return nil
	case l1tokencreate.FieldTokenTicker:
		m.ResetTokenTicker()
		return nil
	case l1tokencreate.FieldDecimals:
		m.ResetDecimals()
		return nil
	case l1tokencreate.FieldMaxSupply:
		m.ResetMaxSupply()
		return nil
	case l1tokencreate.FieldIsFreezable:
		m.ResetIsFreezable()
		return nil
	case l1tokencreate.FieldNetwork:
		m.ResetNetwork()
		return nil
	case l1tokencreate.FieldTokenIdentifier:
		m.ResetTokenIdentifier()
		return nil
	case l1tokencreate.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	}
	return fmt.Errorf("unknown L1TokenCreate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *L1TokenCreateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *L1TokenCreateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *L1TokenCreateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *L1TokenCreateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *L1TokenCreateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *L1TokenCreateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *L1TokenCreateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown L1TokenCreate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *L1TokenCreateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown L1TokenCreate edge %s", name)
}

// PaymentIntentMutation represents an operation that mutates the PaymentIntent nodes in the graph.
type PaymentIntentMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	create_time              *time.Time
	update_time              *time.Time
	payment_intent           *string
	clearedFields            map[string]struct{}
	transfer                 map[uuid.UUID]struct{}
	removedtransfer          map[uuid.UUID]struct{}
	clearedtransfer          bool
	token_transaction        map[uuid.UUID]struct{}
	removedtoken_transaction map[uuid.UUID]struct{}
	clearedtoken_transaction bool
	done                     bool
	oldValue                 func(context.Context) (*PaymentIntent, error)
	predicates               []predicate.PaymentIntent
}

var _ ent.Mutation = (*PaymentIntentMutation)(nil)

// paymentintentOption allows management of the mutation configuration using functional options.
type paymentintentOption func(*PaymentIntentMutation)

// newPaymentIntentMutation creates new mutation for the PaymentIntent entity.
func newPaymentIntentMutation(c config, op Op, opts ...paymentintentOption) *PaymentIntentMutation {
	m := &PaymentIntentMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentIntent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentIntentID sets the ID field of the mutation.
func withPaymentIntentID(id uuid.UUID) paymentintentOption {
	return func(m *PaymentIntentMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentIntent
		)
		m.oldValue = func(ctx context.Context) (*PaymentIntent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentIntent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentIntent sets the old PaymentIntent of the mutation.
func withPaymentIntent(node *PaymentIntent) paymentintentOption {
	return func(m *PaymentIntentMutation) {
		m.oldValue = func(context.Context) (*PaymentIntent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentIntentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentIntentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaymentIntent entities.
func (m *PaymentIntentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentIntentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentIntentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaymentIntent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PaymentIntentMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PaymentIntentMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the PaymentIntent entity.
// If the PaymentIntent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentIntentMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PaymentIntentMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PaymentIntentMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PaymentIntentMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PaymentIntent entity.
// If the PaymentIntent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentIntentMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PaymentIntentMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPaymentIntent sets the "payment_intent" field.
func (m *PaymentIntentMutation) SetPaymentIntent(s string) {
	m.payment_intent = &s
}

// PaymentIntent returns the value of the "payment_intent" field in the mutation.
func (m *PaymentIntentMutation) PaymentIntent() (r string, exists bool) {
	v := m.payment_intent
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentIntent returns the old "payment_intent" field's value of the PaymentIntent entity.
// If the PaymentIntent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentIntentMutation) OldPaymentIntent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentIntent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentIntent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentIntent: %w", err)
	}
	return oldValue.PaymentIntent, nil
}

// ResetPaymentIntent resets all changes to the "payment_intent" field.
func (m *PaymentIntentMutation) ResetPaymentIntent() {
	m.payment_intent = nil
}

// AddTransferIDs adds the "transfer" edge to the Transfer entity by ids.
func (m *PaymentIntentMutation) AddTransferIDs(ids ...uuid.UUID) {
	if m.transfer == nil {
		m.transfer = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.transfer[ids[i]] = struct{}{}
	}
}

// ClearTransfer clears the "transfer" edge to the Transfer entity.
func (m *PaymentIntentMutation) ClearTransfer() {
	m.clearedtransfer = true
}

// TransferCleared reports if the "transfer" edge to the Transfer entity was cleared.
func (m *PaymentIntentMutation) TransferCleared() bool {
	return m.clearedtransfer
}

// RemoveTransferIDs removes the "transfer" edge to the Transfer entity by IDs.
func (m *PaymentIntentMutation) RemoveTransferIDs(ids ...uuid.UUID) {
	if m.removedtransfer == nil {
		m.removedtransfer = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.transfer, ids[i])
		m.removedtransfer[ids[i]] = struct{}{}
	}
}

// RemovedTransfer returns the removed IDs of the "transfer" edge to the Transfer entity.
func (m *PaymentIntentMutation) RemovedTransferIDs() (ids []uuid.UUID) {
	for id := range m.removedtransfer {
		ids = append(ids, id)
	}
	return
}

// TransferIDs returns the "transfer" edge IDs in the mutation.
func (m *PaymentIntentMutation) TransferIDs() (ids []uuid.UUID) {
	for id := range m.transfer {
		ids = append(ids, id)
	}
	return
}

// ResetTransfer resets all changes to the "transfer" edge.
func (m *PaymentIntentMutation) ResetTransfer() {
	m.transfer = nil
	m.clearedtransfer = false
	m.removedtransfer = nil
}

// AddTokenTransactionIDs adds the "token_transaction" edge to the TokenTransaction entity by ids.
func (m *PaymentIntentMutation) AddTokenTransactionIDs(ids ...uuid.UUID) {
	if m.token_transaction == nil {
		m.token_transaction = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.token_transaction[ids[i]] = struct{}{}
	}
}

// ClearTokenTransaction clears the "token_transaction" edge to the TokenTransaction entity.
func (m *PaymentIntentMutation) ClearTokenTransaction() {
	m.clearedtoken_transaction = true
}

// TokenTransactionCleared reports if the "token_transaction" edge to the TokenTransaction entity was cleared.
func (m *PaymentIntentMutation) TokenTransactionCleared() bool {
	return m.clearedtoken_transaction
}

// RemoveTokenTransactionIDs removes the "token_transaction" edge to the TokenTransaction entity by IDs.
func (m *PaymentIntentMutation) RemoveTokenTransactionIDs(ids ...uuid.UUID) {
	if m.removedtoken_transaction == nil {
		m.removedtoken_transaction = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.token_transaction, ids[i])
		m.removedtoken_transaction[ids[i]] = struct{}{}
	}
}

// RemovedTokenTransaction returns the removed IDs of the "token_transaction" edge to the TokenTransaction entity.
func (m *PaymentIntentMutation) RemovedTokenTransactionIDs() (ids []uuid.UUID) {
	for id := range m.removedtoken_transaction {
		ids = append(ids, id)
	}
	return
}

// TokenTransactionIDs returns the "token_transaction" edge IDs in the mutation.
func (m *PaymentIntentMutation) TokenTransactionIDs() (ids []uuid.UUID) {
	for id := range m.token_transaction {
		ids = append(ids, id)
	}
	return
}

// ResetTokenTransaction resets all changes to the "token_transaction" edge.
func (m *PaymentIntentMutation) ResetTokenTransaction() {
	m.token_transaction = nil
	m.clearedtoken_transaction = false
	m.removedtoken_transaction = nil
}

// Where appends a list predicates to the PaymentIntentMutation builder.
func (m *PaymentIntentMutation) Where(ps ...predicate.PaymentIntent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentIntentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentIntentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaymentIntent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentIntentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentIntentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaymentIntent).
func (m *PaymentIntentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentIntentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, paymentintent.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, paymentintent.FieldUpdateTime)
	}
	if m.payment_intent != nil {
		fields = append(fields, paymentintent.FieldPaymentIntent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentIntentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymentintent.FieldCreateTime:
		return m.CreateTime()
	case paymentintent.FieldUpdateTime:
		return m.UpdateTime()
	case paymentintent.FieldPaymentIntent:
		return m.PaymentIntent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentIntentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymentintent.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case paymentintent.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case paymentintent.FieldPaymentIntent:
		return m.OldPaymentIntent(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentIntent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentIntentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymentintent.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case paymentintent.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case paymentintent.FieldPaymentIntent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentIntent(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentIntent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentIntentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentIntentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentIntentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PaymentIntent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentIntentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentIntentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentIntentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PaymentIntent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentIntentMutation) ResetField(name string) error {
	switch name {
	case paymentintent.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case paymentintent.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case paymentintent.FieldPaymentIntent:
		m.ResetPaymentIntent()
		return nil
	}
	return fmt.Errorf("unknown PaymentIntent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentIntentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.transfer != nil {
		edges = append(edges, paymentintent.EdgeTransfer)
	}
	if m.token_transaction != nil {
		edges = append(edges, paymentintent.EdgeTokenTransaction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentIntentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paymentintent.EdgeTransfer:
		ids := make([]ent.Value, 0, len(m.transfer))
		for id := range m.transfer {
			ids = append(ids, id)
		}
		return ids
	case paymentintent.EdgeTokenTransaction:
		ids := make([]ent.Value, 0, len(m.token_transaction))
		for id := range m.token_transaction {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentIntentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtransfer != nil {
		edges = append(edges, paymentintent.EdgeTransfer)
	}
	if m.removedtoken_transaction != nil {
		edges = append(edges, paymentintent.EdgeTokenTransaction)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentIntentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case paymentintent.EdgeTransfer:
		ids := make([]ent.Value, 0, len(m.removedtransfer))
		for id := range m.removedtransfer {
			ids = append(ids, id)
		}
		return ids
	case paymentintent.EdgeTokenTransaction:
		ids := make([]ent.Value, 0, len(m.removedtoken_transaction))
		for id := range m.removedtoken_transaction {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentIntentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtransfer {
		edges = append(edges, paymentintent.EdgeTransfer)
	}
	if m.clearedtoken_transaction {
		edges = append(edges, paymentintent.EdgeTokenTransaction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentIntentMutation) EdgeCleared(name string) bool {
	switch name {
	case paymentintent.EdgeTransfer:
		return m.clearedtransfer
	case paymentintent.EdgeTokenTransaction:
		return m.clearedtoken_transaction
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentIntentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PaymentIntent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentIntentMutation) ResetEdge(name string) error {
	switch name {
	case paymentintent.EdgeTransfer:
		m.ResetTransfer()
		return nil
	case paymentintent.EdgeTokenTransaction:
		m.ResetTokenTransaction()
		return nil
	}
	return fmt.Errorf("unknown PaymentIntent edge %s", name)
}

// PendingSendTransferMutation represents an operation that mutates the PendingSendTransfer nodes in the graph.
type PendingSendTransferMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	create_time   *time.Time
	update_time   *time.Time
	transfer_id   *uuid.UUID
	status        *schematype.PendingSendTransferStatus
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PendingSendTransfer, error)
	predicates    []predicate.PendingSendTransfer
}

var _ ent.Mutation = (*PendingSendTransferMutation)(nil)

// pendingsendtransferOption allows management of the mutation configuration using functional options.
type pendingsendtransferOption func(*PendingSendTransferMutation)

// newPendingSendTransferMutation creates new mutation for the PendingSendTransfer entity.
func newPendingSendTransferMutation(c config, op Op, opts ...pendingsendtransferOption) *PendingSendTransferMutation {
	m := &PendingSendTransferMutation{
		config:        c,
		op:            op,
		typ:           TypePendingSendTransfer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPendingSendTransferID sets the ID field of the mutation.
func withPendingSendTransferID(id uuid.UUID) pendingsendtransferOption {
	return func(m *PendingSendTransferMutation) {
		var (
			err   error
			once  sync.Once
			value *PendingSendTransfer
		)
		m.oldValue = func(ctx context.Context) (*PendingSendTransfer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PendingSendTransfer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPendingSendTransfer sets the old PendingSendTransfer of the mutation.
func withPendingSendTransfer(node *PendingSendTransfer) pendingsendtransferOption {
	return func(m *PendingSendTransferMutation) {
		m.oldValue = func(context.Context) (*PendingSendTransfer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PendingSendTransferMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PendingSendTransferMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PendingSendTransfer entities.
func (m *PendingSendTransferMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PendingSendTransferMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PendingSendTransferMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PendingSendTransfer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PendingSendTransferMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PendingSendTransferMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the PendingSendTransfer entity.
// If the PendingSendTransfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingSendTransferMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PendingSendTransferMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PendingSendTransferMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PendingSendTransferMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PendingSendTransfer entity.
// If the PendingSendTransfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingSendTransferMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PendingSendTransferMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTransferID sets the "transfer_id" field.
func (m *PendingSendTransferMutation) SetTransferID(u uuid.UUID) {
	m.transfer_id = &u
}

// TransferID returns the value of the "transfer_id" field in the mutation.
func (m *PendingSendTransferMutation) TransferID() (r uuid.UUID, exists bool) {
	v := m.transfer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTransferID returns the old "transfer_id" field's value of the PendingSendTransfer entity.
// If the PendingSendTransfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingSendTransferMutation) OldTransferID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransferID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransferID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransferID: %w", err)
	}
	return oldValue.TransferID, nil
}

// ResetTransferID resets all changes to the "transfer_id" field.
func (m *PendingSendTransferMutation) ResetTransferID() {
	m.transfer_id = nil
}

// SetStatus sets the "status" field.
func (m *PendingSendTransferMutation) SetStatus(ssts schematype.PendingSendTransferStatus) {
	m.status = &ssts
}

// Status returns the value of the "status" field in the mutation.
func (m *PendingSendTransferMutation) Status() (r schematype.PendingSendTransferStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PendingSendTransfer entity.
// If the PendingSendTransfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingSendTransferMutation) OldStatus(ctx context.Context) (v schematype.PendingSendTransferStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PendingSendTransferMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the PendingSendTransferMutation builder.
func (m *PendingSendTransferMutation) Where(ps ...predicate.PendingSendTransfer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PendingSendTransferMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PendingSendTransferMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PendingSendTransfer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PendingSendTransferMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PendingSendTransferMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PendingSendTransfer).
func (m *PendingSendTransferMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PendingSendTransferMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, pendingsendtransfer.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, pendingsendtransfer.FieldUpdateTime)
	}
	if m.transfer_id != nil {
		fields = append(fields, pendingsendtransfer.FieldTransferID)
	}
	if m.status != nil {
		fields = append(fields, pendingsendtransfer.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PendingSendTransferMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pendingsendtransfer.FieldCreateTime:
		return m.CreateTime()
	case pendingsendtransfer.FieldUpdateTime:
		return m.UpdateTime()
	case pendingsendtransfer.FieldTransferID:
		return m.TransferID()
	case pendingsendtransfer.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PendingSendTransferMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pendingsendtransfer.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case pendingsendtransfer.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case pendingsendtransfer.FieldTransferID:
		return m.OldTransferID(ctx)
	case pendingsendtransfer.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown PendingSendTransfer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PendingSendTransferMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pendingsendtransfer.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case pendingsendtransfer.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case pendingsendtransfer.FieldTransferID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransferID(v)
		return nil
	case pendingsendtransfer.FieldStatus:
		v, ok := value.(schematype.PendingSendTransferStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown PendingSendTransfer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PendingSendTransferMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PendingSendTransferMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PendingSendTransferMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PendingSendTransfer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PendingSendTransferMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PendingSendTransferMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PendingSendTransferMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PendingSendTransfer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PendingSendTransferMutation) ResetField(name string) error {
	switch name {
	case pendingsendtransfer.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case pendingsendtransfer.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case pendingsendtransfer.FieldTransferID:
		m.ResetTransferID()
		return nil
	case pendingsendtransfer.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown PendingSendTransfer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PendingSendTransferMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PendingSendTransferMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PendingSendTransferMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PendingSendTransferMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PendingSendTransferMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PendingSendTransferMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PendingSendTransferMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PendingSendTransfer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PendingSendTransferMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PendingSendTransfer edge %s", name)
}

// PreimageRequestMutation represents an operation that mutates the PreimageRequest nodes in the graph.
type PreimageRequestMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	create_time              *time.Time
	update_time              *time.Time
	payment_hash             *[]byte
	status                   *schematype.PreimageRequestStatus
	receiver_identity_pubkey *keys.Public
	preimage                 *[]byte
	clearedFields            map[string]struct{}
	transactions             map[uuid.UUID]struct{}
	removedtransactions      map[uuid.UUID]struct{}
	clearedtransactions      bool
	preimage_shares          *uuid.UUID
	clearedpreimage_shares   bool
	transfers                *uuid.UUID
	clearedtransfers         bool
	done                     bool
	oldValue                 func(context.Context) (*PreimageRequest, error)
	predicates               []predicate.PreimageRequest
}

var _ ent.Mutation = (*PreimageRequestMutation)(nil)

// preimagerequestOption allows management of the mutation configuration using functional options.
type preimagerequestOption func(*PreimageRequestMutation)

// newPreimageRequestMutation creates new mutation for the PreimageRequest entity.
func newPreimageRequestMutation(c config, op Op, opts ...preimagerequestOption) *PreimageRequestMutation {
	m := &PreimageRequestMutation{
		config:        c,
		op:            op,
		typ:           TypePreimageRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPreimageRequestID sets the ID field of the mutation.
func withPreimageRequestID(id uuid.UUID) preimagerequestOption {
	return func(m *PreimageRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *PreimageRequest
		)
		m.oldValue = func(ctx context.Context) (*PreimageRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PreimageRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPreimageRequest sets the old PreimageRequest of the mutation.
func withPreimageRequest(node *PreimageRequest) preimagerequestOption {
	return func(m *PreimageRequestMutation) {
		m.oldValue = func(context.Context) (*PreimageRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PreimageRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PreimageRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PreimageRequest entities.
func (m *PreimageRequestMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PreimageRequestMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PreimageRequestMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PreimageRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PreimageRequestMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PreimageRequestMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the PreimageRequest entity.
// If the PreimageRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageRequestMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PreimageRequestMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PreimageRequestMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PreimageRequestMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PreimageRequest entity.
// If the PreimageRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageRequestMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PreimageRequestMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPaymentHash sets the "payment_hash" field.
func (m *PreimageRequestMutation) SetPaymentHash(b []byte) {
	m.payment_hash = &b
}

// PaymentHash returns the value of the "payment_hash" field in the mutation.
func (m *PreimageRequestMutation) PaymentHash() (r []byte, exists bool) {
	v := m.payment_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentHash returns the old "payment_hash" field's value of the PreimageRequest entity.
// If the PreimageRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageRequestMutation) OldPaymentHash(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentHash: %w", err)
	}
	return oldValue.PaymentHash, nil
}

// ResetPaymentHash resets all changes to the "payment_hash" field.
func (m *PreimageRequestMutation) ResetPaymentHash() {
	m.payment_hash = nil
}

// SetStatus sets the "status" field.
func (m *PreimageRequestMutation) SetStatus(srs schematype.PreimageRequestStatus) {
	m.status = &srs
}

// Status returns the value of the "status" field in the mutation.
func (m *PreimageRequestMutation) Status() (r schematype.PreimageRequestStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PreimageRequest entity.
// If the PreimageRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageRequestMutation) OldStatus(ctx context.Context) (v schematype.PreimageRequestStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PreimageRequestMutation) ResetStatus() {
	m.status = nil
}

// SetReceiverIdentityPubkey sets the "receiver_identity_pubkey" field.
func (m *PreimageRequestMutation) SetReceiverIdentityPubkey(k keys.Public) {
	m.receiver_identity_pubkey = &k
}

// ReceiverIdentityPubkey returns the value of the "receiver_identity_pubkey" field in the mutation.
func (m *PreimageRequestMutation) ReceiverIdentityPubkey() (r keys.Public, exists bool) {
	v := m.receiver_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverIdentityPubkey returns the old "receiver_identity_pubkey" field's value of the PreimageRequest entity.
// If the PreimageRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageRequestMutation) OldReceiverIdentityPubkey(ctx context.Context) (v keys.Public, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverIdentityPubkey: %w", err)
	}
	return oldValue.ReceiverIdentityPubkey, nil
}

// ClearReceiverIdentityPubkey clears the value of the "receiver_identity_pubkey" field.
func (m *PreimageRequestMutation) ClearReceiverIdentityPubkey() {
	m.receiver_identity_pubkey = nil
	m.clearedFields[preimagerequest.FieldReceiverIdentityPubkey] = struct{}{}
}

// ReceiverIdentityPubkeyCleared returns if the "receiver_identity_pubkey" field was cleared in this mutation.
func (m *PreimageRequestMutation) ReceiverIdentityPubkeyCleared() bool {
	_, ok := m.clearedFields[preimagerequest.FieldReceiverIdentityPubkey]
	return ok
}

// ResetReceiverIdentityPubkey resets all changes to the "receiver_identity_pubkey" field.
func (m *PreimageRequestMutation) ResetReceiverIdentityPubkey() {
	m.receiver_identity_pubkey = nil
	delete(m.clearedFields, preimagerequest.FieldReceiverIdentityPubkey)
}

// SetPreimage sets the "preimage" field.
func (m *PreimageRequestMutation) SetPreimage(b []byte) {
	m.preimage = &b
}

// Preimage returns the value of the "preimage" field in the mutation.
func (m *PreimageRequestMutation) Preimage() (r []byte, exists bool) {
	v := m.preimage
	if v == nil {
		return
	}
	return *v, true
}

// OldPreimage returns the old "preimage" field's value of the PreimageRequest entity.
// If the PreimageRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageRequestMutation) OldPreimage(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreimage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreimage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreimage: %w", err)
	}
	return oldValue.Preimage, nil
}

// ClearPreimage clears the value of the "preimage" field.
func (m *PreimageRequestMutation) ClearPreimage() {
	m.preimage = nil
	m.clearedFields[preimagerequest.FieldPreimage] = struct{}{}
}

// PreimageCleared returns if the "preimage" field was cleared in this mutation.
func (m *PreimageRequestMutation) PreimageCleared() bool {
	_, ok := m.clearedFields[preimagerequest.FieldPreimage]
	return ok
}

// ResetPreimage resets all changes to the "preimage" field.
func (m *PreimageRequestMutation) ResetPreimage() {
	m.preimage = nil
	delete(m.clearedFields, preimagerequest.FieldPreimage)
}

// AddTransactionIDs adds the "transactions" edge to the UserSignedTransaction entity by ids.
func (m *PreimageRequestMutation) AddTransactionIDs(ids ...uuid.UUID) {
	if m.transactions == nil {
		m.transactions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the UserSignedTransaction entity.
func (m *PreimageRequestMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the UserSignedTransaction entity was cleared.
func (m *PreimageRequestMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the UserSignedTransaction entity by IDs.
func (m *PreimageRequestMutation) RemoveTransactionIDs(ids ...uuid.UUID) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the UserSignedTransaction entity.
func (m *PreimageRequestMutation) RemovedTransactionsIDs() (ids []uuid.UUID) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *PreimageRequestMutation) TransactionsIDs() (ids []uuid.UUID) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *PreimageRequestMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// SetPreimageSharesID sets the "preimage_shares" edge to the PreimageShare entity by id.
func (m *PreimageRequestMutation) SetPreimageSharesID(id uuid.UUID) {
	m.preimage_shares = &id
}

// ClearPreimageShares clears the "preimage_shares" edge to the PreimageShare entity.
func (m *PreimageRequestMutation) ClearPreimageShares() {
	m.clearedpreimage_shares = true
}

// PreimageSharesCleared reports if the "preimage_shares" edge to the PreimageShare entity was cleared.
func (m *PreimageRequestMutation) PreimageSharesCleared() bool {
	return m.clearedpreimage_shares
}

// PreimageSharesID returns the "preimage_shares" edge ID in the mutation.
func (m *PreimageRequestMutation) PreimageSharesID() (id uuid.UUID, exists bool) {
	if m.preimage_shares != nil {
		return *m.preimage_shares, true
	}
	return
}

// PreimageSharesIDs returns the "preimage_shares" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PreimageSharesID instead. It exists only for internal usage by the builders.
func (m *PreimageRequestMutation) PreimageSharesIDs() (ids []uuid.UUID) {
	if id := m.preimage_shares; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPreimageShares resets all changes to the "preimage_shares" edge.
func (m *PreimageRequestMutation) ResetPreimageShares() {
	m.preimage_shares = nil
	m.clearedpreimage_shares = false
}

// SetTransfersID sets the "transfers" edge to the Transfer entity by id.
func (m *PreimageRequestMutation) SetTransfersID(id uuid.UUID) {
	m.transfers = &id
}

// ClearTransfers clears the "transfers" edge to the Transfer entity.
func (m *PreimageRequestMutation) ClearTransfers() {
	m.clearedtransfers = true
}

// TransfersCleared reports if the "transfers" edge to the Transfer entity was cleared.
func (m *PreimageRequestMutation) TransfersCleared() bool {
	return m.clearedtransfers
}

// TransfersID returns the "transfers" edge ID in the mutation.
func (m *PreimageRequestMutation) TransfersID() (id uuid.UUID, exists bool) {
	if m.transfers != nil {
		return *m.transfers, true
	}
	return
}

// TransfersIDs returns the "transfers" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransfersID instead. It exists only for internal usage by the builders.
func (m *PreimageRequestMutation) TransfersIDs() (ids []uuid.UUID) {
	if id := m.transfers; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransfers resets all changes to the "transfers" edge.
func (m *PreimageRequestMutation) ResetTransfers() {
	m.transfers = nil
	m.clearedtransfers = false
}

// Where appends a list predicates to the PreimageRequestMutation builder.
func (m *PreimageRequestMutation) Where(ps ...predicate.PreimageRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PreimageRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PreimageRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PreimageRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PreimageRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PreimageRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PreimageRequest).
func (m *PreimageRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PreimageRequestMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, preimagerequest.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, preimagerequest.FieldUpdateTime)
	}
	if m.payment_hash != nil {
		fields = append(fields, preimagerequest.FieldPaymentHash)
	}
	if m.status != nil {
		fields = append(fields, preimagerequest.FieldStatus)
	}
	if m.receiver_identity_pubkey != nil {
		fields = append(fields, preimagerequest.FieldReceiverIdentityPubkey)
	}
	if m.preimage != nil {
		fields = append(fields, preimagerequest.FieldPreimage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PreimageRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case preimagerequest.FieldCreateTime:
		return m.CreateTime()
	case preimagerequest.FieldUpdateTime:
		return m.UpdateTime()
	case preimagerequest.FieldPaymentHash:
		return m.PaymentHash()
	case preimagerequest.FieldStatus:
		return m.Status()
	case preimagerequest.FieldReceiverIdentityPubkey:
		return m.ReceiverIdentityPubkey()
	case preimagerequest.FieldPreimage:
		return m.Preimage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PreimageRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case preimagerequest.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case preimagerequest.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case preimagerequest.FieldPaymentHash:
		return m.OldPaymentHash(ctx)
	case preimagerequest.FieldStatus:
		return m.OldStatus(ctx)
	case preimagerequest.FieldReceiverIdentityPubkey:
		return m.OldReceiverIdentityPubkey(ctx)
	case preimagerequest.FieldPreimage:
		return m.OldPreimage(ctx)
	}
	return nil, fmt.Errorf("unknown PreimageRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PreimageRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case preimagerequest.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case preimagerequest.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case preimagerequest.FieldPaymentHash:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentHash(v)
		return nil
	case preimagerequest.FieldStatus:
		v, ok := value.(schematype.PreimageRequestStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case preimagerequest.FieldReceiverIdentityPubkey:
		v, ok := value.(keys.Public)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverIdentityPubkey(v)
		return nil
	case preimagerequest.FieldPreimage:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreimage(v)
		return nil
	}
	return fmt.Errorf("unknown PreimageRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PreimageRequestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PreimageRequestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PreimageRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PreimageRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PreimageRequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(preimagerequest.FieldReceiverIdentityPubkey) {
		fields = append(fields, preimagerequest.FieldReceiverIdentityPubkey)
	}
	if m.FieldCleared(preimagerequest.FieldPreimage) {
		fields = append(fields, preimagerequest.FieldPreimage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PreimageRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PreimageRequestMutation) ClearField(name string) error {
	switch name {
	case preimagerequest.FieldReceiverIdentityPubkey:
		m.ClearReceiverIdentityPubkey()
		return nil
	case preimagerequest.FieldPreimage:
		m.ClearPreimage()
		return nil
	}
	return fmt.Errorf("unknown PreimageRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PreimageRequestMutation) ResetField(name string) error {
	switch name {
	case preimagerequest.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case preimagerequest.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case preimagerequest.FieldPaymentHash:
		m.ResetPaymentHash()
		return nil
	case preimagerequest.FieldStatus:
		m.ResetStatus()
		return nil
	case preimagerequest.FieldReceiverIdentityPubkey:
		m.ResetReceiverIdentityPubkey()
		return nil
	case preimagerequest.FieldPreimage:
		m.ResetPreimage()
		return nil
	}
	return fmt.Errorf("unknown PreimageRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PreimageRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.transactions != nil {
		edges = append(edges, preimagerequest.EdgeTransactions)
	}
	if m.preimage_shares != nil {
		edges = append(edges, preimagerequest.EdgePreimageShares)
	}
	if m.transfers != nil {
		edges = append(edges, preimagerequest.EdgeTransfers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PreimageRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case preimagerequest.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	case preimagerequest.EdgePreimageShares:
		if id := m.preimage_shares; id != nil {
			return []ent.Value{*id}
		}
	case preimagerequest.EdgeTransfers:
		if id := m.transfers; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PreimageRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtransactions != nil {
		edges = append(edges, preimagerequest.EdgeTransactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PreimageRequestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case preimagerequest.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PreimageRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtransactions {
		edges = append(edges, preimagerequest.EdgeTransactions)
	}
	if m.clearedpreimage_shares {
		edges = append(edges, preimagerequest.EdgePreimageShares)
	}
	if m.clearedtransfers {
		edges = append(edges, preimagerequest.EdgeTransfers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PreimageRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case preimagerequest.EdgeTransactions:
		return m.clearedtransactions
	case preimagerequest.EdgePreimageShares:
		return m.clearedpreimage_shares
	case preimagerequest.EdgeTransfers:
		return m.clearedtransfers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PreimageRequestMutation) ClearEdge(name string) error {
	switch name {
	case preimagerequest.EdgePreimageShares:
		m.ClearPreimageShares()
		return nil
	case preimagerequest.EdgeTransfers:
		m.ClearTransfers()
		return nil
	}
	return fmt.Errorf("unknown PreimageRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PreimageRequestMutation) ResetEdge(name string) error {
	switch name {
	case preimagerequest.EdgeTransactions:
		m.ResetTransactions()
		return nil
	case preimagerequest.EdgePreimageShares:
		m.ResetPreimageShares()
		return nil
	case preimagerequest.EdgeTransfers:
		m.ResetTransfers()
		return nil
	}
	return fmt.Errorf("unknown PreimageRequest edge %s", name)
}

// PreimageShareMutation represents an operation that mutates the PreimageShare nodes in the graph.
type PreimageShareMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	create_time             *time.Time
	update_time             *time.Time
	payment_hash            *[]byte
	preimage_share          *[]byte
	threshold               *int32
	addthreshold            *int32
	owner_identity_pubkey   *keys.Public
	invoice_string          *string
	clearedFields           map[string]struct{}
	preimage_request        *uuid.UUID
	clearedpreimage_request bool
	done                    bool
	oldValue                func(context.Context) (*PreimageShare, error)
	predicates              []predicate.PreimageShare
}

var _ ent.Mutation = (*PreimageShareMutation)(nil)

// preimageshareOption allows management of the mutation configuration using functional options.
type preimageshareOption func(*PreimageShareMutation)

// newPreimageShareMutation creates new mutation for the PreimageShare entity.
func newPreimageShareMutation(c config, op Op, opts ...preimageshareOption) *PreimageShareMutation {
	m := &PreimageShareMutation{
		config:        c,
		op:            op,
		typ:           TypePreimageShare,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPreimageShareID sets the ID field of the mutation.
func withPreimageShareID(id uuid.UUID) preimageshareOption {
	return func(m *PreimageShareMutation) {
		var (
			err   error
			once  sync.Once
			value *PreimageShare
		)
		m.oldValue = func(ctx context.Context) (*PreimageShare, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PreimageShare.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPreimageShare sets the old PreimageShare of the mutation.
func withPreimageShare(node *PreimageShare) preimageshareOption {
	return func(m *PreimageShareMutation) {
		m.oldValue = func(context.Context) (*PreimageShare, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PreimageShareMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PreimageShareMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PreimageShare entities.
func (m *PreimageShareMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PreimageShareMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PreimageShareMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PreimageShare.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PreimageShareMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PreimageShareMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the PreimageShare entity.
// If the PreimageShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageShareMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PreimageShareMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PreimageShareMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PreimageShareMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PreimageShare entity.
// If the PreimageShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageShareMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PreimageShareMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPaymentHash sets the "payment_hash" field.
func (m *PreimageShareMutation) SetPaymentHash(b []byte) {
	m.payment_hash = &b
}

// PaymentHash returns the value of the "payment_hash" field in the mutation.
func (m *PreimageShareMutation) PaymentHash() (r []byte, exists bool) {
	v := m.payment_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentHash returns the old "payment_hash" field's value of the PreimageShare entity.
// If the PreimageShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageShareMutation) OldPaymentHash(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentHash: %w", err)
	}
	return oldValue.PaymentHash, nil
}

// ResetPaymentHash resets all changes to the "payment_hash" field.
func (m *PreimageShareMutation) ResetPaymentHash() {
	m.payment_hash = nil
}

// SetPreimageShare sets the "preimage_share" field.
func (m *PreimageShareMutation) SetPreimageShare(b []byte) {
	m.preimage_share = &b
}

// PreimageShare returns the value of the "preimage_share" field in the mutation.
func (m *PreimageShareMutation) PreimageShare() (r []byte, exists bool) {
	v := m.preimage_share
	if v == nil {
		return
	}
	return *v, true
}

// OldPreimageShare returns the old "preimage_share" field's value of the PreimageShare entity.
// If the PreimageShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageShareMutation) OldPreimageShare(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreimageShare is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreimageShare requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreimageShare: %w", err)
	}
	return oldValue.PreimageShare, nil
}

// ResetPreimageShare resets all changes to the "preimage_share" field.
func (m *PreimageShareMutation) ResetPreimageShare() {
	m.preimage_share = nil
}

// SetThreshold sets the "threshold" field.
func (m *PreimageShareMutation) SetThreshold(i int32) {
	m.threshold = &i
	m.addthreshold = nil
}

// Threshold returns the value of the "threshold" field in the mutation.
func (m *PreimageShareMutation) Threshold() (r int32, exists bool) {
	v := m.threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldThreshold returns the old "threshold" field's value of the PreimageShare entity.
// If the PreimageShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageShareMutation) OldThreshold(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreshold: %w", err)
	}
	return oldValue.Threshold, nil
}

// AddThreshold adds i to the "threshold" field.
func (m *PreimageShareMutation) AddThreshold(i int32) {
	if m.addthreshold != nil {
		*m.addthreshold += i
	} else {
		m.addthreshold = &i
	}
}

// AddedThreshold returns the value that was added to the "threshold" field in this mutation.
func (m *PreimageShareMutation) AddedThreshold() (r int32, exists bool) {
	v := m.addthreshold
	if v == nil {
		return
	}
	return *v, true
}

// ResetThreshold resets all changes to the "threshold" field.
func (m *PreimageShareMutation) ResetThreshold() {
	m.threshold = nil
	m.addthreshold = nil
}

// SetOwnerIdentityPubkey sets the "owner_identity_pubkey" field.
func (m *PreimageShareMutation) SetOwnerIdentityPubkey(k keys.Public) {
	m.owner_identity_pubkey = &k
}

// OwnerIdentityPubkey returns the value of the "owner_identity_pubkey" field in the mutation.
func (m *PreimageShareMutation) OwnerIdentityPubkey() (r keys.Public, exists bool) {
	v := m.owner_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerIdentityPubkey returns the old "owner_identity_pubkey" field's value of the PreimageShare entity.
// If the PreimageShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageShareMutation) OldOwnerIdentityPubkey(ctx context.Context) (v keys.Public, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerIdentityPubkey: %w", err)
	}
	return oldValue.OwnerIdentityPubkey, nil
}

// ResetOwnerIdentityPubkey resets all changes to the "owner_identity_pubkey" field.
func (m *PreimageShareMutation) ResetOwnerIdentityPubkey() {
	m.owner_identity_pubkey = nil
}

// SetInvoiceString sets the "invoice_string" field.
func (m *PreimageShareMutation) SetInvoiceString(s string) {
	m.invoice_string = &s
}

// InvoiceString returns the value of the "invoice_string" field in the mutation.
func (m *PreimageShareMutation) InvoiceString() (r string, exists bool) {
	v := m.invoice_string
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceString returns the old "invoice_string" field's value of the PreimageShare entity.
// If the PreimageShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageShareMutation) OldInvoiceString(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceString is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceString requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceString: %w", err)
	}
	return oldValue.InvoiceString, nil
}

// ResetInvoiceString resets all changes to the "invoice_string" field.
func (m *PreimageShareMutation) ResetInvoiceString() {
	m.invoice_string = nil
}

// SetPreimageRequestID sets the "preimage_request" edge to the PreimageRequest entity by id.
func (m *PreimageShareMutation) SetPreimageRequestID(id uuid.UUID) {
	m.preimage_request = &id
}

// ClearPreimageRequest clears the "preimage_request" edge to the PreimageRequest entity.
func (m *PreimageShareMutation) ClearPreimageRequest() {
	m.clearedpreimage_request = true
}

// PreimageRequestCleared reports if the "preimage_request" edge to the PreimageRequest entity was cleared.
func (m *PreimageShareMutation) PreimageRequestCleared() bool {
	return m.clearedpreimage_request
}

// PreimageRequestID returns the "preimage_request" edge ID in the mutation.
func (m *PreimageShareMutation) PreimageRequestID() (id uuid.UUID, exists bool) {
	if m.preimage_request != nil {
		return *m.preimage_request, true
	}
	return
}

// PreimageRequestIDs returns the "preimage_request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PreimageRequestID instead. It exists only for internal usage by the builders.
func (m *PreimageShareMutation) PreimageRequestIDs() (ids []uuid.UUID) {
	if id := m.preimage_request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPreimageRequest resets all changes to the "preimage_request" edge.
func (m *PreimageShareMutation) ResetPreimageRequest() {
	m.preimage_request = nil
	m.clearedpreimage_request = false
}

// Where appends a list predicates to the PreimageShareMutation builder.
func (m *PreimageShareMutation) Where(ps ...predicate.PreimageShare) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PreimageShareMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PreimageShareMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PreimageShare, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PreimageShareMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PreimageShareMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PreimageShare).
func (m *PreimageShareMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PreimageShareMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, preimageshare.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, preimageshare.FieldUpdateTime)
	}
	if m.payment_hash != nil {
		fields = append(fields, preimageshare.FieldPaymentHash)
	}
	if m.preimage_share != nil {
		fields = append(fields, preimageshare.FieldPreimageShare)
	}
	if m.threshold != nil {
		fields = append(fields, preimageshare.FieldThreshold)
	}
	if m.owner_identity_pubkey != nil {
		fields = append(fields, preimageshare.FieldOwnerIdentityPubkey)
	}
	if m.invoice_string != nil {
		fields = append(fields, preimageshare.FieldInvoiceString)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PreimageShareMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case preimageshare.FieldCreateTime:
		return m.CreateTime()
	case preimageshare.FieldUpdateTime:
		return m.UpdateTime()
	case preimageshare.FieldPaymentHash:
		return m.PaymentHash()
	case preimageshare.FieldPreimageShare:
		return m.PreimageShare()
	case preimageshare.FieldThreshold:
		return m.Threshold()
	case preimageshare.FieldOwnerIdentityPubkey:
		return m.OwnerIdentityPubkey()
	case preimageshare.FieldInvoiceString:
		return m.InvoiceString()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PreimageShareMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case preimageshare.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case preimageshare.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case preimageshare.FieldPaymentHash:
		return m.OldPaymentHash(ctx)
	case preimageshare.FieldPreimageShare:
		return m.OldPreimageShare(ctx)
	case preimageshare.FieldThreshold:
		return m.OldThreshold(ctx)
	case preimageshare.FieldOwnerIdentityPubkey:
		return m.OldOwnerIdentityPubkey(ctx)
	case preimageshare.FieldInvoiceString:
		return m.OldInvoiceString(ctx)
	}
	return nil, fmt.Errorf("unknown PreimageShare field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PreimageShareMutation) SetField(name string, value ent.Value) error {
	switch name {
	case preimageshare.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case preimageshare.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case preimageshare.FieldPaymentHash:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentHash(v)
		return nil
	case preimageshare.FieldPreimageShare:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreimageShare(v)
		return nil
	case preimageshare.FieldThreshold:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreshold(v)
		return nil
	case preimageshare.FieldOwnerIdentityPubkey:
		v, ok := value.(keys.Public)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerIdentityPubkey(v)
		return nil
	case preimageshare.FieldInvoiceString:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceString(v)
		return nil
	}
	return fmt.Errorf("unknown PreimageShare field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PreimageShareMutation) AddedFields() []string {
	var fields []string
	if m.addthreshold != nil {
		fields = append(fields, preimageshare.FieldThreshold)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PreimageShareMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case preimageshare.FieldThreshold:
		return m.AddedThreshold()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PreimageShareMutation) AddField(name string, value ent.Value) error {
	switch name {
	case preimageshare.FieldThreshold:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThreshold(v)
		return nil
	}
	return fmt.Errorf("unknown PreimageShare numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PreimageShareMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PreimageShareMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PreimageShareMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PreimageShare nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PreimageShareMutation) ResetField(name string) error {
	switch name {
	case preimageshare.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case preimageshare.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case preimageshare.FieldPaymentHash:
		m.ResetPaymentHash()
		return nil
	case preimageshare.FieldPreimageShare:
		m.ResetPreimageShare()
		return nil
	case preimageshare.FieldThreshold:
		m.ResetThreshold()
		return nil
	case preimageshare.FieldOwnerIdentityPubkey:
		m.ResetOwnerIdentityPubkey()
		return nil
	case preimageshare.FieldInvoiceString:
		m.ResetInvoiceString()
		return nil
	}
	return fmt.Errorf("unknown PreimageShare field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PreimageShareMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.preimage_request != nil {
		edges = append(edges, preimageshare.EdgePreimageRequest)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PreimageShareMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case preimageshare.EdgePreimageRequest:
		if id := m.preimage_request; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PreimageShareMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PreimageShareMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PreimageShareMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpreimage_request {
		edges = append(edges, preimageshare.EdgePreimageRequest)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PreimageShareMutation) EdgeCleared(name string) bool {
	switch name {
	case preimageshare.EdgePreimageRequest:
		return m.clearedpreimage_request
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PreimageShareMutation) ClearEdge(name string) error {
	switch name {
	case preimageshare.EdgePreimageRequest:
		m.ClearPreimageRequest()
		return nil
	}
	return fmt.Errorf("unknown PreimageShare unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PreimageShareMutation) ResetEdge(name string) error {
	switch name {
	case preimageshare.EdgePreimageRequest:
		m.ResetPreimageRequest()
		return nil
	}
	return fmt.Errorf("unknown PreimageShare edge %s", name)
}

// SigningCommitmentMutation represents an operation that mutates the SigningCommitment nodes in the graph.
type SigningCommitmentMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	create_time       *time.Time
	update_time       *time.Time
	operator_index    *uint
	addoperator_index *int
	status            *schematype.SigningCommitmentStatus
	nonce_commitment  *[]byte
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*SigningCommitment, error)
	predicates        []predicate.SigningCommitment
}

var _ ent.Mutation = (*SigningCommitmentMutation)(nil)

// signingcommitmentOption allows management of the mutation configuration using functional options.
type signingcommitmentOption func(*SigningCommitmentMutation)

// newSigningCommitmentMutation creates new mutation for the SigningCommitment entity.
func newSigningCommitmentMutation(c config, op Op, opts ...signingcommitmentOption) *SigningCommitmentMutation {
	m := &SigningCommitmentMutation{
		config:        c,
		op:            op,
		typ:           TypeSigningCommitment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSigningCommitmentID sets the ID field of the mutation.
func withSigningCommitmentID(id uuid.UUID) signingcommitmentOption {
	return func(m *SigningCommitmentMutation) {
		var (
			err   error
			once  sync.Once
			value *SigningCommitment
		)
		m.oldValue = func(ctx context.Context) (*SigningCommitment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SigningCommitment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSigningCommitment sets the old SigningCommitment of the mutation.
func withSigningCommitment(node *SigningCommitment) signingcommitmentOption {
	return func(m *SigningCommitmentMutation) {
		m.oldValue = func(context.Context) (*SigningCommitment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SigningCommitmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SigningCommitmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SigningCommitment entities.
func (m *SigningCommitmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SigningCommitmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SigningCommitmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SigningCommitment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SigningCommitmentMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SigningCommitmentMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SigningCommitment entity.
// If the SigningCommitment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningCommitmentMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SigningCommitmentMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SigningCommitmentMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SigningCommitmentMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SigningCommitment entity.
// If the SigningCommitment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningCommitmentMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SigningCommitmentMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetOperatorIndex sets the "operator_index" field.
func (m *SigningCommitmentMutation) SetOperatorIndex(u uint) {
	m.operator_index = &u
	m.addoperator_index = nil
}

// OperatorIndex returns the value of the "operator_index" field in the mutation.
func (m *SigningCommitmentMutation) OperatorIndex() (r uint, exists bool) {
	v := m.operator_index
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorIndex returns the old "operator_index" field's value of the SigningCommitment entity.
// If the SigningCommitment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningCommitmentMutation) OldOperatorIndex(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorIndex: %w", err)
	}
	return oldValue.OperatorIndex, nil
}

// AddOperatorIndex adds u to the "operator_index" field.
func (m *SigningCommitmentMutation) AddOperatorIndex(u int) {
	if m.addoperator_index != nil {
		*m.addoperator_index += u
	} else {
		m.addoperator_index = &u
	}
}

// AddedOperatorIndex returns the value that was added to the "operator_index" field in this mutation.
func (m *SigningCommitmentMutation) AddedOperatorIndex() (r int, exists bool) {
	v := m.addoperator_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperatorIndex resets all changes to the "operator_index" field.
func (m *SigningCommitmentMutation) ResetOperatorIndex() {
	m.operator_index = nil
	m.addoperator_index = nil
}

// SetStatus sets the "status" field.
func (m *SigningCommitmentMutation) SetStatus(scs schematype.SigningCommitmentStatus) {
	m.status = &scs
}

// Status returns the value of the "status" field in the mutation.
func (m *SigningCommitmentMutation) Status() (r schematype.SigningCommitmentStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SigningCommitment entity.
// If the SigningCommitment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningCommitmentMutation) OldStatus(ctx context.Context) (v schematype.SigningCommitmentStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SigningCommitmentMutation) ResetStatus() {
	m.status = nil
}

// SetNonceCommitment sets the "nonce_commitment" field.
func (m *SigningCommitmentMutation) SetNonceCommitment(b []byte) {
	m.nonce_commitment = &b
}

// NonceCommitment returns the value of the "nonce_commitment" field in the mutation.
func (m *SigningCommitmentMutation) NonceCommitment() (r []byte, exists bool) {
	v := m.nonce_commitment
	if v == nil {
		return
	}
	return *v, true
}

// OldNonceCommitment returns the old "nonce_commitment" field's value of the SigningCommitment entity.
// If the SigningCommitment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningCommitmentMutation) OldNonceCommitment(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonceCommitment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonceCommitment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonceCommitment: %w", err)
	}
	return oldValue.NonceCommitment, nil
}

// ResetNonceCommitment resets all changes to the "nonce_commitment" field.
func (m *SigningCommitmentMutation) ResetNonceCommitment() {
	m.nonce_commitment = nil
}

// Where appends a list predicates to the SigningCommitmentMutation builder.
func (m *SigningCommitmentMutation) Where(ps ...predicate.SigningCommitment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SigningCommitmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SigningCommitmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SigningCommitment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SigningCommitmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SigningCommitmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SigningCommitment).
func (m *SigningCommitmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SigningCommitmentMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, signingcommitment.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, signingcommitment.FieldUpdateTime)
	}
	if m.operator_index != nil {
		fields = append(fields, signingcommitment.FieldOperatorIndex)
	}
	if m.status != nil {
		fields = append(fields, signingcommitment.FieldStatus)
	}
	if m.nonce_commitment != nil {
		fields = append(fields, signingcommitment.FieldNonceCommitment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SigningCommitmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case signingcommitment.FieldCreateTime:
		return m.CreateTime()
	case signingcommitment.FieldUpdateTime:
		return m.UpdateTime()
	case signingcommitment.FieldOperatorIndex:
		return m.OperatorIndex()
	case signingcommitment.FieldStatus:
		return m.Status()
	case signingcommitment.FieldNonceCommitment:
		return m.NonceCommitment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SigningCommitmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case signingcommitment.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case signingcommitment.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case signingcommitment.FieldOperatorIndex:
		return m.OldOperatorIndex(ctx)
	case signingcommitment.FieldStatus:
		return m.OldStatus(ctx)
	case signingcommitment.FieldNonceCommitment:
		return m.OldNonceCommitment(ctx)
	}
	return nil, fmt.Errorf("unknown SigningCommitment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningCommitmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case signingcommitment.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case signingcommitment.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case signingcommitment.FieldOperatorIndex:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorIndex(v)
		return nil
	case signingcommitment.FieldStatus:
		v, ok := value.(schematype.SigningCommitmentStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case signingcommitment.FieldNonceCommitment:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonceCommitment(v)
		return nil
	}
	return fmt.Errorf("unknown SigningCommitment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SigningCommitmentMutation) AddedFields() []string {
	var fields []string
	if m.addoperator_index != nil {
		fields = append(fields, signingcommitment.FieldOperatorIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SigningCommitmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case signingcommitment.FieldOperatorIndex:
		return m.AddedOperatorIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningCommitmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case signingcommitment.FieldOperatorIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperatorIndex(v)
		return nil
	}
	return fmt.Errorf("unknown SigningCommitment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SigningCommitmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SigningCommitmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SigningCommitmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SigningCommitment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SigningCommitmentMutation) ResetField(name string) error {
	switch name {
	case signingcommitment.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case signingcommitment.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case signingcommitment.FieldOperatorIndex:
		m.ResetOperatorIndex()
		return nil
	case signingcommitment.FieldStatus:
		m.ResetStatus()
		return nil
	case signingcommitment.FieldNonceCommitment:
		m.ResetNonceCommitment()
		return nil
	}
	return fmt.Errorf("unknown SigningCommitment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SigningCommitmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SigningCommitmentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SigningCommitmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SigningCommitmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SigningCommitmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SigningCommitmentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SigningCommitmentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SigningCommitment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SigningCommitmentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SigningCommitment edge %s", name)
}

// SigningKeyshareMutation represents an operation that mutates the SigningKeyshare nodes in the graph.
type SigningKeyshareMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	create_time          *time.Time
	update_time          *time.Time
	status               *schematype.SigningKeyshareStatus
	secret_share         *[]byte
	public_shares        *map[string]keys.Public
	public_key           *keys.Public
	min_signers          *int32
	addmin_signers       *int32
	coordinator_index    *uint64
	addcoordinator_index *int64
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*SigningKeyshare, error)
	predicates           []predicate.SigningKeyshare
}

var _ ent.Mutation = (*SigningKeyshareMutation)(nil)

// signingkeyshareOption allows management of the mutation configuration using functional options.
type signingkeyshareOption func(*SigningKeyshareMutation)

// newSigningKeyshareMutation creates new mutation for the SigningKeyshare entity.
func newSigningKeyshareMutation(c config, op Op, opts ...signingkeyshareOption) *SigningKeyshareMutation {
	m := &SigningKeyshareMutation{
		config:        c,
		op:            op,
		typ:           TypeSigningKeyshare,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSigningKeyshareID sets the ID field of the mutation.
func withSigningKeyshareID(id uuid.UUID) signingkeyshareOption {
	return func(m *SigningKeyshareMutation) {
		var (
			err   error
			once  sync.Once
			value *SigningKeyshare
		)
		m.oldValue = func(ctx context.Context) (*SigningKeyshare, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SigningKeyshare.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSigningKeyshare sets the old SigningKeyshare of the mutation.
func withSigningKeyshare(node *SigningKeyshare) signingkeyshareOption {
	return func(m *SigningKeyshareMutation) {
		m.oldValue = func(context.Context) (*SigningKeyshare, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SigningKeyshareMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SigningKeyshareMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SigningKeyshare entities.
func (m *SigningKeyshareMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SigningKeyshareMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SigningKeyshareMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SigningKeyshare.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SigningKeyshareMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SigningKeyshareMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SigningKeyshareMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SigningKeyshareMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SigningKeyshareMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SigningKeyshareMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the "status" field.
func (m *SigningKeyshareMutation) SetStatus(sks schematype.SigningKeyshareStatus) {
	m.status = &sks
}

// Status returns the value of the "status" field in the mutation.
func (m *SigningKeyshareMutation) Status() (r schematype.SigningKeyshareStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldStatus(ctx context.Context) (v schematype.SigningKeyshareStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SigningKeyshareMutation) ResetStatus() {
	m.status = nil
}

// SetSecretShare sets the "secret_share" field.
func (m *SigningKeyshareMutation) SetSecretShare(b []byte) {
	m.secret_share = &b
}

// SecretShare returns the value of the "secret_share" field in the mutation.
func (m *SigningKeyshareMutation) SecretShare() (r []byte, exists bool) {
	v := m.secret_share
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretShare returns the old "secret_share" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldSecretShare(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretShare is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretShare requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretShare: %w", err)
	}
	return oldValue.SecretShare, nil
}

// ResetSecretShare resets all changes to the "secret_share" field.
func (m *SigningKeyshareMutation) ResetSecretShare() {
	m.secret_share = nil
}

// SetPublicShares sets the "public_shares" field.
func (m *SigningKeyshareMutation) SetPublicShares(value map[string]keys.Public) {
	m.public_shares = &value
}

// PublicShares returns the value of the "public_shares" field in the mutation.
func (m *SigningKeyshareMutation) PublicShares() (r map[string]keys.Public, exists bool) {
	v := m.public_shares
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicShares returns the old "public_shares" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldPublicShares(ctx context.Context) (v map[string]keys.Public, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicShares is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicShares requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicShares: %w", err)
	}
	return oldValue.PublicShares, nil
}

// ResetPublicShares resets all changes to the "public_shares" field.
func (m *SigningKeyshareMutation) ResetPublicShares() {
	m.public_shares = nil
}

// SetPublicKey sets the "public_key" field.
func (m *SigningKeyshareMutation) SetPublicKey(k keys.Public) {
	m.public_key = &k
}

// PublicKey returns the value of the "public_key" field in the mutation.
func (m *SigningKeyshareMutation) PublicKey() (r keys.Public, exists bool) {
	v := m.public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKey returns the old "public_key" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldPublicKey(ctx context.Context) (v keys.Public, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKey: %w", err)
	}
	return oldValue.PublicKey, nil
}

// ResetPublicKey resets all changes to the "public_key" field.
func (m *SigningKeyshareMutation) ResetPublicKey() {
	m.public_key = nil
}

// SetMinSigners sets the "min_signers" field.
func (m *SigningKeyshareMutation) SetMinSigners(i int32) {
	m.min_signers = &i
	m.addmin_signers = nil
}

// MinSigners returns the value of the "min_signers" field in the mutation.
func (m *SigningKeyshareMutation) MinSigners() (r int32, exists bool) {
	v := m.min_signers
	if v == nil {
		return
	}
	return *v, true
}

// OldMinSigners returns the old "min_signers" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldMinSigners(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinSigners is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinSigners requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinSigners: %w", err)
	}
	return oldValue.MinSigners, nil
}

// AddMinSigners adds i to the "min_signers" field.
func (m *SigningKeyshareMutation) AddMinSigners(i int32) {
	if m.addmin_signers != nil {
		*m.addmin_signers += i
	} else {
		m.addmin_signers = &i
	}
}

// AddedMinSigners returns the value that was added to the "min_signers" field in this mutation.
func (m *SigningKeyshareMutation) AddedMinSigners() (r int32, exists bool) {
	v := m.addmin_signers
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinSigners resets all changes to the "min_signers" field.
func (m *SigningKeyshareMutation) ResetMinSigners() {
	m.min_signers = nil
	m.addmin_signers = nil
}

// SetCoordinatorIndex sets the "coordinator_index" field.
func (m *SigningKeyshareMutation) SetCoordinatorIndex(u uint64) {
	m.coordinator_index = &u
	m.addcoordinator_index = nil
}

// CoordinatorIndex returns the value of the "coordinator_index" field in the mutation.
func (m *SigningKeyshareMutation) CoordinatorIndex() (r uint64, exists bool) {
	v := m.coordinator_index
	if v == nil {
		return
	}
	return *v, true
}

// OldCoordinatorIndex returns the old "coordinator_index" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldCoordinatorIndex(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoordinatorIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoordinatorIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoordinatorIndex: %w", err)
	}
	return oldValue.CoordinatorIndex, nil
}

// AddCoordinatorIndex adds u to the "coordinator_index" field.
func (m *SigningKeyshareMutation) AddCoordinatorIndex(u int64) {
	if m.addcoordinator_index != nil {
		*m.addcoordinator_index += u
	} else {
		m.addcoordinator_index = &u
	}
}

// AddedCoordinatorIndex returns the value that was added to the "coordinator_index" field in this mutation.
func (m *SigningKeyshareMutation) AddedCoordinatorIndex() (r int64, exists bool) {
	v := m.addcoordinator_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoordinatorIndex resets all changes to the "coordinator_index" field.
func (m *SigningKeyshareMutation) ResetCoordinatorIndex() {
	m.coordinator_index = nil
	m.addcoordinator_index = nil
}

// Where appends a list predicates to the SigningKeyshareMutation builder.
func (m *SigningKeyshareMutation) Where(ps ...predicate.SigningKeyshare) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SigningKeyshareMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SigningKeyshareMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SigningKeyshare, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SigningKeyshareMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SigningKeyshareMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SigningKeyshare).
func (m *SigningKeyshareMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SigningKeyshareMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, signingkeyshare.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, signingkeyshare.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, signingkeyshare.FieldStatus)
	}
	if m.secret_share != nil {
		fields = append(fields, signingkeyshare.FieldSecretShare)
	}
	if m.public_shares != nil {
		fields = append(fields, signingkeyshare.FieldPublicShares)
	}
	if m.public_key != nil {
		fields = append(fields, signingkeyshare.FieldPublicKey)
	}
	if m.min_signers != nil {
		fields = append(fields, signingkeyshare.FieldMinSigners)
	}
	if m.coordinator_index != nil {
		fields = append(fields, signingkeyshare.FieldCoordinatorIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SigningKeyshareMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case signingkeyshare.FieldCreateTime:
		return m.CreateTime()
	case signingkeyshare.FieldUpdateTime:
		return m.UpdateTime()
	case signingkeyshare.FieldStatus:
		return m.Status()
	case signingkeyshare.FieldSecretShare:
		return m.SecretShare()
	case signingkeyshare.FieldPublicShares:
		return m.PublicShares()
	case signingkeyshare.FieldPublicKey:
		return m.PublicKey()
	case signingkeyshare.FieldMinSigners:
		return m.MinSigners()
	case signingkeyshare.FieldCoordinatorIndex:
		return m.CoordinatorIndex()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SigningKeyshareMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case signingkeyshare.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case signingkeyshare.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case signingkeyshare.FieldStatus:
		return m.OldStatus(ctx)
	case signingkeyshare.FieldSecretShare:
		return m.OldSecretShare(ctx)
	case signingkeyshare.FieldPublicShares:
		return m.OldPublicShares(ctx)
	case signingkeyshare.FieldPublicKey:
		return m.OldPublicKey(ctx)
	case signingkeyshare.FieldMinSigners:
		return m.OldMinSigners(ctx)
	case signingkeyshare.FieldCoordinatorIndex:
		return m.OldCoordinatorIndex(ctx)
	}
	return nil, fmt.Errorf("unknown SigningKeyshare field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningKeyshareMutation) SetField(name string, value ent.Value) error {
	switch name {
	case signingkeyshare.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case signingkeyshare.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case signingkeyshare.FieldStatus:
		v, ok := value.(schematype.SigningKeyshareStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case signingkeyshare.FieldSecretShare:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretShare(v)
		return nil
	case signingkeyshare.FieldPublicShares:
		v, ok := value.(map[string]keys.Public)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicShares(v)
		return nil
	case signingkeyshare.FieldPublicKey:
		v, ok := value.(keys.Public)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKey(v)
		return nil
	case signingkeyshare.FieldMinSigners:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinSigners(v)
		return nil
	case signingkeyshare.FieldCoordinatorIndex:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoordinatorIndex(v)
		return nil
	}
	return fmt.Errorf("unknown SigningKeyshare field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SigningKeyshareMutation) AddedFields() []string {
	var fields []string
	if m.addmin_signers != nil {
		fields = append(fields, signingkeyshare.FieldMinSigners)
	}
	if m.addcoordinator_index != nil {
		fields = append(fields, signingkeyshare.FieldCoordinatorIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SigningKeyshareMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case signingkeyshare.FieldMinSigners:
		return m.AddedMinSigners()
	case signingkeyshare.FieldCoordinatorIndex:
		return m.AddedCoordinatorIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningKeyshareMutation) AddField(name string, value ent.Value) error {
	switch name {
	case signingkeyshare.FieldMinSigners:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinSigners(v)
		return nil
	case signingkeyshare.FieldCoordinatorIndex:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoordinatorIndex(v)
		return nil
	}
	return fmt.Errorf("unknown SigningKeyshare numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SigningKeyshareMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SigningKeyshareMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SigningKeyshareMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SigningKeyshare nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SigningKeyshareMutation) ResetField(name string) error {
	switch name {
	case signingkeyshare.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case signingkeyshare.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case signingkeyshare.FieldStatus:
		m.ResetStatus()
		return nil
	case signingkeyshare.FieldSecretShare:
		m.ResetSecretShare()
		return nil
	case signingkeyshare.FieldPublicShares:
		m.ResetPublicShares()
		return nil
	case signingkeyshare.FieldPublicKey:
		m.ResetPublicKey()
		return nil
	case signingkeyshare.FieldMinSigners:
		m.ResetMinSigners()
		return nil
	case signingkeyshare.FieldCoordinatorIndex:
		m.ResetCoordinatorIndex()
		return nil
	}
	return fmt.Errorf("unknown SigningKeyshare field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SigningKeyshareMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SigningKeyshareMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SigningKeyshareMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SigningKeyshareMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SigningKeyshareMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SigningKeyshareMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SigningKeyshareMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SigningKeyshare unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SigningKeyshareMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SigningKeyshare edge %s", name)
}

// SigningNonceMutation represents an operation that mutates the SigningNonce nodes in the graph.
type SigningNonceMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	create_time       *time.Time
	update_time       *time.Time
	nonce             *[]byte
	nonce_commitment  *[]byte
	message           *[]byte
	retry_fingerprint *[]byte
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*SigningNonce, error)
	predicates        []predicate.SigningNonce
}

var _ ent.Mutation = (*SigningNonceMutation)(nil)

// signingnonceOption allows management of the mutation configuration using functional options.
type signingnonceOption func(*SigningNonceMutation)

// newSigningNonceMutation creates new mutation for the SigningNonce entity.
func newSigningNonceMutation(c config, op Op, opts ...signingnonceOption) *SigningNonceMutation {
	m := &SigningNonceMutation{
		config:        c,
		op:            op,
		typ:           TypeSigningNonce,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSigningNonceID sets the ID field of the mutation.
func withSigningNonceID(id uuid.UUID) signingnonceOption {
	return func(m *SigningNonceMutation) {
		var (
			err   error
			once  sync.Once
			value *SigningNonce
		)
		m.oldValue = func(ctx context.Context) (*SigningNonce, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SigningNonce.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSigningNonce sets the old SigningNonce of the mutation.
func withSigningNonce(node *SigningNonce) signingnonceOption {
	return func(m *SigningNonceMutation) {
		m.oldValue = func(context.Context) (*SigningNonce, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SigningNonceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SigningNonceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SigningNonce entities.
func (m *SigningNonceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SigningNonceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SigningNonceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SigningNonce.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SigningNonceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SigningNonceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SigningNonce entity.
// If the SigningNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningNonceMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SigningNonceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SigningNonceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SigningNonceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SigningNonce entity.
// If the SigningNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningNonceMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SigningNonceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetNonce sets the "nonce" field.
func (m *SigningNonceMutation) SetNonce(b []byte) {
	m.nonce = &b
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *SigningNonceMutation) Nonce() (r []byte, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the SigningNonce entity.
// If the SigningNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningNonceMutation) OldNonce(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// ResetNonce resets all changes to the "nonce" field.
func (m *SigningNonceMutation) ResetNonce() {
	m.nonce = nil
}

// SetNonceCommitment sets the "nonce_commitment" field.
func (m *SigningNonceMutation) SetNonceCommitment(b []byte) {
	m.nonce_commitment = &b
}

// NonceCommitment returns the value of the "nonce_commitment" field in the mutation.
func (m *SigningNonceMutation) NonceCommitment() (r []byte, exists bool) {
	v := m.nonce_commitment
	if v == nil {
		return
	}
	return *v, true
}

// OldNonceCommitment returns the old "nonce_commitment" field's value of the SigningNonce entity.
// If the SigningNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningNonceMutation) OldNonceCommitment(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonceCommitment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonceCommitment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonceCommitment: %w", err)
	}
	return oldValue.NonceCommitment, nil
}

// ResetNonceCommitment resets all changes to the "nonce_commitment" field.
func (m *SigningNonceMutation) ResetNonceCommitment() {
	m.nonce_commitment = nil
}

// SetMessage sets the "message" field.
func (m *SigningNonceMutation) SetMessage(b []byte) {
	m.message = &b
}

// Message returns the value of the "message" field in the mutation.
func (m *SigningNonceMutation) Message() (r []byte, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the SigningNonce entity.
// If the SigningNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningNonceMutation) OldMessage(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *SigningNonceMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[signingnonce.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *SigningNonceMutation) MessageCleared() bool {
	_, ok := m.clearedFields[signingnonce.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *SigningNonceMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, signingnonce.FieldMessage)
}

// SetRetryFingerprint sets the "retry_fingerprint" field.
func (m *SigningNonceMutation) SetRetryFingerprint(b []byte) {
	m.retry_fingerprint = &b
}

// RetryFingerprint returns the value of the "retry_fingerprint" field in the mutation.
func (m *SigningNonceMutation) RetryFingerprint() (r []byte, exists bool) {
	v := m.retry_fingerprint
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryFingerprint returns the old "retry_fingerprint" field's value of the SigningNonce entity.
// If the SigningNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningNonceMutation) OldRetryFingerprint(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryFingerprint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryFingerprint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryFingerprint: %w", err)
	}
	return oldValue.RetryFingerprint, nil
}

// ClearRetryFingerprint clears the value of the "retry_fingerprint" field.
func (m *SigningNonceMutation) ClearRetryFingerprint() {
	m.retry_fingerprint = nil
	m.clearedFields[signingnonce.FieldRetryFingerprint] = struct{}{}
}

// RetryFingerprintCleared returns if the "retry_fingerprint" field was cleared in this mutation.
func (m *SigningNonceMutation) RetryFingerprintCleared() bool {
	_, ok := m.clearedFields[signingnonce.FieldRetryFingerprint]
	return ok
}

// ResetRetryFingerprint resets all changes to the "retry_fingerprint" field.
func (m *SigningNonceMutation) ResetRetryFingerprint() {
	m.retry_fingerprint = nil
	delete(m.clearedFields, signingnonce.FieldRetryFingerprint)
}

// Where appends a list predicates to the SigningNonceMutation builder.
func (m *SigningNonceMutation) Where(ps ...predicate.SigningNonce) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SigningNonceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SigningNonceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SigningNonce, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SigningNonceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SigningNonceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SigningNonce).
func (m *SigningNonceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SigningNonceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, signingnonce.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, signingnonce.FieldUpdateTime)
	}
	if m.nonce != nil {
		fields = append(fields, signingnonce.FieldNonce)
	}
	if m.nonce_commitment != nil {
		fields = append(fields, signingnonce.FieldNonceCommitment)
	}
	if m.message != nil {
		fields = append(fields, signingnonce.FieldMessage)
	}
	if m.retry_fingerprint != nil {
		fields = append(fields, signingnonce.FieldRetryFingerprint)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SigningNonceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case signingnonce.FieldCreateTime:
		return m.CreateTime()
	case signingnonce.FieldUpdateTime:
		return m.UpdateTime()
	case signingnonce.FieldNonce:
		return m.Nonce()
	case signingnonce.FieldNonceCommitment:
		return m.NonceCommitment()
	case signingnonce.FieldMessage:
		return m.Message()
	case signingnonce.FieldRetryFingerprint:
		return m.RetryFingerprint()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SigningNonceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case signingnonce.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case signingnonce.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case signingnonce.FieldNonce:
		return m.OldNonce(ctx)
	case signingnonce.FieldNonceCommitment:
		return m.OldNonceCommitment(ctx)
	case signingnonce.FieldMessage:
		return m.OldMessage(ctx)
	case signingnonce.FieldRetryFingerprint:
		return m.OldRetryFingerprint(ctx)
	}
	return nil, fmt.Errorf("unknown SigningNonce field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningNonceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case signingnonce.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case signingnonce.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case signingnonce.FieldNonce:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	case signingnonce.FieldNonceCommitment:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonceCommitment(v)
		return nil
	case signingnonce.FieldMessage:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case signingnonce.FieldRetryFingerprint:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryFingerprint(v)
		return nil
	}
	return fmt.Errorf("unknown SigningNonce field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SigningNonceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SigningNonceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningNonceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SigningNonce numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SigningNonceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(signingnonce.FieldMessage) {
		fields = append(fields, signingnonce.FieldMessage)
	}
	if m.FieldCleared(signingnonce.FieldRetryFingerprint) {
		fields = append(fields, signingnonce.FieldRetryFingerprint)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SigningNonceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SigningNonceMutation) ClearField(name string) error {
	switch name {
	case signingnonce.FieldMessage:
		m.ClearMessage()
		return nil
	case signingnonce.FieldRetryFingerprint:
		m.ClearRetryFingerprint()
		return nil
	}
	return fmt.Errorf("unknown SigningNonce nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SigningNonceMutation) ResetField(name string) error {
	switch name {
	case signingnonce.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case signingnonce.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case signingnonce.FieldNonce:
		m.ResetNonce()
		return nil
	case signingnonce.FieldNonceCommitment:
		m.ResetNonceCommitment()
		return nil
	case signingnonce.FieldMessage:
		m.ResetMessage()
		return nil
	case signingnonce.FieldRetryFingerprint:
		m.ResetRetryFingerprint()
		return nil
	}
	return fmt.Errorf("unknown SigningNonce field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SigningNonceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SigningNonceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SigningNonceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SigningNonceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SigningNonceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SigningNonceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SigningNonceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SigningNonce unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SigningNonceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SigningNonce edge %s", name)
}

// SparkInvoiceMutation represents an operation that mutates the SparkInvoice nodes in the graph.
type SparkInvoiceMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	create_time              *time.Time
	update_time              *time.Time
	spark_invoice            *string
	expiry_time              *time.Time
	receiver_public_key      *[]byte
	clearedFields            map[string]struct{}
	token_transaction        map[uuid.UUID]struct{}
	removedtoken_transaction map[uuid.UUID]struct{}
	clearedtoken_transaction bool
	transfer                 map[uuid.UUID]struct{}
	removedtransfer          map[uuid.UUID]struct{}
	clearedtransfer          bool
	done                     bool
	oldValue                 func(context.Context) (*SparkInvoice, error)
	predicates               []predicate.SparkInvoice
}

var _ ent.Mutation = (*SparkInvoiceMutation)(nil)

// sparkinvoiceOption allows management of the mutation configuration using functional options.
type sparkinvoiceOption func(*SparkInvoiceMutation)

// newSparkInvoiceMutation creates new mutation for the SparkInvoice entity.
func newSparkInvoiceMutation(c config, op Op, opts ...sparkinvoiceOption) *SparkInvoiceMutation {
	m := &SparkInvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeSparkInvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSparkInvoiceID sets the ID field of the mutation.
func withSparkInvoiceID(id uuid.UUID) sparkinvoiceOption {
	return func(m *SparkInvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *SparkInvoice
		)
		m.oldValue = func(ctx context.Context) (*SparkInvoice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SparkInvoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSparkInvoice sets the old SparkInvoice of the mutation.
func withSparkInvoice(node *SparkInvoice) sparkinvoiceOption {
	return func(m *SparkInvoiceMutation) {
		m.oldValue = func(context.Context) (*SparkInvoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SparkInvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SparkInvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SparkInvoice entities.
func (m *SparkInvoiceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SparkInvoiceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SparkInvoiceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SparkInvoice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SparkInvoiceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SparkInvoiceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SparkInvoice entity.
// If the SparkInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SparkInvoiceMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SparkInvoiceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SparkInvoiceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SparkInvoiceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SparkInvoice entity.
// If the SparkInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SparkInvoiceMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SparkInvoiceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetSparkInvoice sets the "spark_invoice" field.
func (m *SparkInvoiceMutation) SetSparkInvoice(s string) {
	m.spark_invoice = &s
}

// SparkInvoice returns the value of the "spark_invoice" field in the mutation.
func (m *SparkInvoiceMutation) SparkInvoice() (r string, exists bool) {
	v := m.spark_invoice
	if v == nil {
		return
	}
	return *v, true
}

// OldSparkInvoice returns the old "spark_invoice" field's value of the SparkInvoice entity.
// If the SparkInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SparkInvoiceMutation) OldSparkInvoice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSparkInvoice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSparkInvoice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSparkInvoice: %w", err)
	}
	return oldValue.SparkInvoice, nil
}

// ResetSparkInvoice resets all changes to the "spark_invoice" field.
func (m *SparkInvoiceMutation) ResetSparkInvoice() {
	m.spark_invoice = nil
}

// SetExpiryTime sets the "expiry_time" field.
func (m *SparkInvoiceMutation) SetExpiryTime(t time.Time) {
	m.expiry_time = &t
}

// ExpiryTime returns the value of the "expiry_time" field in the mutation.
func (m *SparkInvoiceMutation) ExpiryTime() (r time.Time, exists bool) {
	v := m.expiry_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiryTime returns the old "expiry_time" field's value of the SparkInvoice entity.
// If the SparkInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SparkInvoiceMutation) OldExpiryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiryTime: %w", err)
	}
	return oldValue.ExpiryTime, nil
}

// ClearExpiryTime clears the value of the "expiry_time" field.
func (m *SparkInvoiceMutation) ClearExpiryTime() {
	m.expiry_time = nil
	m.clearedFields[sparkinvoice.FieldExpiryTime] = struct{}{}
}

// ExpiryTimeCleared returns if the "expiry_time" field was cleared in this mutation.
func (m *SparkInvoiceMutation) ExpiryTimeCleared() bool {
	_, ok := m.clearedFields[sparkinvoice.FieldExpiryTime]
	return ok
}

// ResetExpiryTime resets all changes to the "expiry_time" field.
func (m *SparkInvoiceMutation) ResetExpiryTime() {
	m.expiry_time = nil
	delete(m.clearedFields, sparkinvoice.FieldExpiryTime)
}

// SetReceiverPublicKey sets the "receiver_public_key" field.
func (m *SparkInvoiceMutation) SetReceiverPublicKey(b []byte) {
	m.receiver_public_key = &b
}

// ReceiverPublicKey returns the value of the "receiver_public_key" field in the mutation.
func (m *SparkInvoiceMutation) ReceiverPublicKey() (r []byte, exists bool) {
	v := m.receiver_public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverPublicKey returns the old "receiver_public_key" field's value of the SparkInvoice entity.
// If the SparkInvoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SparkInvoiceMutation) OldReceiverPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverPublicKey: %w", err)
	}
	return oldValue.ReceiverPublicKey, nil
}

// ResetReceiverPublicKey resets all changes to the "receiver_public_key" field.
func (m *SparkInvoiceMutation) ResetReceiverPublicKey() {
	m.receiver_public_key = nil
}

// AddTokenTransactionIDs adds the "token_transaction" edge to the TokenTransaction entity by ids.
func (m *SparkInvoiceMutation) AddTokenTransactionIDs(ids ...uuid.UUID) {
	if m.token_transaction == nil {
		m.token_transaction = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.token_transaction[ids[i]] = struct{}{}
	}
}

// ClearTokenTransaction clears the "token_transaction" edge to the TokenTransaction entity.
func (m *SparkInvoiceMutation) ClearTokenTransaction() {
	m.clearedtoken_transaction = true
}

// TokenTransactionCleared reports if the "token_transaction" edge to the TokenTransaction entity was cleared.
func (m *SparkInvoiceMutation) TokenTransactionCleared() bool {
	return m.clearedtoken_transaction
}

// RemoveTokenTransactionIDs removes the "token_transaction" edge to the TokenTransaction entity by IDs.
func (m *SparkInvoiceMutation) RemoveTokenTransactionIDs(ids ...uuid.UUID) {
	if m.removedtoken_transaction == nil {
		m.removedtoken_transaction = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.token_transaction, ids[i])
		m.removedtoken_transaction[ids[i]] = struct{}{}
	}
}

// RemovedTokenTransaction returns the removed IDs of the "token_transaction" edge to the TokenTransaction entity.
func (m *SparkInvoiceMutation) RemovedTokenTransactionIDs() (ids []uuid.UUID) {
	for id := range m.removedtoken_transaction {
		ids = append(ids, id)
	}
	return
}

// TokenTransactionIDs returns the "token_transaction" edge IDs in the mutation.
func (m *SparkInvoiceMutation) TokenTransactionIDs() (ids []uuid.UUID) {
	for id := range m.token_transaction {
		ids = append(ids, id)
	}
	return
}

// ResetTokenTransaction resets all changes to the "token_transaction" edge.
func (m *SparkInvoiceMutation) ResetTokenTransaction() {
	m.token_transaction = nil
	m.clearedtoken_transaction = false
	m.removedtoken_transaction = nil
}

// AddTransferIDs adds the "transfer" edge to the Transfer entity by ids.
func (m *SparkInvoiceMutation) AddTransferIDs(ids ...uuid.UUID) {
	if m.transfer == nil {
		m.transfer = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.transfer[ids[i]] = struct{}{}
	}
}

// ClearTransfer clears the "transfer" edge to the Transfer entity.
func (m *SparkInvoiceMutation) ClearTransfer() {
	m.clearedtransfer = true
}

// TransferCleared reports if the "transfer" edge to the Transfer entity was cleared.
func (m *SparkInvoiceMutation) TransferCleared() bool {
	return m.clearedtransfer
}

// RemoveTransferIDs removes the "transfer" edge to the Transfer entity by IDs.
func (m *SparkInvoiceMutation) RemoveTransferIDs(ids ...uuid.UUID) {
	if m.removedtransfer == nil {
		m.removedtransfer = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.transfer, ids[i])
		m.removedtransfer[ids[i]] = struct{}{}
	}
}

// RemovedTransfer returns the removed IDs of the "transfer" edge to the Transfer entity.
func (m *SparkInvoiceMutation) RemovedTransferIDs() (ids []uuid.UUID) {
	for id := range m.removedtransfer {
		ids = append(ids, id)
	}
	return
}

// TransferIDs returns the "transfer" edge IDs in the mutation.
func (m *SparkInvoiceMutation) TransferIDs() (ids []uuid.UUID) {
	for id := range m.transfer {
		ids = append(ids, id)
	}
	return
}

// ResetTransfer resets all changes to the "transfer" edge.
func (m *SparkInvoiceMutation) ResetTransfer() {
	m.transfer = nil
	m.clearedtransfer = false
	m.removedtransfer = nil
}

// Where appends a list predicates to the SparkInvoiceMutation builder.
func (m *SparkInvoiceMutation) Where(ps ...predicate.SparkInvoice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SparkInvoiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SparkInvoiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SparkInvoice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SparkInvoiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SparkInvoiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SparkInvoice).
func (m *SparkInvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SparkInvoiceMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, sparkinvoice.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, sparkinvoice.FieldUpdateTime)
	}
	if m.spark_invoice != nil {
		fields = append(fields, sparkinvoice.FieldSparkInvoice)
	}
	if m.expiry_time != nil {
		fields = append(fields, sparkinvoice.FieldExpiryTime)
	}
	if m.receiver_public_key != nil {
		fields = append(fields, sparkinvoice.FieldReceiverPublicKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SparkInvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sparkinvoice.FieldCreateTime:
		return m.CreateTime()
	case sparkinvoice.FieldUpdateTime:
		return m.UpdateTime()
	case sparkinvoice.FieldSparkInvoice:
		return m.SparkInvoice()
	case sparkinvoice.FieldExpiryTime:
		return m.ExpiryTime()
	case sparkinvoice.FieldReceiverPublicKey:
		return m.ReceiverPublicKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SparkInvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sparkinvoice.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case sparkinvoice.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case sparkinvoice.FieldSparkInvoice:
		return m.OldSparkInvoice(ctx)
	case sparkinvoice.FieldExpiryTime:
		return m.OldExpiryTime(ctx)
	case sparkinvoice.FieldReceiverPublicKey:
		return m.OldReceiverPublicKey(ctx)
	}
	return nil, fmt.Errorf("unknown SparkInvoice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SparkInvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sparkinvoice.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case sparkinvoice.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case sparkinvoice.FieldSparkInvoice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSparkInvoice(v)
		return nil
	case sparkinvoice.FieldExpiryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiryTime(v)
		return nil
	case sparkinvoice.FieldReceiverPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverPublicKey(v)
		return nil
	}
	return fmt.Errorf("unknown SparkInvoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SparkInvoiceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SparkInvoiceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SparkInvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SparkInvoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SparkInvoiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sparkinvoice.FieldExpiryTime) {
		fields = append(fields, sparkinvoice.FieldExpiryTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SparkInvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SparkInvoiceMutation) ClearField(name string) error {
	switch name {
	case sparkinvoice.FieldExpiryTime:
		m.ClearExpiryTime()
		return nil
	}
	return fmt.Errorf("unknown SparkInvoice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SparkInvoiceMutation) ResetField(name string) error {
	switch name {
	case sparkinvoice.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case sparkinvoice.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case sparkinvoice.FieldSparkInvoice:
		m.ResetSparkInvoice()
		return nil
	case sparkinvoice.FieldExpiryTime:
		m.ResetExpiryTime()
		return nil
	case sparkinvoice.FieldReceiverPublicKey:
		m.ResetReceiverPublicKey()
		return nil
	}
	return fmt.Errorf("unknown SparkInvoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SparkInvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.token_transaction != nil {
		edges = append(edges, sparkinvoice.EdgeTokenTransaction)
	}
	if m.transfer != nil {
		edges = append(edges, sparkinvoice.EdgeTransfer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SparkInvoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sparkinvoice.EdgeTokenTransaction:
		ids := make([]ent.Value, 0, len(m.token_transaction))
		for id := range m.token_transaction {
			ids = append(ids, id)
		}
		return ids
	case sparkinvoice.EdgeTransfer:
		ids := make([]ent.Value, 0, len(m.transfer))
		for id := range m.transfer {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SparkInvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtoken_transaction != nil {
		edges = append(edges, sparkinvoice.EdgeTokenTransaction)
	}
	if m.removedtransfer != nil {
		edges = append(edges, sparkinvoice.EdgeTransfer)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SparkInvoiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sparkinvoice.EdgeTokenTransaction:
		ids := make([]ent.Value, 0, len(m.removedtoken_transaction))
		for id := range m.removedtoken_transaction {
			ids = append(ids, id)
		}
		return ids
	case sparkinvoice.EdgeTransfer:
		ids := make([]ent.Value, 0, len(m.removedtransfer))
		for id := range m.removedtransfer {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SparkInvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtoken_transaction {
		edges = append(edges, sparkinvoice.EdgeTokenTransaction)
	}
	if m.clearedtransfer {
		edges = append(edges, sparkinvoice.EdgeTransfer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SparkInvoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case sparkinvoice.EdgeTokenTransaction:
		return m.clearedtoken_transaction
	case sparkinvoice.EdgeTransfer:
		return m.clearedtransfer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SparkInvoiceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SparkInvoice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SparkInvoiceMutation) ResetEdge(name string) error {
	switch name {
	case sparkinvoice.EdgeTokenTransaction:
		m.ResetTokenTransaction()
		return nil
	case sparkinvoice.EdgeTransfer:
		m.ResetTransfer()
		return nil
	}
	return fmt.Errorf("unknown SparkInvoice edge %s", name)
}

// TokenCreateMutation represents an operation that mutates the TokenCreate nodes in the graph.
type TokenCreateMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *uuid.UUID
	create_time                        *time.Time
	update_time                        *time.Time
	issuer_public_key                  *keys.Public
	token_name                         *string
	token_ticker                       *string
	decimals                           *uint8
	adddecimals                        *int8
	max_supply                         *[]byte
	is_freezable                       *bool
	network                            *schematype.Network
	token_identifier                   *[]byte
	issuer_signature                   *[]byte
	operator_specific_issuer_signature *[]byte
	creation_entity_public_key         *keys.Public
	wallet_provided_timestamp          *uint64
	addwallet_provided_timestamp       *int64
	clearedFields                      map[string]struct{}
	token_transaction                  map[uuid.UUID]struct{}
	removedtoken_transaction           map[uuid.UUID]struct{}
	clearedtoken_transaction           bool
	l1_token_create                    *uuid.UUID
	clearedl1_token_create             bool
	token_output                       map[uuid.UUID]struct{}
	removedtoken_output                map[uuid.UUID]struct{}
	clearedtoken_output                bool
	token_freeze                       map[uuid.UUID]struct{}
	removedtoken_freeze                map[uuid.UUID]struct{}
	clearedtoken_freeze                bool
	done                               bool
	oldValue                           func(context.Context) (*TokenCreate, error)
	predicates                         []predicate.TokenCreate
}

var _ ent.Mutation = (*TokenCreateMutation)(nil)

// tokencreateOption allows management of the mutation configuration using functional options.
type tokencreateOption func(*TokenCreateMutation)

// newTokenCreateMutation creates new mutation for the TokenCreate entity.
func newTokenCreateMutation(c config, op Op, opts ...tokencreateOption) *TokenCreateMutation {
	m := &TokenCreateMutation{
		config:        c,
		op:            op,
		typ:           TypeTokenCreate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenCreateID sets the ID field of the mutation.
func withTokenCreateID(id uuid.UUID) tokencreateOption {
	return func(m *TokenCreateMutation) {
		var (
			err   error
			once  sync.Once
			value *TokenCreate
		)
		m.oldValue = func(ctx context.Context) (*TokenCreate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TokenCreate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTokenCreate sets the old TokenCreate of the mutation.
func withTokenCreate(node *TokenCreate) tokencreateOption {
	return func(m *TokenCreateMutation) {
		m.oldValue = func(context.Context) (*TokenCreate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenCreateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenCreateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TokenCreate entities.
func (m *TokenCreateMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenCreateMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenCreateMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TokenCreate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TokenCreateMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TokenCreateMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TokenCreate entity.
// If the TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenCreateMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TokenCreateMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TokenCreateMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TokenCreateMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TokenCreate entity.
// If the TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenCreateMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TokenCreateMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetIssuerPublicKey sets the "issuer_public_key" field.
func (m *TokenCreateMutation) SetIssuerPublicKey(k keys.Public) {
	m.issuer_public_key = &k
}

// IssuerPublicKey returns the value of the "issuer_public_key" field in the mutation.
func (m *TokenCreateMutation) IssuerPublicKey() (r keys.Public, exists bool) {
	v := m.issuer_public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuerPublicKey returns the old "issuer_public_key" field's value of the TokenCreate entity.
// If the TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenCreateMutation) OldIssuerPublicKey(ctx context.Context) (v keys.Public, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuerPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuerPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuerPublicKey: %w", err)
	}
	return oldValue.IssuerPublicKey, nil
}

// ResetIssuerPublicKey resets all changes to the "issuer_public_key" field.
func (m *TokenCreateMutation) ResetIssuerPublicKey() {
	m.issuer_public_key = nil
}

// SetTokenName sets the "token_name" field.
func (m *TokenCreateMutation) SetTokenName(s string) {
	m.token_name = &s
}

// TokenName returns the value of the "token_name" field in the mutation.
func (m *TokenCreateMutation) TokenName() (r string, exists bool) {
	v := m.token_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenName returns the old "token_name" field's value of the TokenCreate entity.
// If the TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenCreateMutation) OldTokenName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenName: %w", err)
	}
	return oldValue.TokenName, nil
}

// ResetTokenName resets all changes to the "token_name" field.
func (m *TokenCreateMutation) ResetTokenName() {
	m.token_name = nil
}

// SetTokenTicker sets the "token_ticker" field.
func (m *TokenCreateMutation) SetTokenTicker(s string) {
	m.token_ticker = &s
}

// TokenTicker returns the value of the "token_ticker" field in the mutation.
func (m *TokenCreateMutation) TokenTicker() (r string, exists bool) {
	v := m.token_ticker
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenTicker returns the old "token_ticker" field's value of the TokenCreate entity.
// If the TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenCreateMutation) OldTokenTicker(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenTicker is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenTicker requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenTicker: %w", err)
	}
	return oldValue.TokenTicker, nil
}

// ResetTokenTicker resets all changes to the "token_ticker" field.
func (m *TokenCreateMutation) ResetTokenTicker() {
	m.token_ticker = nil
}

// SetDecimals sets the "decimals" field.
func (m *TokenCreateMutation) SetDecimals(u uint8) {
	m.decimals = &u
	m.adddecimals = nil
}

// Decimals returns the value of the "decimals" field in the mutation.
func (m *TokenCreateMutation) Decimals() (r uint8, exists bool) {
	v := m.decimals
	if v == nil {
		return
	}
	return *v, true
}

// OldDecimals returns the old "decimals" field's value of the TokenCreate entity.
// If the TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenCreateMutation) OldDecimals(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDecimals is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDecimals requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDecimals: %w", err)
	}
	return oldValue.Decimals, nil
}

// AddDecimals adds u to the "decimals" field.
func (m *TokenCreateMutation) AddDecimals(u int8) {
	if m.adddecimals != nil {
		*m.adddecimals += u
	} else {
		m.adddecimals = &u
	}
}

// AddedDecimals returns the value that was added to the "decimals" field in this mutation.
func (m *TokenCreateMutation) AddedDecimals() (r int8, exists bool) {
	v := m.adddecimals
	if v == nil {
		return
	}
	return *v, true
}

// ResetDecimals resets all changes to the "decimals" field.
func (m *TokenCreateMutation) ResetDecimals() {
	m.decimals = nil
	m.adddecimals = nil
}

// SetMaxSupply sets the "max_supply" field.
func (m *TokenCreateMutation) SetMaxSupply(b []byte) {
	m.max_supply = &b
}

// MaxSupply returns the value of the "max_supply" field in the mutation.
func (m *TokenCreateMutation) MaxSupply() (r []byte, exists bool) {
	v := m.max_supply
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxSupply returns the old "max_supply" field's value of the TokenCreate entity.
// If the TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenCreateMutation) OldMaxSupply(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxSupply is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxSupply requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxSupply: %w", err)
	}
	return oldValue.MaxSupply, nil
}

// ResetMaxSupply resets all changes to the "max_supply" field.
func (m *TokenCreateMutation) ResetMaxSupply() {
	m.max_supply = nil
}

// SetIsFreezable sets the "is_freezable" field.
func (m *TokenCreateMutation) SetIsFreezable(b bool) {
	m.is_freezable = &b
}

// IsFreezable returns the value of the "is_freezable" field in the mutation.
func (m *TokenCreateMutation) IsFreezable() (r bool, exists bool) {
	v := m.is_freezable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFreezable returns the old "is_freezable" field's value of the TokenCreate entity.
// If the TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenCreateMutation) OldIsFreezable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFreezable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFreezable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFreezable: %w", err)
	}
	return oldValue.IsFreezable, nil
}

// ResetIsFreezable resets all changes to the "is_freezable" field.
func (m *TokenCreateMutation) ResetIsFreezable() {
	m.is_freezable = nil
}

// SetNetwork sets the "network" field.
func (m *TokenCreateMutation) SetNetwork(s schematype.Network) {
	m.network = &s
}

// Network returns the value of the "network" field in the mutation.
func (m *TokenCreateMutation) Network() (r schematype.Network, exists bool) {
	v := m.network
	if v == nil {
		return
	}
	return *v, true
}

// OldNetwork returns the old "network" field's value of the TokenCreate entity.
// If the TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenCreateMutation) OldNetwork(ctx context.Context) (v schematype.Network, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetwork is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetwork requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetwork: %w", err)
	}
	return oldValue.Network, nil
}

// ResetNetwork resets all changes to the "network" field.
func (m *TokenCreateMutation) ResetNetwork() {
	m.network = nil
}

// SetTokenIdentifier sets the "token_identifier" field.
func (m *TokenCreateMutation) SetTokenIdentifier(b []byte) {
	m.token_identifier = &b
}

// TokenIdentifier returns the value of the "token_identifier" field in the mutation.
func (m *TokenCreateMutation) TokenIdentifier() (r []byte, exists bool) {
	v := m.token_identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenIdentifier returns the old "token_identifier" field's value of the TokenCreate entity.
// If the TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenCreateMutation) OldTokenIdentifier(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenIdentifier: %w", err)
	}
	return oldValue.TokenIdentifier, nil
}

// ResetTokenIdentifier resets all changes to the "token_identifier" field.
func (m *TokenCreateMutation) ResetTokenIdentifier() {
	m.token_identifier = nil
}

// SetIssuerSignature sets the "issuer_signature" field.
func (m *TokenCreateMutation) SetIssuerSignature(b []byte) {
	m.issuer_signature = &b
}

// IssuerSignature returns the value of the "issuer_signature" field in the mutation.
func (m *TokenCreateMutation) IssuerSignature() (r []byte, exists bool) {
	v := m.issuer_signature
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuerSignature returns the old "issuer_signature" field's value of the TokenCreate entity.
// If the TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenCreateMutation) OldIssuerSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuerSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuerSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuerSignature: %w", err)
	}
	return oldValue.IssuerSignature, nil
}

// ClearIssuerSignature clears the value of the "issuer_signature" field.
func (m *TokenCreateMutation) ClearIssuerSignature() {
	m.issuer_signature = nil
	m.clearedFields[tokencreate.FieldIssuerSignature] = struct{}{}
}

// IssuerSignatureCleared returns if the "issuer_signature" field was cleared in this mutation.
func (m *TokenCreateMutation) IssuerSignatureCleared() bool {
	_, ok := m.clearedFields[tokencreate.FieldIssuerSignature]
	return ok
}

// ResetIssuerSignature resets all changes to the "issuer_signature" field.
func (m *TokenCreateMutation) ResetIssuerSignature() {
	m.issuer_signature = nil
	delete(m.clearedFields, tokencreate.FieldIssuerSignature)
}

// SetOperatorSpecificIssuerSignature sets the "operator_specific_issuer_signature" field.
func (m *TokenCreateMutation) SetOperatorSpecificIssuerSignature(b []byte) {
	m.operator_specific_issuer_signature = &b
}

// OperatorSpecificIssuerSignature returns the value of the "operator_specific_issuer_signature" field in the mutation.
func (m *TokenCreateMutation) OperatorSpecificIssuerSignature() (r []byte, exists bool) {
	v := m.operator_specific_issuer_signature
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorSpecificIssuerSignature returns the old "operator_specific_issuer_signature" field's value of the TokenCreate entity.
// If the TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenCreateMutation) OldOperatorSpecificIssuerSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorSpecificIssuerSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorSpecificIssuerSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorSpecificIssuerSignature: %w", err)
	}
	return oldValue.OperatorSpecificIssuerSignature, nil
}

// ClearOperatorSpecificIssuerSignature clears the value of the "operator_specific_issuer_signature" field.
func (m *TokenCreateMutation) ClearOperatorSpecificIssuerSignature() {
	m.operator_specific_issuer_signature = nil
	m.clearedFields[tokencreate.FieldOperatorSpecificIssuerSignature] = struct{}{}
}

// OperatorSpecificIssuerSignatureCleared returns if the "operator_specific_issuer_signature" field was cleared in this mutation.
func (m *TokenCreateMutation) OperatorSpecificIssuerSignatureCleared() bool {
	_, ok := m.clearedFields[tokencreate.FieldOperatorSpecificIssuerSignature]
	return ok
}

// ResetOperatorSpecificIssuerSignature resets all changes to the "operator_specific_issuer_signature" field.
func (m *TokenCreateMutation) ResetOperatorSpecificIssuerSignature() {
	m.operator_specific_issuer_signature = nil
	delete(m.clearedFields, tokencreate.FieldOperatorSpecificIssuerSignature)
}

// SetCreationEntityPublicKey sets the "creation_entity_public_key" field.
func (m *TokenCreateMutation) SetCreationEntityPublicKey(k keys.Public) {
	m.creation_entity_public_key = &k
}

// CreationEntityPublicKey returns the value of the "creation_entity_public_key" field in the mutation.
func (m *TokenCreateMutation) CreationEntityPublicKey() (r keys.Public, exists bool) {
	v := m.creation_entity_public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldCreationEntityPublicKey returns the old "creation_entity_public_key" field's value of the TokenCreate entity.
// If the TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenCreateMutation) OldCreationEntityPublicKey(ctx context.Context) (v keys.Public, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreationEntityPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreationEntityPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreationEntityPublicKey: %w", err)
	}
	return oldValue.CreationEntityPublicKey, nil
}

// ResetCreationEntityPublicKey resets all changes to the "creation_entity_public_key" field.
func (m *TokenCreateMutation) ResetCreationEntityPublicKey() {
	m.creation_entity_public_key = nil
}

// SetWalletProvidedTimestamp sets the "wallet_provided_timestamp" field.
func (m *TokenCreateMutation) SetWalletProvidedTimestamp(u uint64) {
	m.wallet_provided_timestamp = &u
	m.addwallet_provided_timestamp = nil
}

// WalletProvidedTimestamp returns the value of the "wallet_provided_timestamp" field in the mutation.
func (m *TokenCreateMutation) WalletProvidedTimestamp() (r uint64, exists bool) {
	v := m.wallet_provided_timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletProvidedTimestamp returns the old "wallet_provided_timestamp" field's value of the TokenCreate entity.
// If the TokenCreate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenCreateMutation) OldWalletProvidedTimestamp(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWalletProvidedTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWalletProvidedTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletProvidedTimestamp: %w", err)
	}
	return oldValue.WalletProvidedTimestamp, nil
}

// AddWalletProvidedTimestamp adds u to the "wallet_provided_timestamp" field.
func (m *TokenCreateMutation) AddWalletProvidedTimestamp(u int64) {
	if m.addwallet_provided_timestamp != nil {
		*m.addwallet_provided_timestamp += u
	} else {
		m.addwallet_provided_timestamp = &u
	}
}

// AddedWalletProvidedTimestamp returns the value that was added to the "wallet_provided_timestamp" field in this mutation.
func (m *TokenCreateMutation) AddedWalletProvidedTimestamp() (r int64, exists bool) {
	v := m.addwallet_provided_timestamp
	if v == nil {
		return
	}
	return *v, true
}

// ClearWalletProvidedTimestamp clears the value of the "wallet_provided_timestamp" field.
func (m *TokenCreateMutation) ClearWalletProvidedTimestamp() {
	m.wallet_provided_timestamp = nil
	m.addwallet_provided_timestamp = nil
	m.clearedFields[tokencreate.FieldWalletProvidedTimestamp] = struct{}{}
}

// WalletProvidedTimestampCleared returns if the "wallet_provided_timestamp" field was cleared in this mutation.
func (m *TokenCreateMutation) WalletProvidedTimestampCleared() bool {
	_, ok := m.clearedFields[tokencreate.FieldWalletProvidedTimestamp]
	return ok
}

// ResetWalletProvidedTimestamp resets all changes to the "wallet_provided_timestamp" field.
func (m *TokenCreateMutation) ResetWalletProvidedTimestamp() {
	m.wallet_provided_timestamp = nil
	m.addwallet_provided_timestamp = nil
	delete(m.clearedFields, tokencreate.FieldWalletProvidedTimestamp)
}

// AddTokenTransactionIDs adds the "token_transaction" edge to the TokenTransaction entity by ids.
func (m *TokenCreateMutation) AddTokenTransactionIDs(ids ...uuid.UUID) {
	if m.token_transaction == nil {
		m.token_transaction = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.token_transaction[ids[i]] = struct{}{}
	}
}

// ClearTokenTransaction clears the "token_transaction" edge to the TokenTransaction entity.
func (m *TokenCreateMutation) ClearTokenTransaction() {
	m.clearedtoken_transaction = true
}

// TokenTransactionCleared reports if the "token_transaction" edge to the TokenTransaction entity was cleared.
func (m *TokenCreateMutation) TokenTransactionCleared() bool {
	return m.clearedtoken_transaction
}

// RemoveTokenTransactionIDs removes the "token_transaction" edge to the TokenTransaction entity by IDs.
func (m *TokenCreateMutation) RemoveTokenTransactionIDs(ids ...uuid.UUID) {
	if m.removedtoken_transaction == nil {
		m.removedtoken_transaction = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.token_transaction, ids[i])
		m.removedtoken_transaction[ids[i]] = struct{}{}
	}
}

// RemovedTokenTransaction returns the removed IDs of the "token_transaction" edge to the TokenTransaction entity.
func (m *TokenCreateMutation) RemovedTokenTransactionIDs() (ids []uuid.UUID) {
	for id := range m.removedtoken_transaction {
		ids = append(ids, id)
	}
	return
}

// TokenTransactionIDs returns the "token_transaction" edge IDs in the mutation.
func (m *TokenCreateMutation) TokenTransactionIDs() (ids []uuid.UUID) {
	for id := range m.token_transaction {
		ids = append(ids, id)
	}
	return
}

// ResetTokenTransaction resets all changes to the "token_transaction" edge.
func (m *TokenCreateMutation) ResetTokenTransaction() {
	m.token_transaction = nil
	m.clearedtoken_transaction = false
	m.removedtoken_transaction = nil
}

// SetL1TokenCreateID sets the "l1_token_create" edge to the L1TokenCreate entity by id.
func (m *TokenCreateMutation) SetL1TokenCreateID(id uuid.UUID) {
	m.l1_token_create = &id
}

// ClearL1TokenCreate clears the "l1_token_create" edge to the L1TokenCreate entity.
func (m *TokenCreateMutation) ClearL1TokenCreate() {
	m.clearedl1_token_create = true
}

// L1TokenCreateCleared reports if the "l1_token_create" edge to the L1TokenCreate entity was cleared.
func (m *TokenCreateMutation) L1TokenCreateCleared() bool {
	return m.clearedl1_token_create
}

// L1TokenCreateID returns the "l1_token_create" edge ID in the mutation.
func (m *TokenCreateMutation) L1TokenCreateID() (id uuid.UUID, exists bool) {
	if m.l1_token_create != nil {
		return *m.l1_token_create, true
	}
	return
}

// L1TokenCreateIDs returns the "l1_token_create" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// L1TokenCreateID instead. It exists only for internal usage by the builders.
func (m *TokenCreateMutation) L1TokenCreateIDs() (ids []uuid.UUID) {
	if id := m.l1_token_create; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetL1TokenCreate resets all changes to the "l1_token_create" edge.
func (m *TokenCreateMutation) ResetL1TokenCreate() {
	m.l1_token_create = nil
	m.clearedl1_token_create = false
}

// AddTokenOutputIDs adds the "token_output" edge to the TokenOutput entity by ids.
func (m *TokenCreateMutation) AddTokenOutputIDs(ids ...uuid.UUID) {
	if m.token_output == nil {
		m.token_output = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.token_output[ids[i]] = struct{}{}
	}
}

// ClearTokenOutput clears the "token_output" edge to the TokenOutput entity.
func (m *TokenCreateMutation) ClearTokenOutput() {
	m.clearedtoken_output = true
}

// TokenOutputCleared reports if the "token_output" edge to the TokenOutput entity was cleared.
func (m *TokenCreateMutation) TokenOutputCleared() bool {
	return m.clearedtoken_output
}

// RemoveTokenOutputIDs removes the "token_output" edge to the TokenOutput entity by IDs.
func (m *TokenCreateMutation) RemoveTokenOutputIDs(ids ...uuid.UUID) {
	if m.removedtoken_output == nil {
		m.removedtoken_output = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.token_output, ids[i])
		m.removedtoken_output[ids[i]] = struct{}{}
	}
}

// RemovedTokenOutput returns the removed IDs of the "token_output" edge to the TokenOutput entity.
func (m *TokenCreateMutation) RemovedTokenOutputIDs() (ids []uuid.UUID) {
	for id := range m.removedtoken_output {
		ids = append(ids, id)
	}
	return
}

// TokenOutputIDs returns the "token_output" edge IDs in the mutation.
func (m *TokenCreateMutation) TokenOutputIDs() (ids []uuid.UUID) {
	for id := range m.token_output {
		ids = append(ids, id)
	}
	return
}

// ResetTokenOutput resets all changes to the "token_output" edge.
func (m *TokenCreateMutation) ResetTokenOutput() {
	m.token_output = nil
	m.clearedtoken_output = false
	m.removedtoken_output = nil
}

// AddTokenFreezeIDs adds the "token_freeze" edge to the TokenFreeze entity by ids.
func (m *TokenCreateMutation) AddTokenFreezeIDs(ids ...uuid.UUID) {
	if m.token_freeze == nil {
		m.token_freeze = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.token_freeze[ids[i]] = struct{}{}
	}
}

// ClearTokenFreeze clears the "token_freeze" edge to the TokenFreeze entity.
func (m *TokenCreateMutation) ClearTokenFreeze() {
	m.clearedtoken_freeze = true
}

// TokenFreezeCleared reports if the "token_freeze" edge to the TokenFreeze entity was cleared.
func (m *TokenCreateMutation) TokenFreezeCleared() bool {
	return m.clearedtoken_freeze
}

// RemoveTokenFreezeIDs removes the "token_freeze" edge to the TokenFreeze entity by IDs.
func (m *TokenCreateMutation) RemoveTokenFreezeIDs(ids ...uuid.UUID) {
	if m.removedtoken_freeze == nil {
		m.removedtoken_freeze = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.token_freeze, ids[i])
		m.removedtoken_freeze[ids[i]] = struct{}{}
	}
}

// RemovedTokenFreeze returns the removed IDs of the "token_freeze" edge to the TokenFreeze entity.
func (m *TokenCreateMutation) RemovedTokenFreezeIDs() (ids []uuid.UUID) {
	for id := range m.removedtoken_freeze {
		ids = append(ids, id)
	}
	return
}

// TokenFreezeIDs returns the "token_freeze" edge IDs in the mutation.
func (m *TokenCreateMutation) TokenFreezeIDs() (ids []uuid.UUID) {
	for id := range m.token_freeze {
		ids = append(ids, id)
	}
	return
}

// ResetTokenFreeze resets all changes to the "token_freeze" edge.
func (m *TokenCreateMutation) ResetTokenFreeze() {
	m.token_freeze = nil
	m.clearedtoken_freeze = false
	m.removedtoken_freeze = nil
}

// Where appends a list predicates to the TokenCreateMutation builder.
func (m *TokenCreateMutation) Where(ps ...predicate.TokenCreate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenCreateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenCreateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TokenCreate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenCreateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenCreateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TokenCreate).
func (m *TokenCreateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenCreateMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.create_time != nil {
		fields = append(fields, tokencreate.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, tokencreate.FieldUpdateTime)
	}
	if m.issuer_public_key != nil {
		fields = append(fields, tokencreate.FieldIssuerPublicKey)
	}
	if m.token_name != nil {
		fields = append(fields, tokencreate.FieldTokenName)
	}
	if m.token_ticker != nil {
		fields = append(fields, tokencreate.FieldTokenTicker)
	}
	if m.decimals != nil {
		fields = append(fields, tokencreate.FieldDecimals)
	}
	if m.max_supply != nil {
		fields = append(fields, tokencreate.FieldMaxSupply)
	}
	if m.is_freezable != nil {
		fields = append(fields, tokencreate.FieldIsFreezable)
	}
	if m.network != nil {
		fields = append(fields, tokencreate.FieldNetwork)
	}
	if m.token_identifier != nil {
		fields = append(fields, tokencreate.FieldTokenIdentifier)
	}
	if m.issuer_signature != nil {
		fields = append(fields, tokencreate.FieldIssuerSignature)
	}
	if m.operator_specific_issuer_signature != nil {
		fields = append(fields, tokencreate.FieldOperatorSpecificIssuerSignature)
	}
	if m.creation_entity_public_key != nil {
		fields = append(fields, tokencreate.FieldCreationEntityPublicKey)
	}
	if m.wallet_provided_timestamp != nil {
		fields = append(fields, tokencreate.FieldWalletProvidedTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenCreateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tokencreate.FieldCreateTime:
		return m.CreateTime()
	case tokencreate.FieldUpdateTime:
		return m.UpdateTime()
	case tokencreate.FieldIssuerPublicKey:
		return m.IssuerPublicKey()
	case tokencreate.FieldTokenName:
		return m.TokenName()
	case tokencreate.FieldTokenTicker:
		return m.TokenTicker()
	case tokencreate.FieldDecimals:
		return m.Decimals()
	case tokencreate.FieldMaxSupply:
		return m.MaxSupply()
	case tokencreate.FieldIsFreezable:
		return m.IsFreezable()
	case tokencreate.FieldNetwork:
		return m.Network()
	case tokencreate.FieldTokenIdentifier:
		return m.TokenIdentifier()
	case tokencreate.FieldIssuerSignature:
		return m.IssuerSignature()
	case tokencreate.FieldOperatorSpecificIssuerSignature:
		return m.OperatorSpecificIssuerSignature()
	case tokencreate.FieldCreationEntityPublicKey:
		return m.CreationEntityPublicKey()
	case tokencreate.FieldWalletProvidedTimestamp:
		return m.WalletProvidedTimestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenCreateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tokencreate.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case tokencreate.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case tokencreate.FieldIssuerPublicKey:
		return m.OldIssuerPublicKey(ctx)
	case tokencreate.FieldTokenName:
		return m.OldTokenName(ctx)
	case tokencreate.FieldTokenTicker:
		return m.OldTokenTicker(ctx)
	case tokencreate.FieldDecimals:
		return m.OldDecimals(ctx)
	case tokencreate.FieldMaxSupply:
		return m.OldMaxSupply(ctx)
	case tokencreate.FieldIsFreezable:
		return m.OldIsFreezable(ctx)
	case tokencreate.FieldNetwork:
		return m.OldNetwork(ctx)
	case tokencreate.FieldTokenIdentifier:
		return m.OldTokenIdentifier(ctx)
	case tokencreate.FieldIssuerSignature:
		return m.OldIssuerSignature(ctx)
	case tokencreate.FieldOperatorSpecificIssuerSignature:
		return m.OldOperatorSpecificIssuerSignature(ctx)
	case tokencreate.FieldCreationEntityPublicKey:
		return m.OldCreationEntityPublicKey(ctx)
	case tokencreate.FieldWalletProvidedTimestamp:
		return m.OldWalletProvidedTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown TokenCreate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenCreateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tokencreate.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case tokencreate.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case tokencreate.FieldIssuerPublicKey:
		v, ok := value.(keys.Public)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuerPublicKey(v)
		return nil
	case tokencreate.FieldTokenName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenName(v)
		return nil
	case tokencreate.FieldTokenTicker:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenTicker(v)
		return nil
	case tokencreate.FieldDecimals:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDecimals(v)
		return nil
	case tokencreate.FieldMaxSupply:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxSupply(v)
		return nil
	case tokencreate.FieldIsFreezable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFreezable(v)
		return nil
	case tokencreate.FieldNetwork:
		v, ok := value.(schematype.Network)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetwork(v)
		return nil
	case tokencreate.FieldTokenIdentifier:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenIdentifier(v)
		return nil
	case tokencreate.FieldIssuerSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuerSignature(v)
		return nil
	case tokencreate.FieldOperatorSpecificIssuerSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorSpecificIssuerSignature(v)
		return nil
	case tokencreate.FieldCreationEntityPublicKey:
		v, ok := value.(keys.Public)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreationEntityPublicKey(v)
		return nil
	case tokencreate.FieldWalletProvidedTimestamp:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletProvidedTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown TokenCreate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenCreateMutation) AddedFields() []string {
	var fields []string
	if m.adddecimals != nil {
		fields = append(fields, tokencreate.FieldDecimals)
	}
	if m.addwallet_provided_timestamp != nil {
		fields = append(fields, tokencreate.FieldWalletProvidedTimestamp)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenCreateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tokencreate.FieldDecimals:
		return m.AddedDecimals()
	case tokencreate.FieldWalletProvidedTimestamp:
		return m.AddedWalletProvidedTimestamp()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenCreateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tokencreate.FieldDecimals:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDecimals(v)
		return nil
	case tokencreate.FieldWalletProvidedTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWalletProvidedTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown TokenCreate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenCreateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tokencreate.FieldIssuerSignature) {
		fields = append(fields, tokencreate.FieldIssuerSignature)
	}
	if m.FieldCleared(tokencreate.FieldOperatorSpecificIssuerSignature) {
		fields = append(fields, tokencreate.FieldOperatorSpecificIssuerSignature)
	}
	if m.FieldCleared(tokencreate.FieldWalletProvidedTimestamp) {
		fields = append(fields, tokencreate.FieldWalletProvidedTimestamp)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenCreateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenCreateMutation) ClearField(name string) error {
	switch name {
	case tokencreate.FieldIssuerSignature:
		m.ClearIssuerSignature()
		return nil
	case tokencreate.FieldOperatorSpecificIssuerSignature:
		m.ClearOperatorSpecificIssuerSignature()
		return nil
	case tokencreate.FieldWalletProvidedTimestamp:
		m.ClearWalletProvidedTimestamp()
		return nil
	}
	return fmt.Errorf("unknown TokenCreate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenCreateMutation) ResetField(name string) error {
	switch name {
	case tokencreate.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case tokencreate.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case tokencreate.FieldIssuerPublicKey:
		m.ResetIssuerPublicKey()
		return nil
	case tokencreate.FieldTokenName:
		m.ResetTokenName()
		return nil
	case tokencreate.FieldTokenTicker:
		m.ResetTokenTicker()
		return nil
	case tokencreate.FieldDecimals:
		m.ResetDecimals()
		return nil
	case tokencreate.FieldMaxSupply:
		m.ResetMaxSupply()
		return nil
	case tokencreate.FieldIsFreezable:
		m.ResetIsFreezable()
		return nil
	case tokencreate.FieldNetwork:
		m.ResetNetwork()
		return nil
	case tokencreate.FieldTokenIdentifier:
		m.ResetTokenIdentifier()
		return nil
	case tokencreate.FieldIssuerSignature:
		m.ResetIssuerSignature()
		return nil
	case tokencreate.FieldOperatorSpecificIssuerSignature:
		m.ResetOperatorSpecificIssuerSignature()
		return nil
	case tokencreate.FieldCreationEntityPublicKey:
		m.ResetCreationEntityPublicKey()
		return nil
	case tokencreate.FieldWalletProvidedTimestamp:
		m.ResetWalletProvidedTimestamp()
		return nil
	}
	return fmt.Errorf("unknown TokenCreate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenCreateMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.token_transaction != nil {
		edges = append(edges, tokencreate.EdgeTokenTransaction)
	}
	if m.l1_token_create != nil {
		edges = append(edges, tokencreate.EdgeL1TokenCreate)
	}
	if m.token_output != nil {
		edges = append(edges, tokencreate.EdgeTokenOutput)
	}
	if m.token_freeze != nil {
		edges = append(edges, tokencreate.EdgeTokenFreeze)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenCreateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tokencreate.EdgeTokenTransaction:
		ids := make([]ent.Value, 0, len(m.token_transaction))
		for id := range m.token_transaction {
			ids = append(ids, id)
		}
		return ids
	case tokencreate.EdgeL1TokenCreate:
		if id := m.l1_token_create; id != nil {
			return []ent.Value{*id}
		}
	case tokencreate.EdgeTokenOutput:
		ids := make([]ent.Value, 0, len(m.token_output))
		for id := range m.token_output {
			ids = append(ids, id)
		}
		return ids
	case tokencreate.EdgeTokenFreeze:
		ids := make([]ent.Value, 0, len(m.token_freeze))
		for id := range m.token_freeze {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenCreateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtoken_transaction != nil {
		edges = append(edges, tokencreate.EdgeTokenTransaction)
	}
	if m.removedtoken_output != nil {
		edges = append(edges, tokencreate.EdgeTokenOutput)
	}
	if m.removedtoken_freeze != nil {
		edges = append(edges, tokencreate.EdgeTokenFreeze)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenCreateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tokencreate.EdgeTokenTransaction:
		ids := make([]ent.Value, 0, len(m.removedtoken_transaction))
		for id := range m.removedtoken_transaction {
			ids = append(ids, id)
		}
		return ids
	case tokencreate.EdgeTokenOutput:
		ids := make([]ent.Value, 0, len(m.removedtoken_output))
		for id := range m.removedtoken_output {
			ids = append(ids, id)
		}
		return ids
	case tokencreate.EdgeTokenFreeze:
		ids := make([]ent.Value, 0, len(m.removedtoken_freeze))
		for id := range m.removedtoken_freeze {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenCreateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtoken_transaction {
		edges = append(edges, tokencreate.EdgeTokenTransaction)
	}
	if m.clearedl1_token_create {
		edges = append(edges, tokencreate.EdgeL1TokenCreate)
	}
	if m.clearedtoken_output {
		edges = append(edges, tokencreate.EdgeTokenOutput)
	}
	if m.clearedtoken_freeze {
		edges = append(edges, tokencreate.EdgeTokenFreeze)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenCreateMutation) EdgeCleared(name string) bool {
	switch name {
	case tokencreate.EdgeTokenTransaction:
		return m.clearedtoken_transaction
	case tokencreate.EdgeL1TokenCreate:
		return m.clearedl1_token_create
	case tokencreate.EdgeTokenOutput:
		return m.clearedtoken_output
	case tokencreate.EdgeTokenFreeze:
		return m.clearedtoken_freeze
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenCreateMutation) ClearEdge(name string) error {
	switch name {
	case tokencreate.EdgeL1TokenCreate:
		m.ClearL1TokenCreate()
		return nil
	}
	return fmt.Errorf("unknown TokenCreate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenCreateMutation) ResetEdge(name string) error {
	switch name {
	case tokencreate.EdgeTokenTransaction:
		m.ResetTokenTransaction()
		return nil
	case tokencreate.EdgeL1TokenCreate:
		m.ResetL1TokenCreate()
		return nil
	case tokencreate.EdgeTokenOutput:
		m.ResetTokenOutput()
		return nil
	case tokencreate.EdgeTokenFreeze:
		m.ResetTokenFreeze()
		return nil
	}
	return fmt.Errorf("unknown TokenCreate edge %s", name)
}

// TokenFreezeMutation represents an operation that mutates the TokenFreeze nodes in the graph.
type TokenFreezeMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *uuid.UUID
	create_time                         *time.Time
	update_time                         *time.Time
	status                              *schematype.TokenFreezeStatus
	owner_public_key                    *[]byte
	token_public_key                    *[]byte
	issuer_signature                    *[]byte
	wallet_provided_freeze_timestamp    *uint64
	addwallet_provided_freeze_timestamp *int64
	wallet_provided_thaw_timestamp      *uint64
	addwallet_provided_thaw_timestamp   *int64
	clearedFields                       map[string]struct{}
	token_create                        *uuid.UUID
	clearedtoken_create                 bool
	done                                bool
	oldValue                            func(context.Context) (*TokenFreeze, error)
	predicates                          []predicate.TokenFreeze
}

var _ ent.Mutation = (*TokenFreezeMutation)(nil)

// tokenfreezeOption allows management of the mutation configuration using functional options.
type tokenfreezeOption func(*TokenFreezeMutation)

// newTokenFreezeMutation creates new mutation for the TokenFreeze entity.
func newTokenFreezeMutation(c config, op Op, opts ...tokenfreezeOption) *TokenFreezeMutation {
	m := &TokenFreezeMutation{
		config:        c,
		op:            op,
		typ:           TypeTokenFreeze,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenFreezeID sets the ID field of the mutation.
func withTokenFreezeID(id uuid.UUID) tokenfreezeOption {
	return func(m *TokenFreezeMutation) {
		var (
			err   error
			once  sync.Once
			value *TokenFreeze
		)
		m.oldValue = func(ctx context.Context) (*TokenFreeze, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TokenFreeze.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTokenFreeze sets the old TokenFreeze of the mutation.
func withTokenFreeze(node *TokenFreeze) tokenfreezeOption {
	return func(m *TokenFreezeMutation) {
		m.oldValue = func(context.Context) (*TokenFreeze, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenFreezeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenFreezeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TokenFreeze entities.
func (m *TokenFreezeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenFreezeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenFreezeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TokenFreeze.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TokenFreezeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TokenFreezeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TokenFreeze entity.
// If the TokenFreeze object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenFreezeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TokenFreezeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TokenFreezeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TokenFreezeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TokenFreeze entity.
// If the TokenFreeze object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenFreezeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TokenFreezeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the "status" field.
func (m *TokenFreezeMutation) SetStatus(sfs schematype.TokenFreezeStatus) {
	m.status = &sfs
}

// Status returns the value of the "status" field in the mutation.
func (m *TokenFreezeMutation) Status() (r schematype.TokenFreezeStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TokenFreeze entity.
// If the TokenFreeze object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenFreezeMutation) OldStatus(ctx context.Context) (v schematype.TokenFreezeStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TokenFreezeMutation) ResetStatus() {
	m.status = nil
}

// SetOwnerPublicKey sets the "owner_public_key" field.
func (m *TokenFreezeMutation) SetOwnerPublicKey(b []byte) {
	m.owner_public_key = &b
}

// OwnerPublicKey returns the value of the "owner_public_key" field in the mutation.
func (m *TokenFreezeMutation) OwnerPublicKey() (r []byte, exists bool) {
	v := m.owner_public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerPublicKey returns the old "owner_public_key" field's value of the TokenFreeze entity.
// If the TokenFreeze object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenFreezeMutation) OldOwnerPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerPublicKey: %w", err)
	}
	return oldValue.OwnerPublicKey, nil
}

// ResetOwnerPublicKey resets all changes to the "owner_public_key" field.
func (m *TokenFreezeMutation) ResetOwnerPublicKey() {
	m.owner_public_key = nil
}

// SetTokenPublicKey sets the "token_public_key" field.
func (m *TokenFreezeMutation) SetTokenPublicKey(b []byte) {
	m.token_public_key = &b
}

// TokenPublicKey returns the value of the "token_public_key" field in the mutation.
func (m *TokenFreezeMutation) TokenPublicKey() (r []byte, exists bool) {
	v := m.token_public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenPublicKey returns the old "token_public_key" field's value of the TokenFreeze entity.
// If the TokenFreeze object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenFreezeMutation) OldTokenPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenPublicKey: %w", err)
	}
	return oldValue.TokenPublicKey, nil
}

// ClearTokenPublicKey clears the value of the "token_public_key" field.
func (m *TokenFreezeMutation) ClearTokenPublicKey() {
	m.token_public_key = nil
	m.clearedFields[tokenfreeze.FieldTokenPublicKey] = struct{}{}
}

// TokenPublicKeyCleared returns if the "token_public_key" field was cleared in this mutation.
func (m *TokenFreezeMutation) TokenPublicKeyCleared() bool {
	_, ok := m.clearedFields[tokenfreeze.FieldTokenPublicKey]
	return ok
}

// ResetTokenPublicKey resets all changes to the "token_public_key" field.
func (m *TokenFreezeMutation) ResetTokenPublicKey() {
	m.token_public_key = nil
	delete(m.clearedFields, tokenfreeze.FieldTokenPublicKey)
}

// SetIssuerSignature sets the "issuer_signature" field.
func (m *TokenFreezeMutation) SetIssuerSignature(b []byte) {
	m.issuer_signature = &b
}

// IssuerSignature returns the value of the "issuer_signature" field in the mutation.
func (m *TokenFreezeMutation) IssuerSignature() (r []byte, exists bool) {
	v := m.issuer_signature
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuerSignature returns the old "issuer_signature" field's value of the TokenFreeze entity.
// If the TokenFreeze object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenFreezeMutation) OldIssuerSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuerSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuerSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuerSignature: %w", err)
	}
	return oldValue.IssuerSignature, nil
}

// ResetIssuerSignature resets all changes to the "issuer_signature" field.
func (m *TokenFreezeMutation) ResetIssuerSignature() {
	m.issuer_signature = nil
}

// SetWalletProvidedFreezeTimestamp sets the "wallet_provided_freeze_timestamp" field.
func (m *TokenFreezeMutation) SetWalletProvidedFreezeTimestamp(u uint64) {
	m.wallet_provided_freeze_timestamp = &u
	m.addwallet_provided_freeze_timestamp = nil
}

// WalletProvidedFreezeTimestamp returns the value of the "wallet_provided_freeze_timestamp" field in the mutation.
func (m *TokenFreezeMutation) WalletProvidedFreezeTimestamp() (r uint64, exists bool) {
	v := m.wallet_provided_freeze_timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletProvidedFreezeTimestamp returns the old "wallet_provided_freeze_timestamp" field's value of the TokenFreeze entity.
// If the TokenFreeze object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenFreezeMutation) OldWalletProvidedFreezeTimestamp(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWalletProvidedFreezeTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWalletProvidedFreezeTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletProvidedFreezeTimestamp: %w", err)
	}
	return oldValue.WalletProvidedFreezeTimestamp, nil
}

// AddWalletProvidedFreezeTimestamp adds u to the "wallet_provided_freeze_timestamp" field.
func (m *TokenFreezeMutation) AddWalletProvidedFreezeTimestamp(u int64) {
	if m.addwallet_provided_freeze_timestamp != nil {
		*m.addwallet_provided_freeze_timestamp += u
	} else {
		m.addwallet_provided_freeze_timestamp = &u
	}
}

// AddedWalletProvidedFreezeTimestamp returns the value that was added to the "wallet_provided_freeze_timestamp" field in this mutation.
func (m *TokenFreezeMutation) AddedWalletProvidedFreezeTimestamp() (r int64, exists bool) {
	v := m.addwallet_provided_freeze_timestamp
	if v == nil {
		return
	}
	return *v, true
}

// ResetWalletProvidedFreezeTimestamp resets all changes to the "wallet_provided_freeze_timestamp" field.
func (m *TokenFreezeMutation) ResetWalletProvidedFreezeTimestamp() {
	m.wallet_provided_freeze_timestamp = nil
	m.addwallet_provided_freeze_timestamp = nil
}

// SetWalletProvidedThawTimestamp sets the "wallet_provided_thaw_timestamp" field.
func (m *TokenFreezeMutation) SetWalletProvidedThawTimestamp(u uint64) {
	m.wallet_provided_thaw_timestamp = &u
	m.addwallet_provided_thaw_timestamp = nil
}

// WalletProvidedThawTimestamp returns the value of the "wallet_provided_thaw_timestamp" field in the mutation.
func (m *TokenFreezeMutation) WalletProvidedThawTimestamp() (r uint64, exists bool) {
	v := m.wallet_provided_thaw_timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletProvidedThawTimestamp returns the old "wallet_provided_thaw_timestamp" field's value of the TokenFreeze entity.
// If the TokenFreeze object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenFreezeMutation) OldWalletProvidedThawTimestamp(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWalletProvidedThawTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWalletProvidedThawTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletProvidedThawTimestamp: %w", err)
	}
	return oldValue.WalletProvidedThawTimestamp, nil
}

// AddWalletProvidedThawTimestamp adds u to the "wallet_provided_thaw_timestamp" field.
func (m *TokenFreezeMutation) AddWalletProvidedThawTimestamp(u int64) {
	if m.addwallet_provided_thaw_timestamp != nil {
		*m.addwallet_provided_thaw_timestamp += u
	} else {
		m.addwallet_provided_thaw_timestamp = &u
	}
}

// AddedWalletProvidedThawTimestamp returns the value that was added to the "wallet_provided_thaw_timestamp" field in this mutation.
func (m *TokenFreezeMutation) AddedWalletProvidedThawTimestamp() (r int64, exists bool) {
	v := m.addwallet_provided_thaw_timestamp
	if v == nil {
		return
	}
	return *v, true
}

// ClearWalletProvidedThawTimestamp clears the value of the "wallet_provided_thaw_timestamp" field.
func (m *TokenFreezeMutation) ClearWalletProvidedThawTimestamp() {
	m.wallet_provided_thaw_timestamp = nil
	m.addwallet_provided_thaw_timestamp = nil
	m.clearedFields[tokenfreeze.FieldWalletProvidedThawTimestamp] = struct{}{}
}

// WalletProvidedThawTimestampCleared returns if the "wallet_provided_thaw_timestamp" field was cleared in this mutation.
func (m *TokenFreezeMutation) WalletProvidedThawTimestampCleared() bool {
	_, ok := m.clearedFields[tokenfreeze.FieldWalletProvidedThawTimestamp]
	return ok
}

// ResetWalletProvidedThawTimestamp resets all changes to the "wallet_provided_thaw_timestamp" field.
func (m *TokenFreezeMutation) ResetWalletProvidedThawTimestamp() {
	m.wallet_provided_thaw_timestamp = nil
	m.addwallet_provided_thaw_timestamp = nil
	delete(m.clearedFields, tokenfreeze.FieldWalletProvidedThawTimestamp)
}

// SetTokenCreateID sets the "token_create_id" field.
func (m *TokenFreezeMutation) SetTokenCreateID(u uuid.UUID) {
	m.token_create = &u
}

// TokenCreateID returns the value of the "token_create_id" field in the mutation.
func (m *TokenFreezeMutation) TokenCreateID() (r uuid.UUID, exists bool) {
	v := m.token_create
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenCreateID returns the old "token_create_id" field's value of the TokenFreeze entity.
// If the TokenFreeze object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenFreezeMutation) OldTokenCreateID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenCreateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenCreateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenCreateID: %w", err)
	}
	return oldValue.TokenCreateID, nil
}

// ResetTokenCreateID resets all changes to the "token_create_id" field.
func (m *TokenFreezeMutation) ResetTokenCreateID() {
	m.token_create = nil
}

// ClearTokenCreate clears the "token_create" edge to the TokenCreate entity.
func (m *TokenFreezeMutation) ClearTokenCreate() {
	m.clearedtoken_create = true
	m.clearedFields[tokenfreeze.FieldTokenCreateID] = struct{}{}
}

// TokenCreateCleared reports if the "token_create" edge to the TokenCreate entity was cleared.
func (m *TokenFreezeMutation) TokenCreateCleared() bool {
	return m.clearedtoken_create
}

// TokenCreateIDs returns the "token_create" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TokenCreateID instead. It exists only for internal usage by the builders.
func (m *TokenFreezeMutation) TokenCreateIDs() (ids []uuid.UUID) {
	if id := m.token_create; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTokenCreate resets all changes to the "token_create" edge.
func (m *TokenFreezeMutation) ResetTokenCreate() {
	m.token_create = nil
	m.clearedtoken_create = false
}

// Where appends a list predicates to the TokenFreezeMutation builder.
func (m *TokenFreezeMutation) Where(ps ...predicate.TokenFreeze) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenFreezeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenFreezeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TokenFreeze, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenFreezeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenFreezeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TokenFreeze).
func (m *TokenFreezeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenFreezeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, tokenfreeze.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, tokenfreeze.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, tokenfreeze.FieldStatus)
	}
	if m.owner_public_key != nil {
		fields = append(fields, tokenfreeze.FieldOwnerPublicKey)
	}
	if m.token_public_key != nil {
		fields = append(fields, tokenfreeze.FieldTokenPublicKey)
	}
	if m.issuer_signature != nil {
		fields = append(fields, tokenfreeze.FieldIssuerSignature)
	}
	if m.wallet_provided_freeze_timestamp != nil {
		fields = append(fields, tokenfreeze.FieldWalletProvidedFreezeTimestamp)
	}
	if m.wallet_provided_thaw_timestamp != nil {
		fields = append(fields, tokenfreeze.FieldWalletProvidedThawTimestamp)
	}
	if m.token_create != nil {
		fields = append(fields, tokenfreeze.FieldTokenCreateID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenFreezeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tokenfreeze.FieldCreateTime:
		return m.CreateTime()
	case tokenfreeze.FieldUpdateTime:
		return m.UpdateTime()
	case tokenfreeze.FieldStatus:
		return m.Status()
	case tokenfreeze.FieldOwnerPublicKey:
		return m.OwnerPublicKey()
	case tokenfreeze.FieldTokenPublicKey:
		return m.TokenPublicKey()
	case tokenfreeze.FieldIssuerSignature:
		return m.IssuerSignature()
	case tokenfreeze.FieldWalletProvidedFreezeTimestamp:
		return m.WalletProvidedFreezeTimestamp()
	case tokenfreeze.FieldWalletProvidedThawTimestamp:
		return m.WalletProvidedThawTimestamp()
	case tokenfreeze.FieldTokenCreateID:
		return m.TokenCreateID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenFreezeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tokenfreeze.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case tokenfreeze.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case tokenfreeze.FieldStatus:
		return m.OldStatus(ctx)
	case tokenfreeze.FieldOwnerPublicKey:
		return m.OldOwnerPublicKey(ctx)
	case tokenfreeze.FieldTokenPublicKey:
		return m.OldTokenPublicKey(ctx)
	case tokenfreeze.FieldIssuerSignature:
		return m.OldIssuerSignature(ctx)
	case tokenfreeze.FieldWalletProvidedFreezeTimestamp:
		return m.OldWalletProvidedFreezeTimestamp(ctx)
	case tokenfreeze.FieldWalletProvidedThawTimestamp:
		return m.OldWalletProvidedThawTimestamp(ctx)
	case tokenfreeze.FieldTokenCreateID:
		return m.OldTokenCreateID(ctx)
	}
	return nil, fmt.Errorf("unknown TokenFreeze field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenFreezeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tokenfreeze.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case tokenfreeze.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case tokenfreeze.FieldStatus:
		v, ok := value.(schematype.TokenFreezeStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tokenfreeze.FieldOwnerPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerPublicKey(v)
		return nil
	case tokenfreeze.FieldTokenPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenPublicKey(v)
		return nil
	case tokenfreeze.FieldIssuerSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuerSignature(v)
		return nil
	case tokenfreeze.FieldWalletProvidedFreezeTimestamp:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletProvidedFreezeTimestamp(v)
		return nil
	case tokenfreeze.FieldWalletProvidedThawTimestamp:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletProvidedThawTimestamp(v)
		return nil
	case tokenfreeze.FieldTokenCreateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenCreateID(v)
		return nil
	}
	return fmt.Errorf("unknown TokenFreeze field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenFreezeMutation) AddedFields() []string {
	var fields []string
	if m.addwallet_provided_freeze_timestamp != nil {
		fields = append(fields, tokenfreeze.FieldWalletProvidedFreezeTimestamp)
	}
	if m.addwallet_provided_thaw_timestamp != nil {
		fields = append(fields, tokenfreeze.FieldWalletProvidedThawTimestamp)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenFreezeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tokenfreeze.FieldWalletProvidedFreezeTimestamp:
		return m.AddedWalletProvidedFreezeTimestamp()
	case tokenfreeze.FieldWalletProvidedThawTimestamp:
		return m.AddedWalletProvidedThawTimestamp()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenFreezeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tokenfreeze.FieldWalletProvidedFreezeTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWalletProvidedFreezeTimestamp(v)
		return nil
	case tokenfreeze.FieldWalletProvidedThawTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWalletProvidedThawTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown TokenFreeze numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenFreezeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tokenfreeze.FieldTokenPublicKey) {
		fields = append(fields, tokenfreeze.FieldTokenPublicKey)
	}
	if m.FieldCleared(tokenfreeze.FieldWalletProvidedThawTimestamp) {
		fields = append(fields, tokenfreeze.FieldWalletProvidedThawTimestamp)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenFreezeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenFreezeMutation) ClearField(name string) error {
	switch name {
	case tokenfreeze.FieldTokenPublicKey:
		m.ClearTokenPublicKey()
		return nil
	case tokenfreeze.FieldWalletProvidedThawTimestamp:
		m.ClearWalletProvidedThawTimestamp()
		return nil
	}
	return fmt.Errorf("unknown TokenFreeze nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenFreezeMutation) ResetField(name string) error {
	switch name {
	case tokenfreeze.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case tokenfreeze.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case tokenfreeze.FieldStatus:
		m.ResetStatus()
		return nil
	case tokenfreeze.FieldOwnerPublicKey:
		m.ResetOwnerPublicKey()
		return nil
	case tokenfreeze.FieldTokenPublicKey:
		m.ResetTokenPublicKey()
		return nil
	case tokenfreeze.FieldIssuerSignature:
		m.ResetIssuerSignature()
		return nil
	case tokenfreeze.FieldWalletProvidedFreezeTimestamp:
		m.ResetWalletProvidedFreezeTimestamp()
		return nil
	case tokenfreeze.FieldWalletProvidedThawTimestamp:
		m.ResetWalletProvidedThawTimestamp()
		return nil
	case tokenfreeze.FieldTokenCreateID:
		m.ResetTokenCreateID()
		return nil
	}
	return fmt.Errorf("unknown TokenFreeze field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenFreezeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.token_create != nil {
		edges = append(edges, tokenfreeze.EdgeTokenCreate)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenFreezeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tokenfreeze.EdgeTokenCreate:
		if id := m.token_create; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenFreezeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenFreezeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenFreezeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtoken_create {
		edges = append(edges, tokenfreeze.EdgeTokenCreate)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenFreezeMutation) EdgeCleared(name string) bool {
	switch name {
	case tokenfreeze.EdgeTokenCreate:
		return m.clearedtoken_create
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenFreezeMutation) ClearEdge(name string) error {
	switch name {
	case tokenfreeze.EdgeTokenCreate:
		m.ClearTokenCreate()
		return nil
	}
	return fmt.Errorf("unknown TokenFreeze unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenFreezeMutation) ResetEdge(name string) error {
	switch name {
	case tokenfreeze.EdgeTokenCreate:
		m.ResetTokenCreate()
		return nil
	}
	return fmt.Errorf("unknown TokenFreeze edge %s", name)
}

// TokenMintMutation represents an operation that mutates the TokenMint nodes in the graph.
type TokenMintMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *uuid.UUID
	create_time                        *time.Time
	update_time                        *time.Time
	issuer_public_key                  *keys.Public
	wallet_provided_timestamp          *uint64
	addwallet_provided_timestamp       *int64
	issuer_signature                   *[]byte
	operator_specific_issuer_signature *[]byte
	token_identifier                   *[]byte
	clearedFields                      map[string]struct{}
	token_transaction                  map[uuid.UUID]struct{}
	removedtoken_transaction           map[uuid.UUID]struct{}
	clearedtoken_transaction           bool
	done                               bool
	oldValue                           func(context.Context) (*TokenMint, error)
	predicates                         []predicate.TokenMint
}

var _ ent.Mutation = (*TokenMintMutation)(nil)

// tokenmintOption allows management of the mutation configuration using functional options.
type tokenmintOption func(*TokenMintMutation)

// newTokenMintMutation creates new mutation for the TokenMint entity.
func newTokenMintMutation(c config, op Op, opts ...tokenmintOption) *TokenMintMutation {
	m := &TokenMintMutation{
		config:        c,
		op:            op,
		typ:           TypeTokenMint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenMintID sets the ID field of the mutation.
func withTokenMintID(id uuid.UUID) tokenmintOption {
	return func(m *TokenMintMutation) {
		var (
			err   error
			once  sync.Once
			value *TokenMint
		)
		m.oldValue = func(ctx context.Context) (*TokenMint, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TokenMint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTokenMint sets the old TokenMint of the mutation.
func withTokenMint(node *TokenMint) tokenmintOption {
	return func(m *TokenMintMutation) {
		m.oldValue = func(context.Context) (*TokenMint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMintMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMintMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TokenMint entities.
func (m *TokenMintMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMintMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMintMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TokenMint.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TokenMintMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TokenMintMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TokenMint entity.
// If the TokenMint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMintMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TokenMintMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TokenMintMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TokenMintMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TokenMint entity.
// If the TokenMint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMintMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TokenMintMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetIssuerPublicKey sets the "issuer_public_key" field.
func (m *TokenMintMutation) SetIssuerPublicKey(k keys.Public) {
	m.issuer_public_key = &k
}

// IssuerPublicKey returns the value of the "issuer_public_key" field in the mutation.
func (m *TokenMintMutation) IssuerPublicKey() (r keys.Public, exists bool) {
	v := m.issuer_public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuerPublicKey returns the old "issuer_public_key" field's value of the TokenMint entity.
// If the TokenMint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMintMutation) OldIssuerPublicKey(ctx context.Context) (v keys.Public, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuerPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuerPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuerPublicKey: %w", err)
	}
	return oldValue.IssuerPublicKey, nil
}

// ResetIssuerPublicKey resets all changes to the "issuer_public_key" field.
func (m *TokenMintMutation) ResetIssuerPublicKey() {
	m.issuer_public_key = nil
}

// SetWalletProvidedTimestamp sets the "wallet_provided_timestamp" field.
func (m *TokenMintMutation) SetWalletProvidedTimestamp(u uint64) {
	m.wallet_provided_timestamp = &u
	m.addwallet_provided_timestamp = nil
}

// WalletProvidedTimestamp returns the value of the "wallet_provided_timestamp" field in the mutation.
func (m *TokenMintMutation) WalletProvidedTimestamp() (r uint64, exists bool) {
	v := m.wallet_provided_timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletProvidedTimestamp returns the old "wallet_provided_timestamp" field's value of the TokenMint entity.
// If the TokenMint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMintMutation) OldWalletProvidedTimestamp(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWalletProvidedTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWalletProvidedTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletProvidedTimestamp: %w", err)
	}
	return oldValue.WalletProvidedTimestamp, nil
}

// AddWalletProvidedTimestamp adds u to the "wallet_provided_timestamp" field.
func (m *TokenMintMutation) AddWalletProvidedTimestamp(u int64) {
	if m.addwallet_provided_timestamp != nil {
		*m.addwallet_provided_timestamp += u
	} else {
		m.addwallet_provided_timestamp = &u
	}
}

// AddedWalletProvidedTimestamp returns the value that was added to the "wallet_provided_timestamp" field in this mutation.
func (m *TokenMintMutation) AddedWalletProvidedTimestamp() (r int64, exists bool) {
	v := m.addwallet_provided_timestamp
	if v == nil {
		return
	}
	return *v, true
}

// ResetWalletProvidedTimestamp resets all changes to the "wallet_provided_timestamp" field.
func (m *TokenMintMutation) ResetWalletProvidedTimestamp() {
	m.wallet_provided_timestamp = nil
	m.addwallet_provided_timestamp = nil
}

// SetIssuerSignature sets the "issuer_signature" field.
func (m *TokenMintMutation) SetIssuerSignature(b []byte) {
	m.issuer_signature = &b
}

// IssuerSignature returns the value of the "issuer_signature" field in the mutation.
func (m *TokenMintMutation) IssuerSignature() (r []byte, exists bool) {
	v := m.issuer_signature
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuerSignature returns the old "issuer_signature" field's value of the TokenMint entity.
// If the TokenMint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMintMutation) OldIssuerSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuerSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuerSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuerSignature: %w", err)
	}
	return oldValue.IssuerSignature, nil
}

// ResetIssuerSignature resets all changes to the "issuer_signature" field.
func (m *TokenMintMutation) ResetIssuerSignature() {
	m.issuer_signature = nil
}

// SetOperatorSpecificIssuerSignature sets the "operator_specific_issuer_signature" field.
func (m *TokenMintMutation) SetOperatorSpecificIssuerSignature(b []byte) {
	m.operator_specific_issuer_signature = &b
}

// OperatorSpecificIssuerSignature returns the value of the "operator_specific_issuer_signature" field in the mutation.
func (m *TokenMintMutation) OperatorSpecificIssuerSignature() (r []byte, exists bool) {
	v := m.operator_specific_issuer_signature
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorSpecificIssuerSignature returns the old "operator_specific_issuer_signature" field's value of the TokenMint entity.
// If the TokenMint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMintMutation) OldOperatorSpecificIssuerSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorSpecificIssuerSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorSpecificIssuerSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorSpecificIssuerSignature: %w", err)
	}
	return oldValue.OperatorSpecificIssuerSignature, nil
}

// ClearOperatorSpecificIssuerSignature clears the value of the "operator_specific_issuer_signature" field.
func (m *TokenMintMutation) ClearOperatorSpecificIssuerSignature() {
	m.operator_specific_issuer_signature = nil
	m.clearedFields[tokenmint.FieldOperatorSpecificIssuerSignature] = struct{}{}
}

// OperatorSpecificIssuerSignatureCleared returns if the "operator_specific_issuer_signature" field was cleared in this mutation.
func (m *TokenMintMutation) OperatorSpecificIssuerSignatureCleared() bool {
	_, ok := m.clearedFields[tokenmint.FieldOperatorSpecificIssuerSignature]
	return ok
}

// ResetOperatorSpecificIssuerSignature resets all changes to the "operator_specific_issuer_signature" field.
func (m *TokenMintMutation) ResetOperatorSpecificIssuerSignature() {
	m.operator_specific_issuer_signature = nil
	delete(m.clearedFields, tokenmint.FieldOperatorSpecificIssuerSignature)
}

// SetTokenIdentifier sets the "token_identifier" field.
func (m *TokenMintMutation) SetTokenIdentifier(b []byte) {
	m.token_identifier = &b
}

// TokenIdentifier returns the value of the "token_identifier" field in the mutation.
func (m *TokenMintMutation) TokenIdentifier() (r []byte, exists bool) {
	v := m.token_identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenIdentifier returns the old "token_identifier" field's value of the TokenMint entity.
// If the TokenMint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMintMutation) OldTokenIdentifier(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenIdentifier: %w", err)
	}
	return oldValue.TokenIdentifier, nil
}

// ClearTokenIdentifier clears the value of the "token_identifier" field.
func (m *TokenMintMutation) ClearTokenIdentifier() {
	m.token_identifier = nil
	m.clearedFields[tokenmint.FieldTokenIdentifier] = struct{}{}
}

// TokenIdentifierCleared returns if the "token_identifier" field was cleared in this mutation.
func (m *TokenMintMutation) TokenIdentifierCleared() bool {
	_, ok := m.clearedFields[tokenmint.FieldTokenIdentifier]
	return ok
}

// ResetTokenIdentifier resets all changes to the "token_identifier" field.
func (m *TokenMintMutation) ResetTokenIdentifier() {
	m.token_identifier = nil
	delete(m.clearedFields, tokenmint.FieldTokenIdentifier)
}

// AddTokenTransactionIDs adds the "token_transaction" edge to the TokenTransaction entity by ids.
func (m *TokenMintMutation) AddTokenTransactionIDs(ids ...uuid.UUID) {
	if m.token_transaction == nil {
		m.token_transaction = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.token_transaction[ids[i]] = struct{}{}
	}
}

// ClearTokenTransaction clears the "token_transaction" edge to the TokenTransaction entity.
func (m *TokenMintMutation) ClearTokenTransaction() {
	m.clearedtoken_transaction = true
}

// TokenTransactionCleared reports if the "token_transaction" edge to the TokenTransaction entity was cleared.
func (m *TokenMintMutation) TokenTransactionCleared() bool {
	return m.clearedtoken_transaction
}

// RemoveTokenTransactionIDs removes the "token_transaction" edge to the TokenTransaction entity by IDs.
func (m *TokenMintMutation) RemoveTokenTransactionIDs(ids ...uuid.UUID) {
	if m.removedtoken_transaction == nil {
		m.removedtoken_transaction = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.token_transaction, ids[i])
		m.removedtoken_transaction[ids[i]] = struct{}{}
	}
}

// RemovedTokenTransaction returns the removed IDs of the "token_transaction" edge to the TokenTransaction entity.
func (m *TokenMintMutation) RemovedTokenTransactionIDs() (ids []uuid.UUID) {
	for id := range m.removedtoken_transaction {
		ids = append(ids, id)
	}
	return
}

// TokenTransactionIDs returns the "token_transaction" edge IDs in the mutation.
func (m *TokenMintMutation) TokenTransactionIDs() (ids []uuid.UUID) {
	for id := range m.token_transaction {
		ids = append(ids, id)
	}
	return
}

// ResetTokenTransaction resets all changes to the "token_transaction" edge.
func (m *TokenMintMutation) ResetTokenTransaction() {
	m.token_transaction = nil
	m.clearedtoken_transaction = false
	m.removedtoken_transaction = nil
}

// Where appends a list predicates to the TokenMintMutation builder.
func (m *TokenMintMutation) Where(ps ...predicate.TokenMint) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMintMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMintMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TokenMint, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMintMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMintMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TokenMint).
func (m *TokenMintMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMintMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, tokenmint.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, tokenmint.FieldUpdateTime)
	}
	if m.issuer_public_key != nil {
		fields = append(fields, tokenmint.FieldIssuerPublicKey)
	}
	if m.wallet_provided_timestamp != nil {
		fields = append(fields, tokenmint.FieldWalletProvidedTimestamp)
	}
	if m.issuer_signature != nil {
		fields = append(fields, tokenmint.FieldIssuerSignature)
	}
	if m.operator_specific_issuer_signature != nil {
		fields = append(fields, tokenmint.FieldOperatorSpecificIssuerSignature)
	}
	if m.token_identifier != nil {
		fields = append(fields, tokenmint.FieldTokenIdentifier)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMintMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tokenmint.FieldCreateTime:
		return m.CreateTime()
	case tokenmint.FieldUpdateTime:
		return m.UpdateTime()
	case tokenmint.FieldIssuerPublicKey:
		return m.IssuerPublicKey()
	case tokenmint.FieldWalletProvidedTimestamp:
		return m.WalletProvidedTimestamp()
	case tokenmint.FieldIssuerSignature:
		return m.IssuerSignature()
	case tokenmint.FieldOperatorSpecificIssuerSignature:
		return m.OperatorSpecificIssuerSignature()
	case tokenmint.FieldTokenIdentifier:
		return m.TokenIdentifier()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMintMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tokenmint.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case tokenmint.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case tokenmint.FieldIssuerPublicKey:
		return m.OldIssuerPublicKey(ctx)
	case tokenmint.FieldWalletProvidedTimestamp:
		return m.OldWalletProvidedTimestamp(ctx)
	case tokenmint.FieldIssuerSignature:
		return m.OldIssuerSignature(ctx)
	case tokenmint.FieldOperatorSpecificIssuerSignature:
		return m.OldOperatorSpecificIssuerSignature(ctx)
	case tokenmint.FieldTokenIdentifier:
		return m.OldTokenIdentifier(ctx)
	}
	return nil, fmt.Errorf("unknown TokenMint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMintMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tokenmint.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case tokenmint.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case tokenmint.FieldIssuerPublicKey:
		v, ok := value.(keys.Public)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuerPublicKey(v)
		return nil
	case tokenmint.FieldWalletProvidedTimestamp:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletProvidedTimestamp(v)
		return nil
	case tokenmint.FieldIssuerSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuerSignature(v)
		return nil
	case tokenmint.FieldOperatorSpecificIssuerSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorSpecificIssuerSignature(v)
		return nil
	case tokenmint.FieldTokenIdentifier:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenIdentifier(v)
		return nil
	}
	return fmt.Errorf("unknown TokenMint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMintMutation) AddedFields() []string {
	var fields []string
	if m.addwallet_provided_timestamp != nil {
		fields = append(fields, tokenmint.FieldWalletProvidedTimestamp)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMintMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tokenmint.FieldWalletProvidedTimestamp:
		return m.AddedWalletProvidedTimestamp()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMintMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tokenmint.FieldWalletProvidedTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWalletProvidedTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown TokenMint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMintMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tokenmint.FieldOperatorSpecificIssuerSignature) {
		fields = append(fields, tokenmint.FieldOperatorSpecificIssuerSignature)
	}
	if m.FieldCleared(tokenmint.FieldTokenIdentifier) {
		fields = append(fields, tokenmint.FieldTokenIdentifier)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMintMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMintMutation) ClearField(name string) error {
	switch name {
	case tokenmint.FieldOperatorSpecificIssuerSignature:
		m.ClearOperatorSpecificIssuerSignature()
		return nil
	case tokenmint.FieldTokenIdentifier:
		m.ClearTokenIdentifier()
		return nil
	}
	return fmt.Errorf("unknown TokenMint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMintMutation) ResetField(name string) error {
	switch name {
	case tokenmint.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case tokenmint.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case tokenmint.FieldIssuerPublicKey:
		m.ResetIssuerPublicKey()
		return nil
	case tokenmint.FieldWalletProvidedTimestamp:
		m.ResetWalletProvidedTimestamp()
		return nil
	case tokenmint.FieldIssuerSignature:
		m.ResetIssuerSignature()
		return nil
	case tokenmint.FieldOperatorSpecificIssuerSignature:
		m.ResetOperatorSpecificIssuerSignature()
		return nil
	case tokenmint.FieldTokenIdentifier:
		m.ResetTokenIdentifier()
		return nil
	}
	return fmt.Errorf("unknown TokenMint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMintMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.token_transaction != nil {
		edges = append(edges, tokenmint.EdgeTokenTransaction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMintMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tokenmint.EdgeTokenTransaction:
		ids := make([]ent.Value, 0, len(m.token_transaction))
		for id := range m.token_transaction {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMintMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtoken_transaction != nil {
		edges = append(edges, tokenmint.EdgeTokenTransaction)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMintMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tokenmint.EdgeTokenTransaction:
		ids := make([]ent.Value, 0, len(m.removedtoken_transaction))
		for id := range m.removedtoken_transaction {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMintMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtoken_transaction {
		edges = append(edges, tokenmint.EdgeTokenTransaction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMintMutation) EdgeCleared(name string) bool {
	switch name {
	case tokenmint.EdgeTokenTransaction:
		return m.clearedtoken_transaction
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMintMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TokenMint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMintMutation) ResetEdge(name string) error {
	switch name {
	case tokenmint.EdgeTokenTransaction:
		m.ResetTokenTransaction()
		return nil
	}
	return fmt.Errorf("unknown TokenMint edge %s", name)
}

// TokenOutputMutation represents an operation that mutates the TokenOutput nodes in the graph.
type TokenOutputMutation struct {
	config
	op                                             Op
	typ                                            string
	id                                             *uuid.UUID
	create_time                                    *time.Time
	update_time                                    *time.Time
	status                                         *schematype.TokenOutputStatus
	owner_public_key                               *keys.Public
	withdraw_bond_sats                             *uint64
	addwithdraw_bond_sats                          *int64
	withdraw_relative_block_locktime               *uint64
	addwithdraw_relative_block_locktime            *int64
	withdraw_revocation_commitment                 *[]byte
	token_public_key                               *keys.Public
	token_amount                                   *[]byte
	created_transaction_output_vout                *int32
	addcreated_transaction_output_vout             *int32
	spent_ownership_signature                      *[]byte
	spent_operator_specific_ownership_signature    *[]byte
	spent_transaction_input_vout                   *int32
	addspent_transaction_input_vout                *int32
	spent_revocation_secret                        *[]byte
	confirmed_withdraw_block_hash                  *[]byte
	network                                        *schematype.Network
	token_identifier                               *[]byte
	clearedFields                                  map[string]struct{}
	revocation_keyshare                            *uuid.UUID
	clearedrevocation_keyshare                     bool
	output_created_token_transaction               *uuid.UUID
	clearedoutput_created_token_transaction        bool
	output_spent_token_transaction                 *uuid.UUID
	clearedoutput_spent_token_transaction          bool
	output_spent_started_token_transactions        map[uuid.UUID]struct{}
	removedoutput_spent_started_token_transactions map[uuid.UUID]struct{}
	clearedoutput_spent_started_token_transactions bool
	token_partial_revocation_secret_shares         map[uuid.UUID]struct{}
	removedtoken_partial_revocation_secret_shares  map[uuid.UUID]struct{}
	clearedtoken_partial_revocation_secret_shares  bool
	token_create                                   *uuid.UUID
	clearedtoken_create                            bool
	done                                           bool
	oldValue                                       func(context.Context) (*TokenOutput, error)
	predicates                                     []predicate.TokenOutput
}

var _ ent.Mutation = (*TokenOutputMutation)(nil)

// tokenoutputOption allows management of the mutation configuration using functional options.
type tokenoutputOption func(*TokenOutputMutation)

// newTokenOutputMutation creates new mutation for the TokenOutput entity.
func newTokenOutputMutation(c config, op Op, opts ...tokenoutputOption) *TokenOutputMutation {
	m := &TokenOutputMutation{
		config:        c,
		op:            op,
		typ:           TypeTokenOutput,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenOutputID sets the ID field of the mutation.
func withTokenOutputID(id uuid.UUID) tokenoutputOption {
	return func(m *TokenOutputMutation) {
		var (
			err   error
			once  sync.Once
			value *TokenOutput
		)
		m.oldValue = func(ctx context.Context) (*TokenOutput, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TokenOutput.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTokenOutput sets the old TokenOutput of the mutation.
func withTokenOutput(node *TokenOutput) tokenoutputOption {
	return func(m *TokenOutputMutation) {
		m.oldValue = func(context.Context) (*TokenOutput, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenOutputMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenOutputMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TokenOutput entities.
func (m *TokenOutputMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenOutputMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenOutputMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TokenOutput.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TokenOutputMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TokenOutputMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TokenOutput entity.
// If the TokenOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenOutputMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TokenOutputMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TokenOutputMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TokenOutputMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TokenOutput entity.
// If the TokenOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenOutputMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TokenOutputMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the "status" field.
func (m *TokenOutputMutation) SetStatus(sos schematype.TokenOutputStatus) {
	m.status = &sos
}

// Status returns the value of the "status" field in the mutation.
func (m *TokenOutputMutation) Status() (r schematype.TokenOutputStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TokenOutput entity.
// If the TokenOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenOutputMutation) OldStatus(ctx context.Context) (v schematype.TokenOutputStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TokenOutputMutation) ResetStatus() {
	m.status = nil
}

// SetOwnerPublicKey sets the "owner_public_key" field.
func (m *TokenOutputMutation) SetOwnerPublicKey(k keys.Public) {
	m.owner_public_key = &k
}

// OwnerPublicKey returns the value of the "owner_public_key" field in the mutation.
func (m *TokenOutputMutation) OwnerPublicKey() (r keys.Public, exists bool) {
	v := m.owner_public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerPublicKey returns the old "owner_public_key" field's value of the TokenOutput entity.
// If the TokenOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenOutputMutation) OldOwnerPublicKey(ctx context.Context) (v keys.Public, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerPublicKey: %w", err)
	}
	return oldValue.OwnerPublicKey, nil
}

// ResetOwnerPublicKey resets all changes to the "owner_public_key" field.
func (m *TokenOutputMutation) ResetOwnerPublicKey() {
	m.owner_public_key = nil
}

// SetWithdrawBondSats sets the "withdraw_bond_sats" field.
func (m *TokenOutputMutation) SetWithdrawBondSats(u uint64) {
	m.withdraw_bond_sats = &u
	m.addwithdraw_bond_sats = nil
}

// WithdrawBondSats returns the value of the "withdraw_bond_sats" field in the mutation.
func (m *TokenOutputMutation) WithdrawBondSats() (r uint64, exists bool) {
	v := m.withdraw_bond_sats
	if v == nil {
		return
	}
	return *v, true
}

// OldWithdrawBondSats returns the old "withdraw_bond_sats" field's value of the TokenOutput entity.
// If the TokenOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenOutputMutation) OldWithdrawBondSats(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithdrawBondSats is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithdrawBondSats requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithdrawBondSats: %w", err)
	}
	return oldValue.WithdrawBondSats, nil
}

// AddWithdrawBondSats adds u to the "withdraw_bond_sats" field.
func (m *TokenOutputMutation) AddWithdrawBondSats(u int64) {
	if m.addwithdraw_bond_sats != nil {
		*m.addwithdraw_bond_sats += u
	} else {
		m.addwithdraw_bond_sats = &u
	}
}

// AddedWithdrawBondSats returns the value that was added to the "withdraw_bond_sats" field in this mutation.
func (m *TokenOutputMutation) AddedWithdrawBondSats() (r int64, exists bool) {
	v := m.addwithdraw_bond_sats
	if v == nil {
		return
	}
	return *v, true
}

// ResetWithdrawBondSats resets all changes to the "withdraw_bond_sats" field.
func (m *TokenOutputMutation) ResetWithdrawBondSats() {
	m.withdraw_bond_sats = nil
	m.addwithdraw_bond_sats = nil
}

// SetWithdrawRelativeBlockLocktime sets the "withdraw_relative_block_locktime" field.
func (m *TokenOutputMutation) SetWithdrawRelativeBlockLocktime(u uint64) {
	m.withdraw_relative_block_locktime = &u
	m.addwithdraw_relative_block_locktime = nil
}

// WithdrawRelativeBlockLocktime returns the value of the "withdraw_relative_block_locktime" field in the mutation.
func (m *TokenOutputMutation) WithdrawRelativeBlockLocktime() (r uint64, exists bool) {
	v := m.withdraw_relative_block_locktime
	if v == nil {
		return
	}
	return *v, true
}

// OldWithdrawRelativeBlockLocktime returns the old "withdraw_relative_block_locktime" field's value of the TokenOutput entity.
// If the TokenOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenOutputMutation) OldWithdrawRelativeBlockLocktime(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithdrawRelativeBlockLocktime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithdrawRelativeBlockLocktime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithdrawRelativeBlockLocktime: %w", err)
	}
	return oldValue.WithdrawRelativeBlockLocktime, nil
}

// AddWithdrawRelativeBlockLocktime adds u to the "withdraw_relative_block_locktime" field.
func (m *TokenOutputMutation) AddWithdrawRelativeBlockLocktime(u int64) {
	if m.addwithdraw_relative_block_locktime != nil {
		*m.addwithdraw_relative_block_locktime += u
	} else {
		m.addwithdraw_relative_block_locktime = &u
	}
}

// AddedWithdrawRelativeBlockLocktime returns the value that was added to the "withdraw_relative_block_locktime" field in this mutation.
func (m *TokenOutputMutation) AddedWithdrawRelativeBlockLocktime() (r int64, exists bool) {
	v := m.addwithdraw_relative_block_locktime
	if v == nil {
		return
	}
	return *v, true
}

// ResetWithdrawRelativeBlockLocktime resets all changes to the "withdraw_relative_block_locktime" field.
func (m *TokenOutputMutation) ResetWithdrawRelativeBlockLocktime() {
	m.withdraw_relative_block_locktime = nil
	m.addwithdraw_relative_block_locktime = nil
}

// SetWithdrawRevocationCommitment sets the "withdraw_revocation_commitment" field.
func (m *TokenOutputMutation) SetWithdrawRevocationCommitment(b []byte) {
	m.withdraw_revocation_commitment = &b
}

// WithdrawRevocationCommitment returns the value of the "withdraw_revocation_commitment" field in the mutation.
func (m *TokenOutputMutation) WithdrawRevocationCommitment() (r []byte, exists bool) {
	v := m.withdraw_revocation_commitment
	if v == nil {
		return
	}
	return *v, true
}

// OldWithdrawRevocationCommitment returns the old "withdraw_revocation_commitment" field's value of the TokenOutput entity.
// If the TokenOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenOutputMutation) OldWithdrawRevocationCommitment(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithdrawRevocationCommitment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithdrawRevocationCommitment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithdrawRevocationCommitment: %w", err)
	}
	return oldValue.WithdrawRevocationCommitment, nil
}

// ResetWithdrawRevocationCommitment resets all changes to the "withdraw_revocation_commitment" field.
func (m *TokenOutputMutation) ResetWithdrawRevocationCommitment() {
	m.withdraw_revocation_commitment = nil
}

// SetTokenPublicKey sets the "token_public_key" field.
func (m *TokenOutputMutation) SetTokenPublicKey(k keys.Public) {
	m.token_public_key = &k
}

// TokenPublicKey returns the value of the "token_public_key" field in the mutation.
func (m *TokenOutputMutation) TokenPublicKey() (r keys.Public, exists bool) {
	v := m.token_public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenPublicKey returns the old "token_public_key" field's value of the TokenOutput entity.
// If the TokenOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenOutputMutation) OldTokenPublicKey(ctx context.Context) (v keys.Public, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenPublicKey: %w", err)
	}
	return oldValue.TokenPublicKey, nil
}

// ClearTokenPublicKey clears the value of the "token_public_key" field.
func (m *TokenOutputMutation) ClearTokenPublicKey() {
	m.token_public_key = nil
	m.clearedFields[tokenoutput.FieldTokenPublicKey] = struct{}{}
}

// TokenPublicKeyCleared returns if the "token_public_key" field was cleared in this mutation.
func (m *TokenOutputMutation) TokenPublicKeyCleared() bool {
	_, ok := m.clearedFields[tokenoutput.FieldTokenPublicKey]
	return ok
}

// ResetTokenPublicKey resets all changes to the "token_public_key" field.
func (m *TokenOutputMutation) ResetTokenPublicKey() {
	m.token_public_key = nil
	delete(m.clearedFields, tokenoutput.FieldTokenPublicKey)
}

// SetTokenAmount sets the "token_amount" field.
func (m *TokenOutputMutation) SetTokenAmount(b []byte) {
	m.token_amount = &b
}

// TokenAmount returns the value of the "token_amount" field in the mutation.
func (m *TokenOutputMutation) TokenAmount() (r []byte, exists bool) {
	v := m.token_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenAmount returns the old "token_amount" field's value of the TokenOutput entity.
// If the TokenOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenOutputMutation) OldTokenAmount(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenAmount: %w", err)
	}
	return oldValue.TokenAmount, nil
}

// ResetTokenAmount resets all changes to the "token_amount" field.
func (m *TokenOutputMutation) ResetTokenAmount() {
	m.token_amount = nil
}

// SetCreatedTransactionOutputVout sets the "created_transaction_output_vout" field.
func (m *TokenOutputMutation) SetCreatedTransactionOutputVout(i int32) {
	m.created_transaction_output_vout = &i
	m.addcreated_transaction_output_vout = nil
}

// CreatedTransactionOutputVout returns the value of the "created_transaction_output_vout" field in the mutation.
func (m *TokenOutputMutation) CreatedTransactionOutputVout() (r int32, exists bool) {
	v := m.created_transaction_output_vout
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTransactionOutputVout returns the old "created_transaction_output_vout" field's value of the TokenOutput entity.
// If the TokenOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenOutputMutation) OldCreatedTransactionOutputVout(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTransactionOutputVout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTransactionOutputVout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTransactionOutputVout: %w", err)
	}
	return oldValue.CreatedTransactionOutputVout, nil
}

// AddCreatedTransactionOutputVout adds i to the "created_transaction_output_vout" field.
func (m *TokenOutputMutation) AddCreatedTransactionOutputVout(i int32) {
	if m.addcreated_transaction_output_vout != nil {
		*m.addcreated_transaction_output_vout += i
	} else {
		m.addcreated_transaction_output_vout = &i
	}
}

// AddedCreatedTransactionOutputVout returns the value that was added to the "created_transaction_output_vout" field in this mutation.
func (m *TokenOutputMutation) AddedCreatedTransactionOutputVout() (r int32, exists bool) {
	v := m.addcreated_transaction_output_vout
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedTransactionOutputVout resets all changes to the "created_transaction_output_vout" field.
func (m *TokenOutputMutation) ResetCreatedTransactionOutputVout() {
	m.created_transaction_output_vout = nil
	m.addcreated_transaction_output_vout = nil
}

// SetSpentOwnershipSignature sets the "spent_ownership_signature" field.
func (m *TokenOutputMutation) SetSpentOwnershipSignature(b []byte) {
	m.spent_ownership_signature = &b
}

// SpentOwnershipSignature returns the value of the "spent_ownership_signature" field in the mutation.
func (m *TokenOutputMutation) SpentOwnershipSignature() (r []byte, exists bool) {
	v := m.spent_ownership_signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSpentOwnershipSignature returns the old "spent_ownership_signature" field's value of the TokenOutput entity.
// If the TokenOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenOutputMutation) OldSpentOwnershipSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpentOwnershipSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpentOwnershipSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpentOwnershipSignature: %w", err)
	}
	return oldValue.SpentOwnershipSignature, nil
}

// ClearSpentOwnershipSignature clears the value of the "spent_ownership_signature" field.
func (m *TokenOutputMutation) ClearSpentOwnershipSignature() {
	m.spent_ownership_signature = nil
	m.clearedFields[tokenoutput.FieldSpentOwnershipSignature] = struct{}{}
}

// SpentOwnershipSignatureCleared returns if the "spent_ownership_signature" field was cleared in this mutation.
func (m *TokenOutputMutation) SpentOwnershipSignatureCleared() bool {
	_, ok := m.clearedFields[tokenoutput.FieldSpentOwnershipSignature]
	return ok
}

// ResetSpentOwnershipSignature resets all changes to the "spent_ownership_signature" field.
func (m *TokenOutputMutation) ResetSpentOwnershipSignature() {
	m.spent_ownership_signature = nil
	delete(m.clearedFields, tokenoutput.FieldSpentOwnershipSignature)
}

// SetSpentOperatorSpecificOwnershipSignature sets the "spent_operator_specific_ownership_signature" field.
func (m *TokenOutputMutation) SetSpentOperatorSpecificOwnershipSignature(b []byte) {
	m.spent_operator_specific_ownership_signature = &b
}

// SpentOperatorSpecificOwnershipSignature returns the value of the "spent_operator_specific_ownership_signature" field in the mutation.
func (m *TokenOutputMutation) SpentOperatorSpecificOwnershipSignature() (r []byte, exists bool) {
	v := m.spent_operator_specific_ownership_signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSpentOperatorSpecificOwnershipSignature returns the old "spent_operator_specific_ownership_signature" field's value of the TokenOutput entity.
// If the TokenOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenOutputMutation) OldSpentOperatorSpecificOwnershipSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpentOperatorSpecificOwnershipSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpentOperatorSpecificOwnershipSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpentOperatorSpecificOwnershipSignature: %w", err)
	}
	return oldValue.SpentOperatorSpecificOwnershipSignature, nil
}

// ClearSpentOperatorSpecificOwnershipSignature clears the value of the "spent_operator_specific_ownership_signature" field.
func (m *TokenOutputMutation) ClearSpentOperatorSpecificOwnershipSignature() {
	m.spent_operator_specific_ownership_signature = nil
	m.clearedFields[tokenoutput.FieldSpentOperatorSpecificOwnershipSignature] = struct{}{}
}

// SpentOperatorSpecificOwnershipSignatureCleared returns if the "spent_operator_specific_ownership_signature" field was cleared in this mutation.
func (m *TokenOutputMutation) SpentOperatorSpecificOwnershipSignatureCleared() bool {
	_, ok := m.clearedFields[tokenoutput.FieldSpentOperatorSpecificOwnershipSignature]
	return ok
}

// ResetSpentOperatorSpecificOwnershipSignature resets all changes to the "spent_operator_specific_ownership_signature" field.
func (m *TokenOutputMutation) ResetSpentOperatorSpecificOwnershipSignature() {
	m.spent_operator_specific_ownership_signature = nil
	delete(m.clearedFields, tokenoutput.FieldSpentOperatorSpecificOwnershipSignature)
}

// SetSpentTransactionInputVout sets the "spent_transaction_input_vout" field.
func (m *TokenOutputMutation) SetSpentTransactionInputVout(i int32) {
	m.spent_transaction_input_vout = &i
	m.addspent_transaction_input_vout = nil
}

// SpentTransactionInputVout returns the value of the "spent_transaction_input_vout" field in the mutation.
func (m *TokenOutputMutation) SpentTransactionInputVout() (r int32, exists bool) {
	v := m.spent_transaction_input_vout
	if v == nil {
		return
	}
	return *v, true
}

// OldSpentTransactionInputVout returns the old "spent_transaction_input_vout" field's value of the TokenOutput entity.
// If the TokenOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenOutputMutation) OldSpentTransactionInputVout(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpentTransactionInputVout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpentTransactionInputVout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpentTransactionInputVout: %w", err)
	}
	return oldValue.SpentTransactionInputVout, nil
}

// AddSpentTransactionInputVout adds i to the "spent_transaction_input_vout" field.
func (m *TokenOutputMutation) AddSpentTransactionInputVout(i int32) {
	if m.addspent_transaction_input_vout != nil {
		*m.addspent_transaction_input_vout += i
	} else {
		m.addspent_transaction_input_vout = &i
	}
}

// AddedSpentTransactionInputVout returns the value that was added to the "spent_transaction_input_vout" field in this mutation.
func (m *TokenOutputMutation) AddedSpentTransactionInputVout() (r int32, exists bool) {
	v := m.addspent_transaction_input_vout
	if v == nil {
		return
	}
	return *v, true
}

// ClearSpentTransactionInputVout clears the value of the "spent_transaction_input_vout" field.
func (m *TokenOutputMutation) ClearSpentTransactionInputVout() {
	m.spent_transaction_input_vout = nil
	m.addspent_transaction_input_vout = nil
	m.clearedFields[tokenoutput.FieldSpentTransactionInputVout] = struct{}{}
}

// SpentTransactionInputVoutCleared returns if the "spent_transaction_input_vout" field was cleared in this mutation.
func (m *TokenOutputMutation) SpentTransactionInputVoutCleared() bool {
	_, ok := m.clearedFields[tokenoutput.FieldSpentTransactionInputVout]
	return ok
}

// ResetSpentTransactionInputVout resets all changes to the "spent_transaction_input_vout" field.
func (m *TokenOutputMutation) ResetSpentTransactionInputVout() {
	m.spent_transaction_input_vout = nil
	m.addspent_transaction_input_vout = nil
	delete(m.clearedFields, tokenoutput.FieldSpentTransactionInputVout)
}

// SetSpentRevocationSecret sets the "spent_revocation_secret" field.
func (m *TokenOutputMutation) SetSpentRevocationSecret(b []byte) {
	m.spent_revocation_secret = &b
}

// SpentRevocationSecret returns the value of the "spent_revocation_secret" field in the mutation.
func (m *TokenOutputMutation) SpentRevocationSecret() (r []byte, exists bool) {
	v := m.spent_revocation_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSpentRevocationSecret returns the old "spent_revocation_secret" field's value of the TokenOutput entity.
// If the TokenOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenOutputMutation) OldSpentRevocationSecret(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpentRevocationSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpentRevocationSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpentRevocationSecret: %w", err)
	}
	return oldValue.SpentRevocationSecret, nil
}

// ClearSpentRevocationSecret clears the value of the "spent_revocation_secret" field.
func (m *TokenOutputMutation) ClearSpentRevocationSecret() {
	m.spent_revocation_secret = nil
	m.clearedFields[tokenoutput.FieldSpentRevocationSecret] = struct{}{}
}

// SpentRevocationSecretCleared returns if the "spent_revocation_secret" field was cleared in this mutation.
func (m *TokenOutputMutation) SpentRevocationSecretCleared() bool {
	_, ok := m.clearedFields[tokenoutput.FieldSpentRevocationSecret]
	return ok
}

// ResetSpentRevocationSecret resets all changes to the "spent_revocation_secret" field.
func (m *TokenOutputMutation) ResetSpentRevocationSecret() {
	m.spent_revocation_secret = nil
	delete(m.clearedFields, tokenoutput.FieldSpentRevocationSecret)
}

// SetConfirmedWithdrawBlockHash sets the "confirmed_withdraw_block_hash" field.
func (m *TokenOutputMutation) SetConfirmedWithdrawBlockHash(b []byte) {
	m.confirmed_withdraw_block_hash = &b
}

// ConfirmedWithdrawBlockHash returns the value of the "confirmed_withdraw_block_hash" field in the mutation.
func (m *TokenOutputMutation) ConfirmedWithdrawBlockHash() (r []byte, exists bool) {
	v := m.confirmed_withdraw_block_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldConfirmedWithdrawBlockHash returns the old "confirmed_withdraw_block_hash" field's value of the TokenOutput entity.
// If the TokenOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenOutputMutation) OldConfirmedWithdrawBlockHash(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfirmedWithdrawBlockHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfirmedWithdrawBlockHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfirmedWithdrawBlockHash: %w", err)
	}
	return oldValue.ConfirmedWithdrawBlockHash, nil
}

// ClearConfirmedWithdrawBlockHash clears the value of the "confirmed_withdraw_block_hash" field.
func (m *TokenOutputMutation) ClearConfirmedWithdrawBlockHash() {
	m.confirmed_withdraw_block_hash = nil
	m.clearedFields[tokenoutput.FieldConfirmedWithdrawBlockHash] = struct{}{}
}

// ConfirmedWithdrawBlockHashCleared returns if the "confirmed_withdraw_block_hash" field was cleared in this mutation.
func (m *TokenOutputMutation) ConfirmedWithdrawBlockHashCleared() bool {
	_, ok := m.clearedFields[tokenoutput.FieldConfirmedWithdrawBlockHash]
	return ok
}

// ResetConfirmedWithdrawBlockHash resets all changes to the "confirmed_withdraw_block_hash" field.
func (m *TokenOutputMutation) ResetConfirmedWithdrawBlockHash() {
	m.confirmed_withdraw_block_hash = nil
	delete(m.clearedFields, tokenoutput.FieldConfirmedWithdrawBlockHash)
}

// SetNetwork sets the "network" field.
func (m *TokenOutputMutation) SetNetwork(s schematype.Network) {
	m.network = &s
}

// Network returns the value of the "network" field in the mutation.
func (m *TokenOutputMutation) Network() (r schematype.Network, exists bool) {
	v := m.network
	if v == nil {
		return
	}
	return *v, true
}

// OldNetwork returns the old "network" field's value of the TokenOutput entity.
// If the TokenOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenOutputMutation) OldNetwork(ctx context.Context) (v schematype.Network, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetwork is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetwork requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetwork: %w", err)
	}
	return oldValue.Network, nil
}

// ClearNetwork clears the value of the "network" field.
func (m *TokenOutputMutation) ClearNetwork() {
	m.network = nil
	m.clearedFields[tokenoutput.FieldNetwork] = struct{}{}
}

// NetworkCleared returns if the "network" field was cleared in this mutation.
func (m *TokenOutputMutation) NetworkCleared() bool {
	_, ok := m.clearedFields[tokenoutput.FieldNetwork]
	return ok
}

// ResetNetwork resets all changes to the "network" field.
func (m *TokenOutputMutation) ResetNetwork() {
	m.network = nil
	delete(m.clearedFields, tokenoutput.FieldNetwork)
}

// SetTokenIdentifier sets the "token_identifier" field.
func (m *TokenOutputMutation) SetTokenIdentifier(b []byte) {
	m.token_identifier = &b
}

// TokenIdentifier returns the value of the "token_identifier" field in the mutation.
func (m *TokenOutputMutation) TokenIdentifier() (r []byte, exists bool) {
	v := m.token_identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenIdentifier returns the old "token_identifier" field's value of the TokenOutput entity.
// If the TokenOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenOutputMutation) OldTokenIdentifier(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenIdentifier: %w", err)
	}
	return oldValue.TokenIdentifier, nil
}

// ResetTokenIdentifier resets all changes to the "token_identifier" field.
func (m *TokenOutputMutation) ResetTokenIdentifier() {
	m.token_identifier = nil
}

// SetTokenCreateID sets the "token_create_id" field.
func (m *TokenOutputMutation) SetTokenCreateID(u uuid.UUID) {
	m.token_create = &u
}

// TokenCreateID returns the value of the "token_create_id" field in the mutation.
func (m *TokenOutputMutation) TokenCreateID() (r uuid.UUID, exists bool) {
	v := m.token_create
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenCreateID returns the old "token_create_id" field's value of the TokenOutput entity.
// If the TokenOutput object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenOutputMutation) OldTokenCreateID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenCreateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenCreateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenCreateID: %w", err)
	}
	return oldValue.TokenCreateID, nil
}

// ResetTokenCreateID resets all changes to the "token_create_id" field.
func (m *TokenOutputMutation) ResetTokenCreateID() {
	m.token_create = nil
}

// SetRevocationKeyshareID sets the "revocation_keyshare" edge to the SigningKeyshare entity by id.
func (m *TokenOutputMutation) SetRevocationKeyshareID(id uuid.UUID) {
	m.revocation_keyshare = &id
}

// ClearRevocationKeyshare clears the "revocation_keyshare" edge to the SigningKeyshare entity.
func (m *TokenOutputMutation) ClearRevocationKeyshare() {
	m.clearedrevocation_keyshare = true
}

// RevocationKeyshareCleared reports if the "revocation_keyshare" edge to the SigningKeyshare entity was cleared.
func (m *TokenOutputMutation) RevocationKeyshareCleared() bool {
	return m.clearedrevocation_keyshare
}

// RevocationKeyshareID returns the "revocation_keyshare" edge ID in the mutation.
func (m *TokenOutputMutation) RevocationKeyshareID() (id uuid.UUID, exists bool) {
	if m.revocation_keyshare != nil {
		return *m.revocation_keyshare, true
	}
	return
}

// RevocationKeyshareIDs returns the "revocation_keyshare" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RevocationKeyshareID instead. It exists only for internal usage by the builders.
func (m *TokenOutputMutation) RevocationKeyshareIDs() (ids []uuid.UUID) {
	if id := m.revocation_keyshare; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRevocationKeyshare resets all changes to the "revocation_keyshare" edge.
func (m *TokenOutputMutation) ResetRevocationKeyshare() {
	m.revocation_keyshare = nil
	m.clearedrevocation_keyshare = false
}

// SetOutputCreatedTokenTransactionID sets the "output_created_token_transaction" edge to the TokenTransaction entity by id.
func (m *TokenOutputMutation) SetOutputCreatedTokenTransactionID(id uuid.UUID) {
	m.output_created_token_transaction = &id
}

// ClearOutputCreatedTokenTransaction clears the "output_created_token_transaction" edge to the TokenTransaction entity.
func (m *TokenOutputMutation) ClearOutputCreatedTokenTransaction() {
	m.clearedoutput_created_token_transaction = true
}

// OutputCreatedTokenTransactionCleared reports if the "output_created_token_transaction" edge to the TokenTransaction entity was cleared.
func (m *TokenOutputMutation) OutputCreatedTokenTransactionCleared() bool {
	return m.clearedoutput_created_token_transaction
}

// OutputCreatedTokenTransactionID returns the "output_created_token_transaction" edge ID in the mutation.
func (m *TokenOutputMutation) OutputCreatedTokenTransactionID() (id uuid.UUID, exists bool) {
	if m.output_created_token_transaction != nil {
		return *m.output_created_token_transaction, true
	}
	return
}

// OutputCreatedTokenTransactionIDs returns the "output_created_token_transaction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OutputCreatedTokenTransactionID instead. It exists only for internal usage by the builders.
func (m *TokenOutputMutation) OutputCreatedTokenTransactionIDs() (ids []uuid.UUID) {
	if id := m.output_created_token_transaction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOutputCreatedTokenTransaction resets all changes to the "output_created_token_transaction" edge.
func (m *TokenOutputMutation) ResetOutputCreatedTokenTransaction() {
	m.output_created_token_transaction = nil
	m.clearedoutput_created_token_transaction = false
}

// SetOutputSpentTokenTransactionID sets the "output_spent_token_transaction" edge to the TokenTransaction entity by id.
func (m *TokenOutputMutation) SetOutputSpentTokenTransactionID(id uuid.UUID) {
	m.output_spent_token_transaction = &id
}

// ClearOutputSpentTokenTransaction clears the "output_spent_token_transaction" edge to the TokenTransaction entity.
func (m *TokenOutputMutation) ClearOutputSpentTokenTransaction() {
	m.clearedoutput_spent_token_transaction = true
}

// OutputSpentTokenTransactionCleared reports if the "output_spent_token_transaction" edge to the TokenTransaction entity was cleared.
func (m *TokenOutputMutation) OutputSpentTokenTransactionCleared() bool {
	return m.clearedoutput_spent_token_transaction
}

// OutputSpentTokenTransactionID returns the "output_spent_token_transaction" edge ID in the mutation.
func (m *TokenOutputMutation) OutputSpentTokenTransactionID() (id uuid.UUID, exists bool) {
	if m.output_spent_token_transaction != nil {
		return *m.output_spent_token_transaction, true
	}
	return
}

// OutputSpentTokenTransactionIDs returns the "output_spent_token_transaction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OutputSpentTokenTransactionID instead. It exists only for internal usage by the builders.
func (m *TokenOutputMutation) OutputSpentTokenTransactionIDs() (ids []uuid.UUID) {
	if id := m.output_spent_token_transaction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOutputSpentTokenTransaction resets all changes to the "output_spent_token_transaction" edge.
func (m *TokenOutputMutation) ResetOutputSpentTokenTransaction() {
	m.output_spent_token_transaction = nil
	m.clearedoutput_spent_token_transaction = false
}

// AddOutputSpentStartedTokenTransactionIDs adds the "output_spent_started_token_transactions" edge to the TokenTransaction entity by ids.
func (m *TokenOutputMutation) AddOutputSpentStartedTokenTransactionIDs(ids ...uuid.UUID) {
	if m.output_spent_started_token_transactions == nil {
		m.output_spent_started_token_transactions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.output_spent_started_token_transactions[ids[i]] = struct{}{}
	}
}

// ClearOutputSpentStartedTokenTransactions clears the "output_spent_started_token_transactions" edge to the TokenTransaction entity.
func (m *TokenOutputMutation) ClearOutputSpentStartedTokenTransactions() {
	m.clearedoutput_spent_started_token_transactions = true
}

// OutputSpentStartedTokenTransactionsCleared reports if the "output_spent_started_token_transactions" edge to the TokenTransaction entity was cleared.
func (m *TokenOutputMutation) OutputSpentStartedTokenTransactionsCleared() bool {
	return m.clearedoutput_spent_started_token_transactions
}

// RemoveOutputSpentStartedTokenTransactionIDs removes the "output_spent_started_token_transactions" edge to the TokenTransaction entity by IDs.
func (m *TokenOutputMutation) RemoveOutputSpentStartedTokenTransactionIDs(ids ...uuid.UUID) {
	if m.removedoutput_spent_started_token_transactions == nil {
		m.removedoutput_spent_started_token_transactions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.output_spent_started_token_transactions, ids[i])
		m.removedoutput_spent_started_token_transactions[ids[i]] = struct{}{}
	}
}

// RemovedOutputSpentStartedTokenTransactions returns the removed IDs of the "output_spent_started_token_transactions" edge to the TokenTransaction entity.
func (m *TokenOutputMutation) RemovedOutputSpentStartedTokenTransactionsIDs() (ids []uuid.UUID) {
	for id := range m.removedoutput_spent_started_token_transactions {
		ids = append(ids, id)
	}
	return
}

// OutputSpentStartedTokenTransactionsIDs returns the "output_spent_started_token_transactions" edge IDs in the mutation.
func (m *TokenOutputMutation) OutputSpentStartedTokenTransactionsIDs() (ids []uuid.UUID) {
	for id := range m.output_spent_started_token_transactions {
		ids = append(ids, id)
	}
	return
}

// ResetOutputSpentStartedTokenTransactions resets all changes to the "output_spent_started_token_transactions" edge.
func (m *TokenOutputMutation) ResetOutputSpentStartedTokenTransactions() {
	m.output_spent_started_token_transactions = nil
	m.clearedoutput_spent_started_token_transactions = false
	m.removedoutput_spent_started_token_transactions = nil
}

// AddTokenPartialRevocationSecretShareIDs adds the "token_partial_revocation_secret_shares" edge to the TokenPartialRevocationSecretShare entity by ids.
func (m *TokenOutputMutation) AddTokenPartialRevocationSecretShareIDs(ids ...uuid.UUID) {
	if m.token_partial_revocation_secret_shares == nil {
		m.token_partial_revocation_secret_shares = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.token_partial_revocation_secret_shares[ids[i]] = struct{}{}
	}
}

// ClearTokenPartialRevocationSecretShares clears the "token_partial_revocation_secret_shares" edge to the TokenPartialRevocationSecretShare entity.
func (m *TokenOutputMutation) ClearTokenPartialRevocationSecretShares() {
	m.clearedtoken_partial_revocation_secret_shares = true
}

// TokenPartialRevocationSecretSharesCleared reports if the "token_partial_revocation_secret_shares" edge to the TokenPartialRevocationSecretShare entity was cleared.
func (m *TokenOutputMutation) TokenPartialRevocationSecretSharesCleared() bool {
	return m.clearedtoken_partial_revocation_secret_shares
}

// RemoveTokenPartialRevocationSecretShareIDs removes the "token_partial_revocation_secret_shares" edge to the TokenPartialRevocationSecretShare entity by IDs.
func (m *TokenOutputMutation) RemoveTokenPartialRevocationSecretShareIDs(ids ...uuid.UUID) {
	if m.removedtoken_partial_revocation_secret_shares == nil {
		m.removedtoken_partial_revocation_secret_shares = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.token_partial_revocation_secret_shares, ids[i])
		m.removedtoken_partial_revocation_secret_shares[ids[i]] = struct{}{}
	}
}

// RemovedTokenPartialRevocationSecretShares returns the removed IDs of the "token_partial_revocation_secret_shares" edge to the TokenPartialRevocationSecretShare entity.
func (m *TokenOutputMutation) RemovedTokenPartialRevocationSecretSharesIDs() (ids []uuid.UUID) {
	for id := range m.removedtoken_partial_revocation_secret_shares {
		ids = append(ids, id)
	}
	return
}

// TokenPartialRevocationSecretSharesIDs returns the "token_partial_revocation_secret_shares" edge IDs in the mutation.
func (m *TokenOutputMutation) TokenPartialRevocationSecretSharesIDs() (ids []uuid.UUID) {
	for id := range m.token_partial_revocation_secret_shares {
		ids = append(ids, id)
	}
	return
}

// ResetTokenPartialRevocationSecretShares resets all changes to the "token_partial_revocation_secret_shares" edge.
func (m *TokenOutputMutation) ResetTokenPartialRevocationSecretShares() {
	m.token_partial_revocation_secret_shares = nil
	m.clearedtoken_partial_revocation_secret_shares = false
	m.removedtoken_partial_revocation_secret_shares = nil
}

// ClearTokenCreate clears the "token_create" edge to the TokenCreate entity.
func (m *TokenOutputMutation) ClearTokenCreate() {
	m.clearedtoken_create = true
	m.clearedFields[tokenoutput.FieldTokenCreateID] = struct{}{}
}

// TokenCreateCleared reports if the "token_create" edge to the TokenCreate entity was cleared.
func (m *TokenOutputMutation) TokenCreateCleared() bool {
	return m.clearedtoken_create
}

// TokenCreateIDs returns the "token_create" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TokenCreateID instead. It exists only for internal usage by the builders.
func (m *TokenOutputMutation) TokenCreateIDs() (ids []uuid.UUID) {
	if id := m.token_create; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTokenCreate resets all changes to the "token_create" edge.
func (m *TokenOutputMutation) ResetTokenCreate() {
	m.token_create = nil
	m.clearedtoken_create = false
}

// Where appends a list predicates to the TokenOutputMutation builder.
func (m *TokenOutputMutation) Where(ps ...predicate.TokenOutput) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenOutputMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenOutputMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TokenOutput, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenOutputMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenOutputMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TokenOutput).
func (m *TokenOutputMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenOutputMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.create_time != nil {
		fields = append(fields, tokenoutput.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, tokenoutput.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, tokenoutput.FieldStatus)
	}
	if m.owner_public_key != nil {
		fields = append(fields, tokenoutput.FieldOwnerPublicKey)
	}
	if m.withdraw_bond_sats != nil {
		fields = append(fields, tokenoutput.FieldWithdrawBondSats)
	}
	if m.withdraw_relative_block_locktime != nil {
		fields = append(fields, tokenoutput.FieldWithdrawRelativeBlockLocktime)
	}
	if m.withdraw_revocation_commitment != nil {
		fields = append(fields, tokenoutput.FieldWithdrawRevocationCommitment)
	}
	if m.token_public_key != nil {
		fields = append(fields, tokenoutput.FieldTokenPublicKey)
	}
	if m.token_amount != nil {
		fields = append(fields, tokenoutput.FieldTokenAmount)
	}
	if m.created_transaction_output_vout != nil {
		fields = append(fields, tokenoutput.FieldCreatedTransactionOutputVout)
	}
	if m.spent_ownership_signature != nil {
		fields = append(fields, tokenoutput.FieldSpentOwnershipSignature)
	}
	if m.spent_operator_specific_ownership_signature != nil {
		fields = append(fields, tokenoutput.FieldSpentOperatorSpecificOwnershipSignature)
	}
	if m.spent_transaction_input_vout != nil {
		fields = append(fields, tokenoutput.FieldSpentTransactionInputVout)
	}
	if m.spent_revocation_secret != nil {
		fields = append(fields, tokenoutput.FieldSpentRevocationSecret)
	}
	if m.confirmed_withdraw_block_hash != nil {
		fields = append(fields, tokenoutput.FieldConfirmedWithdrawBlockHash)
	}
	if m.network != nil {
		fields = append(fields, tokenoutput.FieldNetwork)
	}
	if m.token_identifier != nil {
		fields = append(fields, tokenoutput.FieldTokenIdentifier)
	}
	if m.token_create != nil {
		fields = append(fields, tokenoutput.FieldTokenCreateID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenOutputMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tokenoutput.FieldCreateTime:
		return m.CreateTime()
	case tokenoutput.FieldUpdateTime:
		return m.UpdateTime()
	case tokenoutput.FieldStatus:
		return m.Status()
	case tokenoutput.FieldOwnerPublicKey:
		return m.OwnerPublicKey()
	case tokenoutput.FieldWithdrawBondSats:
		return m.WithdrawBondSats()
	case tokenoutput.FieldWithdrawRelativeBlockLocktime:
		return m.WithdrawRelativeBlockLocktime()
	case tokenoutput.FieldWithdrawRevocationCommitment:
		return m.WithdrawRevocationCommitment()
	case tokenoutput.FieldTokenPublicKey:
		return m.TokenPublicKey()
	case tokenoutput.FieldTokenAmount:
		return m.TokenAmount()
	case tokenoutput.FieldCreatedTransactionOutputVout:
		return m.CreatedTransactionOutputVout()
	case tokenoutput.FieldSpentOwnershipSignature:
		return m.SpentOwnershipSignature()
	case tokenoutput.FieldSpentOperatorSpecificOwnershipSignature:
		return m.SpentOperatorSpecificOwnershipSignature()
	case tokenoutput.FieldSpentTransactionInputVout:
		return m.SpentTransactionInputVout()
	case tokenoutput.FieldSpentRevocationSecret:
		return m.SpentRevocationSecret()
	case tokenoutput.FieldConfirmedWithdrawBlockHash:
		return m.ConfirmedWithdrawBlockHash()
	case tokenoutput.FieldNetwork:
		return m.Network()
	case tokenoutput.FieldTokenIdentifier:
		return m.TokenIdentifier()
	case tokenoutput.FieldTokenCreateID:
		return m.TokenCreateID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenOutputMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tokenoutput.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case tokenoutput.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case tokenoutput.FieldStatus:
		return m.OldStatus(ctx)
	case tokenoutput.FieldOwnerPublicKey:
		return m.OldOwnerPublicKey(ctx)
	case tokenoutput.FieldWithdrawBondSats:
		return m.OldWithdrawBondSats(ctx)
	case tokenoutput.FieldWithdrawRelativeBlockLocktime:
		return m.OldWithdrawRelativeBlockLocktime(ctx)
	case tokenoutput.FieldWithdrawRevocationCommitment:
		return m.OldWithdrawRevocationCommitment(ctx)
	case tokenoutput.FieldTokenPublicKey:
		return m.OldTokenPublicKey(ctx)
	case tokenoutput.FieldTokenAmount:
		return m.OldTokenAmount(ctx)
	case tokenoutput.FieldCreatedTransactionOutputVout:
		return m.OldCreatedTransactionOutputVout(ctx)
	case tokenoutput.FieldSpentOwnershipSignature:
		return m.OldSpentOwnershipSignature(ctx)
	case tokenoutput.FieldSpentOperatorSpecificOwnershipSignature:
		return m.OldSpentOperatorSpecificOwnershipSignature(ctx)
	case tokenoutput.FieldSpentTransactionInputVout:
		return m.OldSpentTransactionInputVout(ctx)
	case tokenoutput.FieldSpentRevocationSecret:
		return m.OldSpentRevocationSecret(ctx)
	case tokenoutput.FieldConfirmedWithdrawBlockHash:
		return m.OldConfirmedWithdrawBlockHash(ctx)
	case tokenoutput.FieldNetwork:
		return m.OldNetwork(ctx)
	case tokenoutput.FieldTokenIdentifier:
		return m.OldTokenIdentifier(ctx)
	case tokenoutput.FieldTokenCreateID:
		return m.OldTokenCreateID(ctx)
	}
	return nil, fmt.Errorf("unknown TokenOutput field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenOutputMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tokenoutput.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case tokenoutput.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case tokenoutput.FieldStatus:
		v, ok := value.(schematype.TokenOutputStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tokenoutput.FieldOwnerPublicKey:
		v, ok := value.(keys.Public)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerPublicKey(v)
		return nil
	case tokenoutput.FieldWithdrawBondSats:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithdrawBondSats(v)
		return nil
	case tokenoutput.FieldWithdrawRelativeBlockLocktime:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithdrawRelativeBlockLocktime(v)
		return nil
	case tokenoutput.FieldWithdrawRevocationCommitment:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithdrawRevocationCommitment(v)
		return nil
	case tokenoutput.FieldTokenPublicKey:
		v, ok := value.(keys.Public)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenPublicKey(v)
		return nil
	case tokenoutput.FieldTokenAmount:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenAmount(v)
		return nil
	case tokenoutput.FieldCreatedTransactionOutputVout:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTransactionOutputVout(v)
		return nil
	case tokenoutput.FieldSpentOwnershipSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpentOwnershipSignature(v)
		return nil
	case tokenoutput.FieldSpentOperatorSpecificOwnershipSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpentOperatorSpecificOwnershipSignature(v)
		return nil
	case tokenoutput.FieldSpentTransactionInputVout:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpentTransactionInputVout(v)
		return nil
	case tokenoutput.FieldSpentRevocationSecret:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpentRevocationSecret(v)
		return nil
	case tokenoutput.FieldConfirmedWithdrawBlockHash:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfirmedWithdrawBlockHash(v)
		return nil
	case tokenoutput.FieldNetwork:
		v, ok := value.(schematype.Network)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetwork(v)
		return nil
	case tokenoutput.FieldTokenIdentifier:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenIdentifier(v)
		return nil
	case tokenoutput.FieldTokenCreateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenCreateID(v)
		return nil
	}
	return fmt.Errorf("unknown TokenOutput field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenOutputMutation) AddedFields() []string {
	var fields []string
	if m.addwithdraw_bond_sats != nil {
		fields = append(fields, tokenoutput.FieldWithdrawBondSats)
	}
	if m.addwithdraw_relative_block_locktime != nil {
		fields = append(fields, tokenoutput.FieldWithdrawRelativeBlockLocktime)
	}
	if m.addcreated_transaction_output_vout != nil {
		fields = append(fields, tokenoutput.FieldCreatedTransactionOutputVout)
	}
	if m.addspent_transaction_input_vout != nil {
		fields = append(fields, tokenoutput.FieldSpentTransactionInputVout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenOutputMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tokenoutput.FieldWithdrawBondSats:
		return m.AddedWithdrawBondSats()
	case tokenoutput.FieldWithdrawRelativeBlockLocktime:
		return m.AddedWithdrawRelativeBlockLocktime()
	case tokenoutput.FieldCreatedTransactionOutputVout:
		return m.AddedCreatedTransactionOutputVout()
	case tokenoutput.FieldSpentTransactionInputVout:
		return m.AddedSpentTransactionInputVout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenOutputMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tokenoutput.FieldWithdrawBondSats:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWithdrawBondSats(v)
		return nil
	case tokenoutput.FieldWithdrawRelativeBlockLocktime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWithdrawRelativeBlockLocktime(v)
		return nil
	case tokenoutput.FieldCreatedTransactionOutputVout:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedTransactionOutputVout(v)
		return nil
	case tokenoutput.FieldSpentTransactionInputVout:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpentTransactionInputVout(v)
		return nil
	}
	return fmt.Errorf("unknown TokenOutput numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenOutputMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tokenoutput.FieldTokenPublicKey) {
		fields = append(fields, tokenoutput.FieldTokenPublicKey)
	}
	if m.FieldCleared(tokenoutput.FieldSpentOwnershipSignature) {
		fields = append(fields, tokenoutput.FieldSpentOwnershipSignature)
	}
	if m.FieldCleared(tokenoutput.FieldSpentOperatorSpecificOwnershipSignature) {
		fields = append(fields, tokenoutput.FieldSpentOperatorSpecificOwnershipSignature)
	}
	if m.FieldCleared(tokenoutput.FieldSpentTransactionInputVout) {
		fields = append(fields, tokenoutput.FieldSpentTransactionInputVout)
	}
	if m.FieldCleared(tokenoutput.FieldSpentRevocationSecret) {
		fields = append(fields, tokenoutput.FieldSpentRevocationSecret)
	}
	if m.FieldCleared(tokenoutput.FieldConfirmedWithdrawBlockHash) {
		fields = append(fields, tokenoutput.FieldConfirmedWithdrawBlockHash)
	}
	if m.FieldCleared(tokenoutput.FieldNetwork) {
		fields = append(fields, tokenoutput.FieldNetwork)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenOutputMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenOutputMutation) ClearField(name string) error {
	switch name {
	case tokenoutput.FieldTokenPublicKey:
		m.ClearTokenPublicKey()
		return nil
	case tokenoutput.FieldSpentOwnershipSignature:
		m.ClearSpentOwnershipSignature()
		return nil
	case tokenoutput.FieldSpentOperatorSpecificOwnershipSignature:
		m.ClearSpentOperatorSpecificOwnershipSignature()
		return nil
	case tokenoutput.FieldSpentTransactionInputVout:
		m.ClearSpentTransactionInputVout()
		return nil
	case tokenoutput.FieldSpentRevocationSecret:
		m.ClearSpentRevocationSecret()
		return nil
	case tokenoutput.FieldConfirmedWithdrawBlockHash:
		m.ClearConfirmedWithdrawBlockHash()
		return nil
	case tokenoutput.FieldNetwork:
		m.ClearNetwork()
		return nil
	}
	return fmt.Errorf("unknown TokenOutput nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenOutputMutation) ResetField(name string) error {
	switch name {
	case tokenoutput.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case tokenoutput.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case tokenoutput.FieldStatus:
		m.ResetStatus()
		return nil
	case tokenoutput.FieldOwnerPublicKey:
		m.ResetOwnerPublicKey()
		return nil
	case tokenoutput.FieldWithdrawBondSats:
		m.ResetWithdrawBondSats()
		return nil
	case tokenoutput.FieldWithdrawRelativeBlockLocktime:
		m.ResetWithdrawRelativeBlockLocktime()
		return nil
	case tokenoutput.FieldWithdrawRevocationCommitment:
		m.ResetWithdrawRevocationCommitment()
		return nil
	case tokenoutput.FieldTokenPublicKey:
		m.ResetTokenPublicKey()
		return nil
	case tokenoutput.FieldTokenAmount:
		m.ResetTokenAmount()
		return nil
	case tokenoutput.FieldCreatedTransactionOutputVout:
		m.ResetCreatedTransactionOutputVout()
		return nil
	case tokenoutput.FieldSpentOwnershipSignature:
		m.ResetSpentOwnershipSignature()
		return nil
	case tokenoutput.FieldSpentOperatorSpecificOwnershipSignature:
		m.ResetSpentOperatorSpecificOwnershipSignature()
		return nil
	case tokenoutput.FieldSpentTransactionInputVout:
		m.ResetSpentTransactionInputVout()
		return nil
	case tokenoutput.FieldSpentRevocationSecret:
		m.ResetSpentRevocationSecret()
		return nil
	case tokenoutput.FieldConfirmedWithdrawBlockHash:
		m.ResetConfirmedWithdrawBlockHash()
		return nil
	case tokenoutput.FieldNetwork:
		m.ResetNetwork()
		return nil
	case tokenoutput.FieldTokenIdentifier:
		m.ResetTokenIdentifier()
		return nil
	case tokenoutput.FieldTokenCreateID:
		m.ResetTokenCreateID()
		return nil
	}
	return fmt.Errorf("unknown TokenOutput field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenOutputMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.revocation_keyshare != nil {
		edges = append(edges, tokenoutput.EdgeRevocationKeyshare)
	}
	if m.output_created_token_transaction != nil {
		edges = append(edges, tokenoutput.EdgeOutputCreatedTokenTransaction)
	}
	if m.output_spent_token_transaction != nil {
		edges = append(edges, tokenoutput.EdgeOutputSpentTokenTransaction)
	}
	if m.output_spent_started_token_transactions != nil {
		edges = append(edges, tokenoutput.EdgeOutputSpentStartedTokenTransactions)
	}
	if m.token_partial_revocation_secret_shares != nil {
		edges = append(edges, tokenoutput.EdgeTokenPartialRevocationSecretShares)
	}
	if m.token_create != nil {
		edges = append(edges, tokenoutput.EdgeTokenCreate)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenOutputMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tokenoutput.EdgeRevocationKeyshare:
		if id := m.revocation_keyshare; id != nil {
			return []ent.Value{*id}
		}
	case tokenoutput.EdgeOutputCreatedTokenTransaction:
		if id := m.output_created_token_transaction; id != nil {
			return []ent.Value{*id}
		}
	case tokenoutput.EdgeOutputSpentTokenTransaction:
		if id := m.output_spent_token_transaction; id != nil {
			return []ent.Value{*id}
		}
	case tokenoutput.EdgeOutputSpentStartedTokenTransactions:
		ids := make([]ent.Value, 0, len(m.output_spent_started_token_transactions))
		for id := range m.output_spent_started_token_transactions {
			ids = append(ids, id)
		}
		return ids
	case tokenoutput.EdgeTokenPartialRevocationSecretShares:
		ids := make([]ent.Value, 0, len(m.token_partial_revocation_secret_shares))
		for id := range m.token_partial_revocation_secret_shares {
			ids = append(ids, id)
		}
		return ids
	case tokenoutput.EdgeTokenCreate:
		if id := m.token_create; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenOutputMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedoutput_spent_started_token_transactions != nil {
		edges = append(edges, tokenoutput.EdgeOutputSpentStartedTokenTransactions)
	}
	if m.removedtoken_partial_revocation_secret_shares != nil {
		edges = append(edges, tokenoutput.EdgeTokenPartialRevocationSecretShares)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenOutputMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tokenoutput.EdgeOutputSpentStartedTokenTransactions:
		ids := make([]ent.Value, 0, len(m.removedoutput_spent_started_token_transactions))
		for id := range m.removedoutput_spent_started_token_transactions {
			ids = append(ids, id)
		}
		return ids
	case tokenoutput.EdgeTokenPartialRevocationSecretShares:
		ids := make([]ent.Value, 0, len(m.removedtoken_partial_revocation_secret_shares))
		for id := range m.removedtoken_partial_revocation_secret_shares {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenOutputMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedrevocation_keyshare {
		edges = append(edges, tokenoutput.EdgeRevocationKeyshare)
	}
	if m.clearedoutput_created_token_transaction {
		edges = append(edges, tokenoutput.EdgeOutputCreatedTokenTransaction)
	}
	if m.clearedoutput_spent_token_transaction {
		edges = append(edges, tokenoutput.EdgeOutputSpentTokenTransaction)
	}
	if m.clearedoutput_spent_started_token_transactions {
		edges = append(edges, tokenoutput.EdgeOutputSpentStartedTokenTransactions)
	}
	if m.clearedtoken_partial_revocation_secret_shares {
		edges = append(edges, tokenoutput.EdgeTokenPartialRevocationSecretShares)
	}
	if m.clearedtoken_create {
		edges = append(edges, tokenoutput.EdgeTokenCreate)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenOutputMutation) EdgeCleared(name string) bool {
	switch name {
	case tokenoutput.EdgeRevocationKeyshare:
		return m.clearedrevocation_keyshare
	case tokenoutput.EdgeOutputCreatedTokenTransaction:
		return m.clearedoutput_created_token_transaction
	case tokenoutput.EdgeOutputSpentTokenTransaction:
		return m.clearedoutput_spent_token_transaction
	case tokenoutput.EdgeOutputSpentStartedTokenTransactions:
		return m.clearedoutput_spent_started_token_transactions
	case tokenoutput.EdgeTokenPartialRevocationSecretShares:
		return m.clearedtoken_partial_revocation_secret_shares
	case tokenoutput.EdgeTokenCreate:
		return m.clearedtoken_create
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenOutputMutation) ClearEdge(name string) error {
	switch name {
	case tokenoutput.EdgeRevocationKeyshare:
		m.ClearRevocationKeyshare()
		return nil
	case tokenoutput.EdgeOutputCreatedTokenTransaction:
		m.ClearOutputCreatedTokenTransaction()
		return nil
	case tokenoutput.EdgeOutputSpentTokenTransaction:
		m.ClearOutputSpentTokenTransaction()
		return nil
	case tokenoutput.EdgeTokenCreate:
		m.ClearTokenCreate()
		return nil
	}
	return fmt.Errorf("unknown TokenOutput unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenOutputMutation) ResetEdge(name string) error {
	switch name {
	case tokenoutput.EdgeRevocationKeyshare:
		m.ResetRevocationKeyshare()
		return nil
	case tokenoutput.EdgeOutputCreatedTokenTransaction:
		m.ResetOutputCreatedTokenTransaction()
		return nil
	case tokenoutput.EdgeOutputSpentTokenTransaction:
		m.ResetOutputSpentTokenTransaction()
		return nil
	case tokenoutput.EdgeOutputSpentStartedTokenTransactions:
		m.ResetOutputSpentStartedTokenTransactions()
		return nil
	case tokenoutput.EdgeTokenPartialRevocationSecretShares:
		m.ResetTokenPartialRevocationSecretShares()
		return nil
	case tokenoutput.EdgeTokenCreate:
		m.ResetTokenCreate()
		return nil
	}
	return fmt.Errorf("unknown TokenOutput edge %s", name)
}

// TokenPartialRevocationSecretShareMutation represents an operation that mutates the TokenPartialRevocationSecretShare nodes in the graph.
type TokenPartialRevocationSecretShareMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	create_time                  *time.Time
	update_time                  *time.Time
	operator_identity_public_key *keys.Public
	secret_share                 *[]byte
	clearedFields                map[string]struct{}
	token_output                 *uuid.UUID
	clearedtoken_output          bool
	done                         bool
	oldValue                     func(context.Context) (*TokenPartialRevocationSecretShare, error)
	predicates                   []predicate.TokenPartialRevocationSecretShare
}

var _ ent.Mutation = (*TokenPartialRevocationSecretShareMutation)(nil)

// tokenpartialrevocationsecretshareOption allows management of the mutation configuration using functional options.
type tokenpartialrevocationsecretshareOption func(*TokenPartialRevocationSecretShareMutation)

// newTokenPartialRevocationSecretShareMutation creates new mutation for the TokenPartialRevocationSecretShare entity.
func newTokenPartialRevocationSecretShareMutation(c config, op Op, opts ...tokenpartialrevocationsecretshareOption) *TokenPartialRevocationSecretShareMutation {
	m := &TokenPartialRevocationSecretShareMutation{
		config:        c,
		op:            op,
		typ:           TypeTokenPartialRevocationSecretShare,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenPartialRevocationSecretShareID sets the ID field of the mutation.
func withTokenPartialRevocationSecretShareID(id uuid.UUID) tokenpartialrevocationsecretshareOption {
	return func(m *TokenPartialRevocationSecretShareMutation) {
		var (
			err   error
			once  sync.Once
			value *TokenPartialRevocationSecretShare
		)
		m.oldValue = func(ctx context.Context) (*TokenPartialRevocationSecretShare, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TokenPartialRevocationSecretShare.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTokenPartialRevocationSecretShare sets the old TokenPartialRevocationSecretShare of the mutation.
func withTokenPartialRevocationSecretShare(node *TokenPartialRevocationSecretShare) tokenpartialrevocationsecretshareOption {
	return func(m *TokenPartialRevocationSecretShareMutation) {
		m.oldValue = func(context.Context) (*TokenPartialRevocationSecretShare, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenPartialRevocationSecretShareMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenPartialRevocationSecretShareMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TokenPartialRevocationSecretShare entities.
func (m *TokenPartialRevocationSecretShareMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenPartialRevocationSecretShareMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenPartialRevocationSecretShareMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TokenPartialRevocationSecretShare.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TokenPartialRevocationSecretShareMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TokenPartialRevocationSecretShareMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TokenPartialRevocationSecretShare entity.
// If the TokenPartialRevocationSecretShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenPartialRevocationSecretShareMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TokenPartialRevocationSecretShareMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TokenPartialRevocationSecretShareMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TokenPartialRevocationSecretShareMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TokenPartialRevocationSecretShare entity.
// If the TokenPartialRevocationSecretShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenPartialRevocationSecretShareMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TokenPartialRevocationSecretShareMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetOperatorIdentityPublicKey sets the "operator_identity_public_key" field.
func (m *TokenPartialRevocationSecretShareMutation) SetOperatorIdentityPublicKey(k keys.Public) {
	m.operator_identity_public_key = &k
}

// OperatorIdentityPublicKey returns the value of the "operator_identity_public_key" field in the mutation.
func (m *TokenPartialRevocationSecretShareMutation) OperatorIdentityPublicKey() (r keys.Public, exists bool) {
	v := m.operator_identity_public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorIdentityPublicKey returns the old "operator_identity_public_key" field's value of the TokenPartialRevocationSecretShare entity.
// If the TokenPartialRevocationSecretShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenPartialRevocationSecretShareMutation) OldOperatorIdentityPublicKey(ctx context.Context) (v keys.Public, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorIdentityPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorIdentityPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorIdentityPublicKey: %w", err)
	}
	return oldValue.OperatorIdentityPublicKey, nil
}

// ResetOperatorIdentityPublicKey resets all changes to the "operator_identity_public_key" field.
func (m *TokenPartialRevocationSecretShareMutation) ResetOperatorIdentityPublicKey() {
	m.operator_identity_public_key = nil
}

// SetSecretShare sets the "secret_share" field.
func (m *TokenPartialRevocationSecretShareMutation) SetSecretShare(b []byte) {
	m.secret_share = &b
}

// SecretShare returns the value of the "secret_share" field in the mutation.
func (m *TokenPartialRevocationSecretShareMutation) SecretShare() (r []byte, exists bool) {
	v := m.secret_share
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretShare returns the old "secret_share" field's value of the TokenPartialRevocationSecretShare entity.
// If the TokenPartialRevocationSecretShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenPartialRevocationSecretShareMutation) OldSecretShare(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretShare is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretShare requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretShare: %w", err)
	}
	return oldValue.SecretShare, nil
}

// ResetSecretShare resets all changes to the "secret_share" field.
func (m *TokenPartialRevocationSecretShareMutation) ResetSecretShare() {
	m.secret_share = nil
}

// SetTokenOutputID sets the "token_output" edge to the TokenOutput entity by id.
func (m *TokenPartialRevocationSecretShareMutation) SetTokenOutputID(id uuid.UUID) {
	m.token_output = &id
}

// ClearTokenOutput clears the "token_output" edge to the TokenOutput entity.
func (m *TokenPartialRevocationSecretShareMutation) ClearTokenOutput() {
	m.clearedtoken_output = true
}

// TokenOutputCleared reports if the "token_output" edge to the TokenOutput entity was cleared.
func (m *TokenPartialRevocationSecretShareMutation) TokenOutputCleared() bool {
	return m.clearedtoken_output
}

// TokenOutputID returns the "token_output" edge ID in the mutation.
func (m *TokenPartialRevocationSecretShareMutation) TokenOutputID() (id uuid.UUID, exists bool) {
	if m.token_output != nil {
		return *m.token_output, true
	}
	return
}

// TokenOutputIDs returns the "token_output" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TokenOutputID instead. It exists only for internal usage by the builders.
func (m *TokenPartialRevocationSecretShareMutation) TokenOutputIDs() (ids []uuid.UUID) {
	if id := m.token_output; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTokenOutput resets all changes to the "token_output" edge.
func (m *TokenPartialRevocationSecretShareMutation) ResetTokenOutput() {
	m.token_output = nil
	m.clearedtoken_output = false
}

// Where appends a list predicates to the TokenPartialRevocationSecretShareMutation builder.
func (m *TokenPartialRevocationSecretShareMutation) Where(ps ...predicate.TokenPartialRevocationSecretShare) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenPartialRevocationSecretShareMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenPartialRevocationSecretShareMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TokenPartialRevocationSecretShare, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenPartialRevocationSecretShareMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenPartialRevocationSecretShareMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TokenPartialRevocationSecretShare).
func (m *TokenPartialRevocationSecretShareMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenPartialRevocationSecretShareMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, tokenpartialrevocationsecretshare.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, tokenpartialrevocationsecretshare.FieldUpdateTime)
	}
	if m.operator_identity_public_key != nil {
		fields = append(fields, tokenpartialrevocationsecretshare.FieldOperatorIdentityPublicKey)
	}
	if m.secret_share != nil {
		fields = append(fields, tokenpartialrevocationsecretshare.FieldSecretShare)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenPartialRevocationSecretShareMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tokenpartialrevocationsecretshare.FieldCreateTime:
		return m.CreateTime()
	case tokenpartialrevocationsecretshare.FieldUpdateTime:
		return m.UpdateTime()
	case tokenpartialrevocationsecretshare.FieldOperatorIdentityPublicKey:
		return m.OperatorIdentityPublicKey()
	case tokenpartialrevocationsecretshare.FieldSecretShare:
		return m.SecretShare()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenPartialRevocationSecretShareMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tokenpartialrevocationsecretshare.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case tokenpartialrevocationsecretshare.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case tokenpartialrevocationsecretshare.FieldOperatorIdentityPublicKey:
		return m.OldOperatorIdentityPublicKey(ctx)
	case tokenpartialrevocationsecretshare.FieldSecretShare:
		return m.OldSecretShare(ctx)
	}
	return nil, fmt.Errorf("unknown TokenPartialRevocationSecretShare field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenPartialRevocationSecretShareMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tokenpartialrevocationsecretshare.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case tokenpartialrevocationsecretshare.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case tokenpartialrevocationsecretshare.FieldOperatorIdentityPublicKey:
		v, ok := value.(keys.Public)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorIdentityPublicKey(v)
		return nil
	case tokenpartialrevocationsecretshare.FieldSecretShare:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretShare(v)
		return nil
	}
	return fmt.Errorf("unknown TokenPartialRevocationSecretShare field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenPartialRevocationSecretShareMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenPartialRevocationSecretShareMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenPartialRevocationSecretShareMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TokenPartialRevocationSecretShare numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenPartialRevocationSecretShareMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenPartialRevocationSecretShareMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenPartialRevocationSecretShareMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TokenPartialRevocationSecretShare nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenPartialRevocationSecretShareMutation) ResetField(name string) error {
	switch name {
	case tokenpartialrevocationsecretshare.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case tokenpartialrevocationsecretshare.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case tokenpartialrevocationsecretshare.FieldOperatorIdentityPublicKey:
		m.ResetOperatorIdentityPublicKey()
		return nil
	case tokenpartialrevocationsecretshare.FieldSecretShare:
		m.ResetSecretShare()
		return nil
	}
	return fmt.Errorf("unknown TokenPartialRevocationSecretShare field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenPartialRevocationSecretShareMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.token_output != nil {
		edges = append(edges, tokenpartialrevocationsecretshare.EdgeTokenOutput)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenPartialRevocationSecretShareMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tokenpartialrevocationsecretshare.EdgeTokenOutput:
		if id := m.token_output; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenPartialRevocationSecretShareMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenPartialRevocationSecretShareMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenPartialRevocationSecretShareMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtoken_output {
		edges = append(edges, tokenpartialrevocationsecretshare.EdgeTokenOutput)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenPartialRevocationSecretShareMutation) EdgeCleared(name string) bool {
	switch name {
	case tokenpartialrevocationsecretshare.EdgeTokenOutput:
		return m.clearedtoken_output
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenPartialRevocationSecretShareMutation) ClearEdge(name string) error {
	switch name {
	case tokenpartialrevocationsecretshare.EdgeTokenOutput:
		m.ClearTokenOutput()
		return nil
	}
	return fmt.Errorf("unknown TokenPartialRevocationSecretShare unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenPartialRevocationSecretShareMutation) ResetEdge(name string) error {
	switch name {
	case tokenpartialrevocationsecretshare.EdgeTokenOutput:
		m.ResetTokenOutput()
		return nil
	}
	return fmt.Errorf("unknown TokenPartialRevocationSecretShare edge %s", name)
}

// TokenTransactionMutation represents an operation that mutates the TokenTransaction nodes in the graph.
type TokenTransactionMutation struct {
	config
	op                               Op
	typ                              string
	id                               *uuid.UUID
	create_time                      *time.Time
	update_time                      *time.Time
	partial_token_transaction_hash   *[]byte
	finalized_token_transaction_hash *[]byte
	operator_signature               *[]byte
	status                           *schematype.TokenTransactionStatus
	expiry_time                      *time.Time
	coordinator_public_key           *keys.Public
	client_created_timestamp         *time.Time
	version                          *schematype.TokenTransactionVersion
	addversion                       *schematype.TokenTransactionVersion
	clearedFields                    map[string]struct{}
	spent_output                     map[uuid.UUID]struct{}
	removedspent_output              map[uuid.UUID]struct{}
	clearedspent_output              bool
	spent_output_v2                  map[uuid.UUID]struct{}
	removedspent_output_v2           map[uuid.UUID]struct{}
	clearedspent_output_v2           bool
	created_output                   map[uuid.UUID]struct{}
	removedcreated_output            map[uuid.UUID]struct{}
	clearedcreated_output            bool
	mint                             *uuid.UUID
	clearedmint                      bool
	create                           *uuid.UUID
	clearedcreate                    bool
	payment_intent                   *uuid.UUID
	clearedpayment_intent            bool
	peer_signatures                  map[uuid.UUID]struct{}
	removedpeer_signatures           map[uuid.UUID]struct{}
	clearedpeer_signatures           bool
	spark_invoice                    map[uuid.UUID]struct{}
	removedspark_invoice             map[uuid.UUID]struct{}
	clearedspark_invoice             bool
	done                             bool
	oldValue                         func(context.Context) (*TokenTransaction, error)
	predicates                       []predicate.TokenTransaction
}

var _ ent.Mutation = (*TokenTransactionMutation)(nil)

// tokentransactionOption allows management of the mutation configuration using functional options.
type tokentransactionOption func(*TokenTransactionMutation)

// newTokenTransactionMutation creates new mutation for the TokenTransaction entity.
func newTokenTransactionMutation(c config, op Op, opts ...tokentransactionOption) *TokenTransactionMutation {
	m := &TokenTransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTokenTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenTransactionID sets the ID field of the mutation.
func withTokenTransactionID(id uuid.UUID) tokentransactionOption {
	return func(m *TokenTransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *TokenTransaction
		)
		m.oldValue = func(ctx context.Context) (*TokenTransaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TokenTransaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTokenTransaction sets the old TokenTransaction of the mutation.
func withTokenTransaction(node *TokenTransaction) tokentransactionOption {
	return func(m *TokenTransactionMutation) {
		m.oldValue = func(context.Context) (*TokenTransaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenTransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenTransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TokenTransaction entities.
func (m *TokenTransactionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenTransactionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenTransactionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TokenTransaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TokenTransactionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TokenTransactionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TokenTransaction entity.
// If the TokenTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenTransactionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TokenTransactionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TokenTransactionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TokenTransactionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TokenTransaction entity.
// If the TokenTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenTransactionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TokenTransactionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPartialTokenTransactionHash sets the "partial_token_transaction_hash" field.
func (m *TokenTransactionMutation) SetPartialTokenTransactionHash(b []byte) {
	m.partial_token_transaction_hash = &b
}

// PartialTokenTransactionHash returns the value of the "partial_token_transaction_hash" field in the mutation.
func (m *TokenTransactionMutation) PartialTokenTransactionHash() (r []byte, exists bool) {
	v := m.partial_token_transaction_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPartialTokenTransactionHash returns the old "partial_token_transaction_hash" field's value of the TokenTransaction entity.
// If the TokenTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenTransactionMutation) OldPartialTokenTransactionHash(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPartialTokenTransactionHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPartialTokenTransactionHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPartialTokenTransactionHash: %w", err)
	}
	return oldValue.PartialTokenTransactionHash, nil
}

// ResetPartialTokenTransactionHash resets all changes to the "partial_token_transaction_hash" field.
func (m *TokenTransactionMutation) ResetPartialTokenTransactionHash() {
	m.partial_token_transaction_hash = nil
}

// SetFinalizedTokenTransactionHash sets the "finalized_token_transaction_hash" field.
func (m *TokenTransactionMutation) SetFinalizedTokenTransactionHash(b []byte) {
	m.finalized_token_transaction_hash = &b
}

// FinalizedTokenTransactionHash returns the value of the "finalized_token_transaction_hash" field in the mutation.
func (m *TokenTransactionMutation) FinalizedTokenTransactionHash() (r []byte, exists bool) {
	v := m.finalized_token_transaction_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldFinalizedTokenTransactionHash returns the old "finalized_token_transaction_hash" field's value of the TokenTransaction entity.
// If the TokenTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenTransactionMutation) OldFinalizedTokenTransactionHash(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinalizedTokenTransactionHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinalizedTokenTransactionHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinalizedTokenTransactionHash: %w", err)
	}
	return oldValue.FinalizedTokenTransactionHash, nil
}

// ResetFinalizedTokenTransactionHash resets all changes to the "finalized_token_transaction_hash" field.
func (m *TokenTransactionMutation) ResetFinalizedTokenTransactionHash() {
	m.finalized_token_transaction_hash = nil
}

// SetOperatorSignature sets the "operator_signature" field.
func (m *TokenTransactionMutation) SetOperatorSignature(b []byte) {
	m.operator_signature = &b
}

// OperatorSignature returns the value of the "operator_signature" field in the mutation.
func (m *TokenTransactionMutation) OperatorSignature() (r []byte, exists bool) {
	v := m.operator_signature
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorSignature returns the old "operator_signature" field's value of the TokenTransaction entity.
// If the TokenTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenTransactionMutation) OldOperatorSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorSignature: %w", err)
	}
	return oldValue.OperatorSignature, nil
}

// ClearOperatorSignature clears the value of the "operator_signature" field.
func (m *TokenTransactionMutation) ClearOperatorSignature() {
	m.operator_signature = nil
	m.clearedFields[tokentransaction.FieldOperatorSignature] = struct{}{}
}

// OperatorSignatureCleared returns if the "operator_signature" field was cleared in this mutation.
func (m *TokenTransactionMutation) OperatorSignatureCleared() bool {
	_, ok := m.clearedFields[tokentransaction.FieldOperatorSignature]
	return ok
}

// ResetOperatorSignature resets all changes to the "operator_signature" field.
func (m *TokenTransactionMutation) ResetOperatorSignature() {
	m.operator_signature = nil
	delete(m.clearedFields, tokentransaction.FieldOperatorSignature)
}

// SetStatus sets the "status" field.
func (m *TokenTransactionMutation) SetStatus(sts schematype.TokenTransactionStatus) {
	m.status = &sts
}

// Status returns the value of the "status" field in the mutation.
func (m *TokenTransactionMutation) Status() (r schematype.TokenTransactionStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TokenTransaction entity.
// If the TokenTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenTransactionMutation) OldStatus(ctx context.Context) (v schematype.TokenTransactionStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *TokenTransactionMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[tokentransaction.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *TokenTransactionMutation) StatusCleared() bool {
	_, ok := m.clearedFields[tokentransaction.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *TokenTransactionMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, tokentransaction.FieldStatus)
}

// SetExpiryTime sets the "expiry_time" field.
func (m *TokenTransactionMutation) SetExpiryTime(t time.Time) {
	m.expiry_time = &t
}

// ExpiryTime returns the value of the "expiry_time" field in the mutation.
func (m *TokenTransactionMutation) ExpiryTime() (r time.Time, exists bool) {
	v := m.expiry_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiryTime returns the old "expiry_time" field's value of the TokenTransaction entity.
// If the TokenTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenTransactionMutation) OldExpiryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiryTime: %w", err)
	}
	return oldValue.ExpiryTime, nil
}

// ClearExpiryTime clears the value of the "expiry_time" field.
func (m *TokenTransactionMutation) ClearExpiryTime() {
	m.expiry_time = nil
	m.clearedFields[tokentransaction.FieldExpiryTime] = struct{}{}
}

// ExpiryTimeCleared returns if the "expiry_time" field was cleared in this mutation.
func (m *TokenTransactionMutation) ExpiryTimeCleared() bool {
	_, ok := m.clearedFields[tokentransaction.FieldExpiryTime]
	return ok
}

// ResetExpiryTime resets all changes to the "expiry_time" field.
func (m *TokenTransactionMutation) ResetExpiryTime() {
	m.expiry_time = nil
	delete(m.clearedFields, tokentransaction.FieldExpiryTime)
}

// SetCoordinatorPublicKey sets the "coordinator_public_key" field.
func (m *TokenTransactionMutation) SetCoordinatorPublicKey(k keys.Public) {
	m.coordinator_public_key = &k
}

// CoordinatorPublicKey returns the value of the "coordinator_public_key" field in the mutation.
func (m *TokenTransactionMutation) CoordinatorPublicKey() (r keys.Public, exists bool) {
	v := m.coordinator_public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldCoordinatorPublicKey returns the old "coordinator_public_key" field's value of the TokenTransaction entity.
// If the TokenTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenTransactionMutation) OldCoordinatorPublicKey(ctx context.Context) (v keys.Public, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoordinatorPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoordinatorPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoordinatorPublicKey: %w", err)
	}
	return oldValue.CoordinatorPublicKey, nil
}

// ClearCoordinatorPublicKey clears the value of the "coordinator_public_key" field.
func (m *TokenTransactionMutation) ClearCoordinatorPublicKey() {
	m.coordinator_public_key = nil
	m.clearedFields[tokentransaction.FieldCoordinatorPublicKey] = struct{}{}
}

// CoordinatorPublicKeyCleared returns if the "coordinator_public_key" field was cleared in this mutation.
func (m *TokenTransactionMutation) CoordinatorPublicKeyCleared() bool {
	_, ok := m.clearedFields[tokentransaction.FieldCoordinatorPublicKey]
	return ok
}

// ResetCoordinatorPublicKey resets all changes to the "coordinator_public_key" field.
func (m *TokenTransactionMutation) ResetCoordinatorPublicKey() {
	m.coordinator_public_key = nil
	delete(m.clearedFields, tokentransaction.FieldCoordinatorPublicKey)
}

// SetClientCreatedTimestamp sets the "client_created_timestamp" field.
func (m *TokenTransactionMutation) SetClientCreatedTimestamp(t time.Time) {
	m.client_created_timestamp = &t
}

// ClientCreatedTimestamp returns the value of the "client_created_timestamp" field in the mutation.
func (m *TokenTransactionMutation) ClientCreatedTimestamp() (r time.Time, exists bool) {
	v := m.client_created_timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldClientCreatedTimestamp returns the old "client_created_timestamp" field's value of the TokenTransaction entity.
// If the TokenTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenTransactionMutation) OldClientCreatedTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientCreatedTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientCreatedTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientCreatedTimestamp: %w", err)
	}
	return oldValue.ClientCreatedTimestamp, nil
}

// ClearClientCreatedTimestamp clears the value of the "client_created_timestamp" field.
func (m *TokenTransactionMutation) ClearClientCreatedTimestamp() {
	m.client_created_timestamp = nil
	m.clearedFields[tokentransaction.FieldClientCreatedTimestamp] = struct{}{}
}

// ClientCreatedTimestampCleared returns if the "client_created_timestamp" field was cleared in this mutation.
func (m *TokenTransactionMutation) ClientCreatedTimestampCleared() bool {
	_, ok := m.clearedFields[tokentransaction.FieldClientCreatedTimestamp]
	return ok
}

// ResetClientCreatedTimestamp resets all changes to the "client_created_timestamp" field.
func (m *TokenTransactionMutation) ResetClientCreatedTimestamp() {
	m.client_created_timestamp = nil
	delete(m.clearedFields, tokentransaction.FieldClientCreatedTimestamp)
}

// SetVersion sets the "version" field.
func (m *TokenTransactionMutation) SetVersion(stv schematype.TokenTransactionVersion) {
	m.version = &stv
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *TokenTransactionMutation) Version() (r schematype.TokenTransactionVersion, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the TokenTransaction entity.
// If the TokenTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenTransactionMutation) OldVersion(ctx context.Context) (v schematype.TokenTransactionVersion, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds stv to the "version" field.
func (m *TokenTransactionMutation) AddVersion(stv schematype.TokenTransactionVersion) {
	if m.addversion != nil {
		*m.addversion += stv
	} else {
		m.addversion = &stv
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *TokenTransactionMutation) AddedVersion() (r schematype.TokenTransactionVersion, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *TokenTransactionMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// AddSpentOutputIDs adds the "spent_output" edge to the TokenOutput entity by ids.
func (m *TokenTransactionMutation) AddSpentOutputIDs(ids ...uuid.UUID) {
	if m.spent_output == nil {
		m.spent_output = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.spent_output[ids[i]] = struct{}{}
	}
}

// ClearSpentOutput clears the "spent_output" edge to the TokenOutput entity.
func (m *TokenTransactionMutation) ClearSpentOutput() {
	m.clearedspent_output = true
}

// SpentOutputCleared reports if the "spent_output" edge to the TokenOutput entity was cleared.
func (m *TokenTransactionMutation) SpentOutputCleared() bool {
	return m.clearedspent_output
}

// RemoveSpentOutputIDs removes the "spent_output" edge to the TokenOutput entity by IDs.
func (m *TokenTransactionMutation) RemoveSpentOutputIDs(ids ...uuid.UUID) {
	if m.removedspent_output == nil {
		m.removedspent_output = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.spent_output, ids[i])
		m.removedspent_output[ids[i]] = struct{}{}
	}
}

// RemovedSpentOutput returns the removed IDs of the "spent_output" edge to the TokenOutput entity.
func (m *TokenTransactionMutation) RemovedSpentOutputIDs() (ids []uuid.UUID) {
	for id := range m.removedspent_output {
		ids = append(ids, id)
	}
	return
}

// SpentOutputIDs returns the "spent_output" edge IDs in the mutation.
func (m *TokenTransactionMutation) SpentOutputIDs() (ids []uuid.UUID) {
	for id := range m.spent_output {
		ids = append(ids, id)
	}
	return
}

// ResetSpentOutput resets all changes to the "spent_output" edge.
func (m *TokenTransactionMutation) ResetSpentOutput() {
	m.spent_output = nil
	m.clearedspent_output = false
	m.removedspent_output = nil
}

// AddSpentOutputV2IDs adds the "spent_output_v2" edge to the TokenOutput entity by ids.
func (m *TokenTransactionMutation) AddSpentOutputV2IDs(ids ...uuid.UUID) {
	if m.spent_output_v2 == nil {
		m.spent_output_v2 = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.spent_output_v2[ids[i]] = struct{}{}
	}
}

// ClearSpentOutputV2 clears the "spent_output_v2" edge to the TokenOutput entity.
func (m *TokenTransactionMutation) ClearSpentOutputV2() {
	m.clearedspent_output_v2 = true
}

// SpentOutputV2Cleared reports if the "spent_output_v2" edge to the TokenOutput entity was cleared.
func (m *TokenTransactionMutation) SpentOutputV2Cleared() bool {
	return m.clearedspent_output_v2
}

// RemoveSpentOutputV2IDs removes the "spent_output_v2" edge to the TokenOutput entity by IDs.
func (m *TokenTransactionMutation) RemoveSpentOutputV2IDs(ids ...uuid.UUID) {
	if m.removedspent_output_v2 == nil {
		m.removedspent_output_v2 = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.spent_output_v2, ids[i])
		m.removedspent_output_v2[ids[i]] = struct{}{}
	}
}

// RemovedSpentOutputV2 returns the removed IDs of the "spent_output_v2" edge to the TokenOutput entity.
func (m *TokenTransactionMutation) RemovedSpentOutputV2IDs() (ids []uuid.UUID) {
	for id := range m.removedspent_output_v2 {
		ids = append(ids, id)
	}
	return
}

// SpentOutputV2IDs returns the "spent_output_v2" edge IDs in the mutation.
func (m *TokenTransactionMutation) SpentOutputV2IDs() (ids []uuid.UUID) {
	for id := range m.spent_output_v2 {
		ids = append(ids, id)
	}
	return
}

// ResetSpentOutputV2 resets all changes to the "spent_output_v2" edge.
func (m *TokenTransactionMutation) ResetSpentOutputV2() {
	m.spent_output_v2 = nil
	m.clearedspent_output_v2 = false
	m.removedspent_output_v2 = nil
}

// AddCreatedOutputIDs adds the "created_output" edge to the TokenOutput entity by ids.
func (m *TokenTransactionMutation) AddCreatedOutputIDs(ids ...uuid.UUID) {
	if m.created_output == nil {
		m.created_output = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.created_output[ids[i]] = struct{}{}
	}
}

// ClearCreatedOutput clears the "created_output" edge to the TokenOutput entity.
func (m *TokenTransactionMutation) ClearCreatedOutput() {
	m.clearedcreated_output = true
}

// CreatedOutputCleared reports if the "created_output" edge to the TokenOutput entity was cleared.
func (m *TokenTransactionMutation) CreatedOutputCleared() bool {
	return m.clearedcreated_output
}

// RemoveCreatedOutputIDs removes the "created_output" edge to the TokenOutput entity by IDs.
func (m *TokenTransactionMutation) RemoveCreatedOutputIDs(ids ...uuid.UUID) {
	if m.removedcreated_output == nil {
		m.removedcreated_output = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.created_output, ids[i])
		m.removedcreated_output[ids[i]] = struct{}{}
	}
}

// RemovedCreatedOutput returns the removed IDs of the "created_output" edge to the TokenOutput entity.
func (m *TokenTransactionMutation) RemovedCreatedOutputIDs() (ids []uuid.UUID) {
	for id := range m.removedcreated_output {
		ids = append(ids, id)
	}
	return
}

// CreatedOutputIDs returns the "created_output" edge IDs in the mutation.
func (m *TokenTransactionMutation) CreatedOutputIDs() (ids []uuid.UUID) {
	for id := range m.created_output {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedOutput resets all changes to the "created_output" edge.
func (m *TokenTransactionMutation) ResetCreatedOutput() {
	m.created_output = nil
	m.clearedcreated_output = false
	m.removedcreated_output = nil
}

// SetMintID sets the "mint" edge to the TokenMint entity by id.
func (m *TokenTransactionMutation) SetMintID(id uuid.UUID) {
	m.mint = &id
}

// ClearMint clears the "mint" edge to the TokenMint entity.
func (m *TokenTransactionMutation) ClearMint() {
	m.clearedmint = true
}

// MintCleared reports if the "mint" edge to the TokenMint entity was cleared.
func (m *TokenTransactionMutation) MintCleared() bool {
	return m.clearedmint
}

// MintID returns the "mint" edge ID in the mutation.
func (m *TokenTransactionMutation) MintID() (id uuid.UUID, exists bool) {
	if m.mint != nil {
		return *m.mint, true
	}
	return
}

// MintIDs returns the "mint" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MintID instead. It exists only for internal usage by the builders.
func (m *TokenTransactionMutation) MintIDs() (ids []uuid.UUID) {
	if id := m.mint; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMint resets all changes to the "mint" edge.
func (m *TokenTransactionMutation) ResetMint() {
	m.mint = nil
	m.clearedmint = false
}

// SetCreateID sets the "create" edge to the TokenCreate entity by id.
func (m *TokenTransactionMutation) SetCreateID(id uuid.UUID) {
	m.create = &id
}

// ClearCreate clears the "create" edge to the TokenCreate entity.
func (m *TokenTransactionMutation) ClearCreate() {
	m.clearedcreate = true
}

// CreateCleared reports if the "create" edge to the TokenCreate entity was cleared.
func (m *TokenTransactionMutation) CreateCleared() bool {
	return m.clearedcreate
}

// CreateID returns the "create" edge ID in the mutation.
func (m *TokenTransactionMutation) CreateID() (id uuid.UUID, exists bool) {
	if m.create != nil {
		return *m.create, true
	}
	return
}

// CreateIDs returns the "create" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreateID instead. It exists only for internal usage by the builders.
func (m *TokenTransactionMutation) CreateIDs() (ids []uuid.UUID) {
	if id := m.create; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreate resets all changes to the "create" edge.
func (m *TokenTransactionMutation) ResetCreate() {
	m.create = nil
	m.clearedcreate = false
}

// SetPaymentIntentID sets the "payment_intent" edge to the PaymentIntent entity by id.
func (m *TokenTransactionMutation) SetPaymentIntentID(id uuid.UUID) {
	m.payment_intent = &id
}

// ClearPaymentIntent clears the "payment_intent" edge to the PaymentIntent entity.
func (m *TokenTransactionMutation) ClearPaymentIntent() {
	m.clearedpayment_intent = true
}

// PaymentIntentCleared reports if the "payment_intent" edge to the PaymentIntent entity was cleared.
func (m *TokenTransactionMutation) PaymentIntentCleared() bool {
	return m.clearedpayment_intent
}

// PaymentIntentID returns the "payment_intent" edge ID in the mutation.
func (m *TokenTransactionMutation) PaymentIntentID() (id uuid.UUID, exists bool) {
	if m.payment_intent != nil {
		return *m.payment_intent, true
	}
	return
}

// PaymentIntentIDs returns the "payment_intent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PaymentIntentID instead. It exists only for internal usage by the builders.
func (m *TokenTransactionMutation) PaymentIntentIDs() (ids []uuid.UUID) {
	if id := m.payment_intent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPaymentIntent resets all changes to the "payment_intent" edge.
func (m *TokenTransactionMutation) ResetPaymentIntent() {
	m.payment_intent = nil
	m.clearedpayment_intent = false
}

// AddPeerSignatureIDs adds the "peer_signatures" edge to the TokenTransactionPeerSignature entity by ids.
func (m *TokenTransactionMutation) AddPeerSignatureIDs(ids ...uuid.UUID) {
	if m.peer_signatures == nil {
		m.peer_signatures = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.peer_signatures[ids[i]] = struct{}{}
	}
}

// ClearPeerSignatures clears the "peer_signatures" edge to the TokenTransactionPeerSignature entity.
func (m *TokenTransactionMutation) ClearPeerSignatures() {
	m.clearedpeer_signatures = true
}

// PeerSignaturesCleared reports if the "peer_signatures" edge to the TokenTransactionPeerSignature entity was cleared.
func (m *TokenTransactionMutation) PeerSignaturesCleared() bool {
	return m.clearedpeer_signatures
}

// RemovePeerSignatureIDs removes the "peer_signatures" edge to the TokenTransactionPeerSignature entity by IDs.
func (m *TokenTransactionMutation) RemovePeerSignatureIDs(ids ...uuid.UUID) {
	if m.removedpeer_signatures == nil {
		m.removedpeer_signatures = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.peer_signatures, ids[i])
		m.removedpeer_signatures[ids[i]] = struct{}{}
	}
}

// RemovedPeerSignatures returns the removed IDs of the "peer_signatures" edge to the TokenTransactionPeerSignature entity.
func (m *TokenTransactionMutation) RemovedPeerSignaturesIDs() (ids []uuid.UUID) {
	for id := range m.removedpeer_signatures {
		ids = append(ids, id)
	}
	return
}

// PeerSignaturesIDs returns the "peer_signatures" edge IDs in the mutation.
func (m *TokenTransactionMutation) PeerSignaturesIDs() (ids []uuid.UUID) {
	for id := range m.peer_signatures {
		ids = append(ids, id)
	}
	return
}

// ResetPeerSignatures resets all changes to the "peer_signatures" edge.
func (m *TokenTransactionMutation) ResetPeerSignatures() {
	m.peer_signatures = nil
	m.clearedpeer_signatures = false
	m.removedpeer_signatures = nil
}

// AddSparkInvoiceIDs adds the "spark_invoice" edge to the SparkInvoice entity by ids.
func (m *TokenTransactionMutation) AddSparkInvoiceIDs(ids ...uuid.UUID) {
	if m.spark_invoice == nil {
		m.spark_invoice = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.spark_invoice[ids[i]] = struct{}{}
	}
}

// ClearSparkInvoice clears the "spark_invoice" edge to the SparkInvoice entity.
func (m *TokenTransactionMutation) ClearSparkInvoice() {
	m.clearedspark_invoice = true
}

// SparkInvoiceCleared reports if the "spark_invoice" edge to the SparkInvoice entity was cleared.
func (m *TokenTransactionMutation) SparkInvoiceCleared() bool {
	return m.clearedspark_invoice
}

// RemoveSparkInvoiceIDs removes the "spark_invoice" edge to the SparkInvoice entity by IDs.
func (m *TokenTransactionMutation) RemoveSparkInvoiceIDs(ids ...uuid.UUID) {
	if m.removedspark_invoice == nil {
		m.removedspark_invoice = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.spark_invoice, ids[i])
		m.removedspark_invoice[ids[i]] = struct{}{}
	}
}

// RemovedSparkInvoice returns the removed IDs of the "spark_invoice" edge to the SparkInvoice entity.
func (m *TokenTransactionMutation) RemovedSparkInvoiceIDs() (ids []uuid.UUID) {
	for id := range m.removedspark_invoice {
		ids = append(ids, id)
	}
	return
}

// SparkInvoiceIDs returns the "spark_invoice" edge IDs in the mutation.
func (m *TokenTransactionMutation) SparkInvoiceIDs() (ids []uuid.UUID) {
	for id := range m.spark_invoice {
		ids = append(ids, id)
	}
	return
}

// ResetSparkInvoice resets all changes to the "spark_invoice" edge.
func (m *TokenTransactionMutation) ResetSparkInvoice() {
	m.spark_invoice = nil
	m.clearedspark_invoice = false
	m.removedspark_invoice = nil
}

// Where appends a list predicates to the TokenTransactionMutation builder.
func (m *TokenTransactionMutation) Where(ps ...predicate.TokenTransaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenTransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenTransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TokenTransaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenTransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenTransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TokenTransaction).
func (m *TokenTransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenTransactionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, tokentransaction.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, tokentransaction.FieldUpdateTime)
	}
	if m.partial_token_transaction_hash != nil {
		fields = append(fields, tokentransaction.FieldPartialTokenTransactionHash)
	}
	if m.finalized_token_transaction_hash != nil {
		fields = append(fields, tokentransaction.FieldFinalizedTokenTransactionHash)
	}
	if m.operator_signature != nil {
		fields = append(fields, tokentransaction.FieldOperatorSignature)
	}
	if m.status != nil {
		fields = append(fields, tokentransaction.FieldStatus)
	}
	if m.expiry_time != nil {
		fields = append(fields, tokentransaction.FieldExpiryTime)
	}
	if m.coordinator_public_key != nil {
		fields = append(fields, tokentransaction.FieldCoordinatorPublicKey)
	}
	if m.client_created_timestamp != nil {
		fields = append(fields, tokentransaction.FieldClientCreatedTimestamp)
	}
	if m.version != nil {
		fields = append(fields, tokentransaction.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenTransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tokentransaction.FieldCreateTime:
		return m.CreateTime()
	case tokentransaction.FieldUpdateTime:
		return m.UpdateTime()
	case tokentransaction.FieldPartialTokenTransactionHash:
		return m.PartialTokenTransactionHash()
	case tokentransaction.FieldFinalizedTokenTransactionHash:
		return m.FinalizedTokenTransactionHash()
	case tokentransaction.FieldOperatorSignature:
		return m.OperatorSignature()
	case tokentransaction.FieldStatus:
		return m.Status()
	case tokentransaction.FieldExpiryTime:
		return m.ExpiryTime()
	case tokentransaction.FieldCoordinatorPublicKey:
		return m.CoordinatorPublicKey()
	case tokentransaction.FieldClientCreatedTimestamp:
		return m.ClientCreatedTimestamp()
	case tokentransaction.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenTransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tokentransaction.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case tokentransaction.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case tokentransaction.FieldPartialTokenTransactionHash:
		return m.OldPartialTokenTransactionHash(ctx)
	case tokentransaction.FieldFinalizedTokenTransactionHash:
		return m.OldFinalizedTokenTransactionHash(ctx)
	case tokentransaction.FieldOperatorSignature:
		return m.OldOperatorSignature(ctx)
	case tokentransaction.FieldStatus:
		return m.OldStatus(ctx)
	case tokentransaction.FieldExpiryTime:
		return m.OldExpiryTime(ctx)
	case tokentransaction.FieldCoordinatorPublicKey:
		return m.OldCoordinatorPublicKey(ctx)
	case tokentransaction.FieldClientCreatedTimestamp:
		return m.OldClientCreatedTimestamp(ctx)
	case tokentransaction.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown TokenTransaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenTransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tokentransaction.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case tokentransaction.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case tokentransaction.FieldPartialTokenTransactionHash:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPartialTokenTransactionHash(v)
		return nil
	case tokentransaction.FieldFinalizedTokenTransactionHash:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinalizedTokenTransactionHash(v)
		return nil
	case tokentransaction.FieldOperatorSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorSignature(v)
		return nil
	case tokentransaction.FieldStatus:
		v, ok := value.(schematype.TokenTransactionStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tokentransaction.FieldExpiryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiryTime(v)
		return nil
	case tokentransaction.FieldCoordinatorPublicKey:
		v, ok := value.(keys.Public)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoordinatorPublicKey(v)
		return nil
	case tokentransaction.FieldClientCreatedTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientCreatedTimestamp(v)
		return nil
	case tokentransaction.FieldVersion:
		v, ok := value.(schematype.TokenTransactionVersion)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown TokenTransaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenTransactionMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, tokentransaction.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenTransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tokentransaction.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenTransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tokentransaction.FieldVersion:
		v, ok := value.(schematype.TokenTransactionVersion)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown TokenTransaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenTransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tokentransaction.FieldOperatorSignature) {
		fields = append(fields, tokentransaction.FieldOperatorSignature)
	}
	if m.FieldCleared(tokentransaction.FieldStatus) {
		fields = append(fields, tokentransaction.FieldStatus)
	}
	if m.FieldCleared(tokentransaction.FieldExpiryTime) {
		fields = append(fields, tokentransaction.FieldExpiryTime)
	}
	if m.FieldCleared(tokentransaction.FieldCoordinatorPublicKey) {
		fields = append(fields, tokentransaction.FieldCoordinatorPublicKey)
	}
	if m.FieldCleared(tokentransaction.FieldClientCreatedTimestamp) {
		fields = append(fields, tokentransaction.FieldClientCreatedTimestamp)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenTransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenTransactionMutation) ClearField(name string) error {
	switch name {
	case tokentransaction.FieldOperatorSignature:
		m.ClearOperatorSignature()
		return nil
	case tokentransaction.FieldStatus:
		m.ClearStatus()
		return nil
	case tokentransaction.FieldExpiryTime:
		m.ClearExpiryTime()
		return nil
	case tokentransaction.FieldCoordinatorPublicKey:
		m.ClearCoordinatorPublicKey()
		return nil
	case tokentransaction.FieldClientCreatedTimestamp:
		m.ClearClientCreatedTimestamp()
		return nil
	}
	return fmt.Errorf("unknown TokenTransaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenTransactionMutation) ResetField(name string) error {
	switch name {
	case tokentransaction.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case tokentransaction.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case tokentransaction.FieldPartialTokenTransactionHash:
		m.ResetPartialTokenTransactionHash()
		return nil
	case tokentransaction.FieldFinalizedTokenTransactionHash:
		m.ResetFinalizedTokenTransactionHash()
		return nil
	case tokentransaction.FieldOperatorSignature:
		m.ResetOperatorSignature()
		return nil
	case tokentransaction.FieldStatus:
		m.ResetStatus()
		return nil
	case tokentransaction.FieldExpiryTime:
		m.ResetExpiryTime()
		return nil
	case tokentransaction.FieldCoordinatorPublicKey:
		m.ResetCoordinatorPublicKey()
		return nil
	case tokentransaction.FieldClientCreatedTimestamp:
		m.ResetClientCreatedTimestamp()
		return nil
	case tokentransaction.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown TokenTransaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenTransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.spent_output != nil {
		edges = append(edges, tokentransaction.EdgeSpentOutput)
	}
	if m.spent_output_v2 != nil {
		edges = append(edges, tokentransaction.EdgeSpentOutputV2)
	}
	if m.created_output != nil {
		edges = append(edges, tokentransaction.EdgeCreatedOutput)
	}
	if m.mint != nil {
		edges = append(edges, tokentransaction.EdgeMint)
	}
	if m.create != nil {
		edges = append(edges, tokentransaction.EdgeCreate)
	}
	if m.payment_intent != nil {
		edges = append(edges, tokentransaction.EdgePaymentIntent)
	}
	if m.peer_signatures != nil {
		edges = append(edges, tokentransaction.EdgePeerSignatures)
	}
	if m.spark_invoice != nil {
		edges = append(edges, tokentransaction.EdgeSparkInvoice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenTransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tokentransaction.EdgeSpentOutput:
		ids := make([]ent.Value, 0, len(m.spent_output))
		for id := range m.spent_output {
			ids = append(ids, id)
		}
		return ids
	case tokentransaction.EdgeSpentOutputV2:
		ids := make([]ent.Value, 0, len(m.spent_output_v2))
		for id := range m.spent_output_v2 {
			ids = append(ids, id)
		}
		return ids
	case tokentransaction.EdgeCreatedOutput:
		ids := make([]ent.Value, 0, len(m.created_output))
		for id := range m.created_output {
			ids = append(ids, id)
		}
		return ids
	case tokentransaction.EdgeMint:
		if id := m.mint; id != nil {
			return []ent.Value{*id}
		}
	case tokentransaction.EdgeCreate:
		if id := m.create; id != nil {
			return []ent.Value{*id}
		}
	case tokentransaction.EdgePaymentIntent:
		if id := m.payment_intent; id != nil {
			return []ent.Value{*id}
		}
	case tokentransaction.EdgePeerSignatures:
		ids := make([]ent.Value, 0, len(m.peer_signatures))
		for id := range m.peer_signatures {
			ids = append(ids, id)
		}
		return ids
	case tokentransaction.EdgeSparkInvoice:
		ids := make([]ent.Value, 0, len(m.spark_invoice))
		for id := range m.spark_invoice {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenTransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedspent_output != nil {
		edges = append(edges, tokentransaction.EdgeSpentOutput)
	}
	if m.removedspent_output_v2 != nil {
		edges = append(edges, tokentransaction.EdgeSpentOutputV2)
	}
	if m.removedcreated_output != nil {
		edges = append(edges, tokentransaction.EdgeCreatedOutput)
	}
	if m.removedpeer_signatures != nil {
		edges = append(edges, tokentransaction.EdgePeerSignatures)
	}
	if m.removedspark_invoice != nil {
		edges = append(edges, tokentransaction.EdgeSparkInvoice)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenTransactionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tokentransaction.EdgeSpentOutput:
		ids := make([]ent.Value, 0, len(m.removedspent_output))
		for id := range m.removedspent_output {
			ids = append(ids, id)
		}
		return ids
	case tokentransaction.EdgeSpentOutputV2:
		ids := make([]ent.Value, 0, len(m.removedspent_output_v2))
		for id := range m.removedspent_output_v2 {
			ids = append(ids, id)
		}
		return ids
	case tokentransaction.EdgeCreatedOutput:
		ids := make([]ent.Value, 0, len(m.removedcreated_output))
		for id := range m.removedcreated_output {
			ids = append(ids, id)
		}
		return ids
	case tokentransaction.EdgePeerSignatures:
		ids := make([]ent.Value, 0, len(m.removedpeer_signatures))
		for id := range m.removedpeer_signatures {
			ids = append(ids, id)
		}
		return ids
	case tokentransaction.EdgeSparkInvoice:
		ids := make([]ent.Value, 0, len(m.removedspark_invoice))
		for id := range m.removedspark_invoice {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenTransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedspent_output {
		edges = append(edges, tokentransaction.EdgeSpentOutput)
	}
	if m.clearedspent_output_v2 {
		edges = append(edges, tokentransaction.EdgeSpentOutputV2)
	}
	if m.clearedcreated_output {
		edges = append(edges, tokentransaction.EdgeCreatedOutput)
	}
	if m.clearedmint {
		edges = append(edges, tokentransaction.EdgeMint)
	}
	if m.clearedcreate {
		edges = append(edges, tokentransaction.EdgeCreate)
	}
	if m.clearedpayment_intent {
		edges = append(edges, tokentransaction.EdgePaymentIntent)
	}
	if m.clearedpeer_signatures {
		edges = append(edges, tokentransaction.EdgePeerSignatures)
	}
	if m.clearedspark_invoice {
		edges = append(edges, tokentransaction.EdgeSparkInvoice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenTransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case tokentransaction.EdgeSpentOutput:
		return m.clearedspent_output
	case tokentransaction.EdgeSpentOutputV2:
		return m.clearedspent_output_v2
	case tokentransaction.EdgeCreatedOutput:
		return m.clearedcreated_output
	case tokentransaction.EdgeMint:
		return m.clearedmint
	case tokentransaction.EdgeCreate:
		return m.clearedcreate
	case tokentransaction.EdgePaymentIntent:
		return m.clearedpayment_intent
	case tokentransaction.EdgePeerSignatures:
		return m.clearedpeer_signatures
	case tokentransaction.EdgeSparkInvoice:
		return m.clearedspark_invoice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenTransactionMutation) ClearEdge(name string) error {
	switch name {
	case tokentransaction.EdgeMint:
		m.ClearMint()
		return nil
	case tokentransaction.EdgeCreate:
		m.ClearCreate()
		return nil
	case tokentransaction.EdgePaymentIntent:
		m.ClearPaymentIntent()
		return nil
	}
	return fmt.Errorf("unknown TokenTransaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenTransactionMutation) ResetEdge(name string) error {
	switch name {
	case tokentransaction.EdgeSpentOutput:
		m.ResetSpentOutput()
		return nil
	case tokentransaction.EdgeSpentOutputV2:
		m.ResetSpentOutputV2()
		return nil
	case tokentransaction.EdgeCreatedOutput:
		m.ResetCreatedOutput()
		return nil
	case tokentransaction.EdgeMint:
		m.ResetMint()
		return nil
	case tokentransaction.EdgeCreate:
		m.ResetCreate()
		return nil
	case tokentransaction.EdgePaymentIntent:
		m.ResetPaymentIntent()
		return nil
	case tokentransaction.EdgePeerSignatures:
		m.ResetPeerSignatures()
		return nil
	case tokentransaction.EdgeSparkInvoice:
		m.ResetSparkInvoice()
		return nil
	}
	return fmt.Errorf("unknown TokenTransaction edge %s", name)
}

// TokenTransactionPeerSignatureMutation represents an operation that mutates the TokenTransactionPeerSignature nodes in the graph.
type TokenTransactionPeerSignatureMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	create_time                  *time.Time
	update_time                  *time.Time
	operator_identity_public_key *keys.Public
	signature                    *[]byte
	clearedFields                map[string]struct{}
	token_transaction            *uuid.UUID
	clearedtoken_transaction     bool
	done                         bool
	oldValue                     func(context.Context) (*TokenTransactionPeerSignature, error)
	predicates                   []predicate.TokenTransactionPeerSignature
}

var _ ent.Mutation = (*TokenTransactionPeerSignatureMutation)(nil)

// tokentransactionpeersignatureOption allows management of the mutation configuration using functional options.
type tokentransactionpeersignatureOption func(*TokenTransactionPeerSignatureMutation)

// newTokenTransactionPeerSignatureMutation creates new mutation for the TokenTransactionPeerSignature entity.
func newTokenTransactionPeerSignatureMutation(c config, op Op, opts ...tokentransactionpeersignatureOption) *TokenTransactionPeerSignatureMutation {
	m := &TokenTransactionPeerSignatureMutation{
		config:        c,
		op:            op,
		typ:           TypeTokenTransactionPeerSignature,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenTransactionPeerSignatureID sets the ID field of the mutation.
func withTokenTransactionPeerSignatureID(id uuid.UUID) tokentransactionpeersignatureOption {
	return func(m *TokenTransactionPeerSignatureMutation) {
		var (
			err   error
			once  sync.Once
			value *TokenTransactionPeerSignature
		)
		m.oldValue = func(ctx context.Context) (*TokenTransactionPeerSignature, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TokenTransactionPeerSignature.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTokenTransactionPeerSignature sets the old TokenTransactionPeerSignature of the mutation.
func withTokenTransactionPeerSignature(node *TokenTransactionPeerSignature) tokentransactionpeersignatureOption {
	return func(m *TokenTransactionPeerSignatureMutation) {
		m.oldValue = func(context.Context) (*TokenTransactionPeerSignature, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenTransactionPeerSignatureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenTransactionPeerSignatureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TokenTransactionPeerSignature entities.
func (m *TokenTransactionPeerSignatureMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenTransactionPeerSignatureMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenTransactionPeerSignatureMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TokenTransactionPeerSignature.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TokenTransactionPeerSignatureMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TokenTransactionPeerSignatureMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TokenTransactionPeerSignature entity.
// If the TokenTransactionPeerSignature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenTransactionPeerSignatureMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TokenTransactionPeerSignatureMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TokenTransactionPeerSignatureMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TokenTransactionPeerSignatureMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TokenTransactionPeerSignature entity.
// If the TokenTransactionPeerSignature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenTransactionPeerSignatureMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TokenTransactionPeerSignatureMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetOperatorIdentityPublicKey sets the "operator_identity_public_key" field.
func (m *TokenTransactionPeerSignatureMutation) SetOperatorIdentityPublicKey(k keys.Public) {
	m.operator_identity_public_key = &k
}

// OperatorIdentityPublicKey returns the value of the "operator_identity_public_key" field in the mutation.
func (m *TokenTransactionPeerSignatureMutation) OperatorIdentityPublicKey() (r keys.Public, exists bool) {
	v := m.operator_identity_public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorIdentityPublicKey returns the old "operator_identity_public_key" field's value of the TokenTransactionPeerSignature entity.
// If the TokenTransactionPeerSignature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenTransactionPeerSignatureMutation) OldOperatorIdentityPublicKey(ctx context.Context) (v keys.Public, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorIdentityPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorIdentityPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorIdentityPublicKey: %w", err)
	}
	return oldValue.OperatorIdentityPublicKey, nil
}

// ResetOperatorIdentityPublicKey resets all changes to the "operator_identity_public_key" field.
func (m *TokenTransactionPeerSignatureMutation) ResetOperatorIdentityPublicKey() {
	m.operator_identity_public_key = nil
}

// SetSignature sets the "signature" field.
func (m *TokenTransactionPeerSignatureMutation) SetSignature(b []byte) {
	m.signature = &b
}

// Signature returns the value of the "signature" field in the mutation.
func (m *TokenTransactionPeerSignatureMutation) Signature() (r []byte, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the TokenTransactionPeerSignature entity.
// If the TokenTransactionPeerSignature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenTransactionPeerSignatureMutation) OldSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ResetSignature resets all changes to the "signature" field.
func (m *TokenTransactionPeerSignatureMutation) ResetSignature() {
	m.signature = nil
}

// SetTokenTransactionID sets the "token_transaction" edge to the TokenTransaction entity by id.
func (m *TokenTransactionPeerSignatureMutation) SetTokenTransactionID(id uuid.UUID) {
	m.token_transaction = &id
}

// ClearTokenTransaction clears the "token_transaction" edge to the TokenTransaction entity.
func (m *TokenTransactionPeerSignatureMutation) ClearTokenTransaction() {
	m.clearedtoken_transaction = true
}

// TokenTransactionCleared reports if the "token_transaction" edge to the TokenTransaction entity was cleared.
func (m *TokenTransactionPeerSignatureMutation) TokenTransactionCleared() bool {
	return m.clearedtoken_transaction
}

// TokenTransactionID returns the "token_transaction" edge ID in the mutation.
func (m *TokenTransactionPeerSignatureMutation) TokenTransactionID() (id uuid.UUID, exists bool) {
	if m.token_transaction != nil {
		return *m.token_transaction, true
	}
	return
}

// TokenTransactionIDs returns the "token_transaction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TokenTransactionID instead. It exists only for internal usage by the builders.
func (m *TokenTransactionPeerSignatureMutation) TokenTransactionIDs() (ids []uuid.UUID) {
	if id := m.token_transaction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTokenTransaction resets all changes to the "token_transaction" edge.
func (m *TokenTransactionPeerSignatureMutation) ResetTokenTransaction() {
	m.token_transaction = nil
	m.clearedtoken_transaction = false
}

// Where appends a list predicates to the TokenTransactionPeerSignatureMutation builder.
func (m *TokenTransactionPeerSignatureMutation) Where(ps ...predicate.TokenTransactionPeerSignature) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenTransactionPeerSignatureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenTransactionPeerSignatureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TokenTransactionPeerSignature, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenTransactionPeerSignatureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenTransactionPeerSignatureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TokenTransactionPeerSignature).
func (m *TokenTransactionPeerSignatureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenTransactionPeerSignatureMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, tokentransactionpeersignature.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, tokentransactionpeersignature.FieldUpdateTime)
	}
	if m.operator_identity_public_key != nil {
		fields = append(fields, tokentransactionpeersignature.FieldOperatorIdentityPublicKey)
	}
	if m.signature != nil {
		fields = append(fields, tokentransactionpeersignature.FieldSignature)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenTransactionPeerSignatureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tokentransactionpeersignature.FieldCreateTime:
		return m.CreateTime()
	case tokentransactionpeersignature.FieldUpdateTime:
		return m.UpdateTime()
	case tokentransactionpeersignature.FieldOperatorIdentityPublicKey:
		return m.OperatorIdentityPublicKey()
	case tokentransactionpeersignature.FieldSignature:
		return m.Signature()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenTransactionPeerSignatureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tokentransactionpeersignature.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case tokentransactionpeersignature.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case tokentransactionpeersignature.FieldOperatorIdentityPublicKey:
		return m.OldOperatorIdentityPublicKey(ctx)
	case tokentransactionpeersignature.FieldSignature:
		return m.OldSignature(ctx)
	}
	return nil, fmt.Errorf("unknown TokenTransactionPeerSignature field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenTransactionPeerSignatureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tokentransactionpeersignature.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case tokentransactionpeersignature.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case tokentransactionpeersignature.FieldOperatorIdentityPublicKey:
		v, ok := value.(keys.Public)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorIdentityPublicKey(v)
		return nil
	case tokentransactionpeersignature.FieldSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	}
	return fmt.Errorf("unknown TokenTransactionPeerSignature field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenTransactionPeerSignatureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenTransactionPeerSignatureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenTransactionPeerSignatureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TokenTransactionPeerSignature numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenTransactionPeerSignatureMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenTransactionPeerSignatureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenTransactionPeerSignatureMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TokenTransactionPeerSignature nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenTransactionPeerSignatureMutation) ResetField(name string) error {
	switch name {
	case tokentransactionpeersignature.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case tokentransactionpeersignature.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case tokentransactionpeersignature.FieldOperatorIdentityPublicKey:
		m.ResetOperatorIdentityPublicKey()
		return nil
	case tokentransactionpeersignature.FieldSignature:
		m.ResetSignature()
		return nil
	}
	return fmt.Errorf("unknown TokenTransactionPeerSignature field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenTransactionPeerSignatureMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.token_transaction != nil {
		edges = append(edges, tokentransactionpeersignature.EdgeTokenTransaction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenTransactionPeerSignatureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tokentransactionpeersignature.EdgeTokenTransaction:
		if id := m.token_transaction; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenTransactionPeerSignatureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenTransactionPeerSignatureMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenTransactionPeerSignatureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtoken_transaction {
		edges = append(edges, tokentransactionpeersignature.EdgeTokenTransaction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenTransactionPeerSignatureMutation) EdgeCleared(name string) bool {
	switch name {
	case tokentransactionpeersignature.EdgeTokenTransaction:
		return m.clearedtoken_transaction
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenTransactionPeerSignatureMutation) ClearEdge(name string) error {
	switch name {
	case tokentransactionpeersignature.EdgeTokenTransaction:
		m.ClearTokenTransaction()
		return nil
	}
	return fmt.Errorf("unknown TokenTransactionPeerSignature unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenTransactionPeerSignatureMutation) ResetEdge(name string) error {
	switch name {
	case tokentransactionpeersignature.EdgeTokenTransaction:
		m.ResetTokenTransaction()
		return nil
	}
	return fmt.Errorf("unknown TokenTransactionPeerSignature edge %s", name)
}

// TransferMutation represents an operation that mutates the Transfer nodes in the graph.
type TransferMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	create_time                  *time.Time
	update_time                  *time.Time
	sender_identity_pubkey       *keys.Public
	receiver_identity_pubkey     *keys.Public
	total_value                  *uint64
	addtotal_value               *int64
	status                       *schematype.TransferStatus
	_type                        *schematype.TransferType
	expiry_time                  *time.Time
	completion_time              *time.Time
	clearedFields                map[string]struct{}
	transfer_leaves              map[uuid.UUID]struct{}
	removedtransfer_leaves       map[uuid.UUID]struct{}
	clearedtransfer_leaves       bool
	payment_intent               *uuid.UUID
	clearedpayment_intent        bool
	spark_invoice                *uuid.UUID
	clearedspark_invoice         bool
	counter_swap_transfer        map[uuid.UUID]struct{}
	removedcounter_swap_transfer map[uuid.UUID]struct{}
	clearedcounter_swap_transfer bool
	primary_swap_transfer        *uuid.UUID
	clearedprimary_swap_transfer bool
	done                         bool
	oldValue                     func(context.Context) (*Transfer, error)
	predicates                   []predicate.Transfer
}

var _ ent.Mutation = (*TransferMutation)(nil)

// transferOption allows management of the mutation configuration using functional options.
type transferOption func(*TransferMutation)

// newTransferMutation creates new mutation for the Transfer entity.
func newTransferMutation(c config, op Op, opts ...transferOption) *TransferMutation {
	m := &TransferMutation{
		config:        c,
		op:            op,
		typ:           TypeTransfer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransferID sets the ID field of the mutation.
func withTransferID(id uuid.UUID) transferOption {
	return func(m *TransferMutation) {
		var (
			err   error
			once  sync.Once
			value *Transfer
		)
		m.oldValue = func(ctx context.Context) (*Transfer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transfer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransfer sets the old Transfer of the mutation.
func withTransfer(node *Transfer) transferOption {
	return func(m *TransferMutation) {
		m.oldValue = func(context.Context) (*Transfer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransferMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransferMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transfer entities.
func (m *TransferMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransferMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransferMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transfer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TransferMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TransferMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TransferMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TransferMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TransferMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TransferMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetSenderIdentityPubkey sets the "sender_identity_pubkey" field.
func (m *TransferMutation) SetSenderIdentityPubkey(k keys.Public) {
	m.sender_identity_pubkey = &k
}

// SenderIdentityPubkey returns the value of the "sender_identity_pubkey" field in the mutation.
func (m *TransferMutation) SenderIdentityPubkey() (r keys.Public, exists bool) {
	v := m.sender_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderIdentityPubkey returns the old "sender_identity_pubkey" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldSenderIdentityPubkey(ctx context.Context) (v keys.Public, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderIdentityPubkey: %w", err)
	}
	return oldValue.SenderIdentityPubkey, nil
}

// ResetSenderIdentityPubkey resets all changes to the "sender_identity_pubkey" field.
func (m *TransferMutation) ResetSenderIdentityPubkey() {
	m.sender_identity_pubkey = nil
}

// SetReceiverIdentityPubkey sets the "receiver_identity_pubkey" field.
func (m *TransferMutation) SetReceiverIdentityPubkey(k keys.Public) {
	m.receiver_identity_pubkey = &k
}

// ReceiverIdentityPubkey returns the value of the "receiver_identity_pubkey" field in the mutation.
func (m *TransferMutation) ReceiverIdentityPubkey() (r keys.Public, exists bool) {
	v := m.receiver_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverIdentityPubkey returns the old "receiver_identity_pubkey" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldReceiverIdentityPubkey(ctx context.Context) (v keys.Public, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverIdentityPubkey: %w", err)
	}
	return oldValue.ReceiverIdentityPubkey, nil
}

// ResetReceiverIdentityPubkey resets all changes to the "receiver_identity_pubkey" field.
func (m *TransferMutation) ResetReceiverIdentityPubkey() {
	m.receiver_identity_pubkey = nil
}

// SetTotalValue sets the "total_value" field.
func (m *TransferMutation) SetTotalValue(u uint64) {
	m.total_value = &u
	m.addtotal_value = nil
}

// TotalValue returns the value of the "total_value" field in the mutation.
func (m *TransferMutation) TotalValue() (r uint64, exists bool) {
	v := m.total_value
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalValue returns the old "total_value" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldTotalValue(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalValue: %w", err)
	}
	return oldValue.TotalValue, nil
}

// AddTotalValue adds u to the "total_value" field.
func (m *TransferMutation) AddTotalValue(u int64) {
	if m.addtotal_value != nil {
		*m.addtotal_value += u
	} else {
		m.addtotal_value = &u
	}
}

// AddedTotalValue returns the value that was added to the "total_value" field in this mutation.
func (m *TransferMutation) AddedTotalValue() (r int64, exists bool) {
	v := m.addtotal_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalValue resets all changes to the "total_value" field.
func (m *TransferMutation) ResetTotalValue() {
	m.total_value = nil
	m.addtotal_value = nil
}

// SetStatus sets the "status" field.
func (m *TransferMutation) SetStatus(ss schematype.TransferStatus) {
	m.status = &ss
}

// Status returns the value of the "status" field in the mutation.
func (m *TransferMutation) Status() (r schematype.TransferStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldStatus(ctx context.Context) (v schematype.TransferStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TransferMutation) ResetStatus() {
	m.status = nil
}

// SetType sets the "type" field.
func (m *TransferMutation) SetType(st schematype.TransferType) {
	m._type = &st
}

// GetType returns the value of the "type" field in the mutation.
func (m *TransferMutation) GetType() (r schematype.TransferType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldType(ctx context.Context) (v schematype.TransferType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TransferMutation) ResetType() {
	m._type = nil
}

// SetExpiryTime sets the "expiry_time" field.
func (m *TransferMutation) SetExpiryTime(t time.Time) {
	m.expiry_time = &t
}

// ExpiryTime returns the value of the "expiry_time" field in the mutation.
func (m *TransferMutation) ExpiryTime() (r time.Time, exists bool) {
	v := m.expiry_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiryTime returns the old "expiry_time" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldExpiryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiryTime: %w", err)
	}
	return oldValue.ExpiryTime, nil
}

// ResetExpiryTime resets all changes to the "expiry_time" field.
func (m *TransferMutation) ResetExpiryTime() {
	m.expiry_time = nil
}

// SetCompletionTime sets the "completion_time" field.
func (m *TransferMutation) SetCompletionTime(t time.Time) {
	m.completion_time = &t
}

// CompletionTime returns the value of the "completion_time" field in the mutation.
func (m *TransferMutation) CompletionTime() (r time.Time, exists bool) {
	v := m.completion_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionTime returns the old "completion_time" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldCompletionTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionTime: %w", err)
	}
	return oldValue.CompletionTime, nil
}

// ClearCompletionTime clears the value of the "completion_time" field.
func (m *TransferMutation) ClearCompletionTime() {
	m.completion_time = nil
	m.clearedFields[transfer.FieldCompletionTime] = struct{}{}
}

// CompletionTimeCleared returns if the "completion_time" field was cleared in this mutation.
func (m *TransferMutation) CompletionTimeCleared() bool {
	_, ok := m.clearedFields[transfer.FieldCompletionTime]
	return ok
}

// ResetCompletionTime resets all changes to the "completion_time" field.
func (m *TransferMutation) ResetCompletionTime() {
	m.completion_time = nil
	delete(m.clearedFields, transfer.FieldCompletionTime)
}

// SetSparkInvoiceID sets the "spark_invoice_id" field.
func (m *TransferMutation) SetSparkInvoiceID(u uuid.UUID) {
	m.spark_invoice = &u
}

// SparkInvoiceID returns the value of the "spark_invoice_id" field in the mutation.
func (m *TransferMutation) SparkInvoiceID() (r uuid.UUID, exists bool) {
	v := m.spark_invoice
	if v == nil {
		return
	}
	return *v, true
}

// OldSparkInvoiceID returns the old "spark_invoice_id" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldSparkInvoiceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSparkInvoiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSparkInvoiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSparkInvoiceID: %w", err)
	}
	return oldValue.SparkInvoiceID, nil
}

// ClearSparkInvoiceID clears the value of the "spark_invoice_id" field.
func (m *TransferMutation) ClearSparkInvoiceID() {
	m.spark_invoice = nil
	m.clearedFields[transfer.FieldSparkInvoiceID] = struct{}{}
}

// SparkInvoiceIDCleared returns if the "spark_invoice_id" field was cleared in this mutation.
func (m *TransferMutation) SparkInvoiceIDCleared() bool {
	_, ok := m.clearedFields[transfer.FieldSparkInvoiceID]
	return ok
}

// ResetSparkInvoiceID resets all changes to the "spark_invoice_id" field.
func (m *TransferMutation) ResetSparkInvoiceID() {
	m.spark_invoice = nil
	delete(m.clearedFields, transfer.FieldSparkInvoiceID)
}

// AddTransferLeafeIDs adds the "transfer_leaves" edge to the TransferLeaf entity by ids.
func (m *TransferMutation) AddTransferLeafeIDs(ids ...uuid.UUID) {
	if m.transfer_leaves == nil {
		m.transfer_leaves = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.transfer_leaves[ids[i]] = struct{}{}
	}
}

// ClearTransferLeaves clears the "transfer_leaves" edge to the TransferLeaf entity.
func (m *TransferMutation) ClearTransferLeaves() {
	m.clearedtransfer_leaves = true
}

// TransferLeavesCleared reports if the "transfer_leaves" edge to the TransferLeaf entity was cleared.
func (m *TransferMutation) TransferLeavesCleared() bool {
	return m.clearedtransfer_leaves
}

// RemoveTransferLeafeIDs removes the "transfer_leaves" edge to the TransferLeaf entity by IDs.
func (m *TransferMutation) RemoveTransferLeafeIDs(ids ...uuid.UUID) {
	if m.removedtransfer_leaves == nil {
		m.removedtransfer_leaves = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.transfer_leaves, ids[i])
		m.removedtransfer_leaves[ids[i]] = struct{}{}
	}
}

// RemovedTransferLeaves returns the removed IDs of the "transfer_leaves" edge to the TransferLeaf entity.
func (m *TransferMutation) RemovedTransferLeavesIDs() (ids []uuid.UUID) {
	for id := range m.removedtransfer_leaves {
		ids = append(ids, id)
	}
	return
}

// TransferLeavesIDs returns the "transfer_leaves" edge IDs in the mutation.
func (m *TransferMutation) TransferLeavesIDs() (ids []uuid.UUID) {
	for id := range m.transfer_leaves {
		ids = append(ids, id)
	}
	return
}

// ResetTransferLeaves resets all changes to the "transfer_leaves" edge.
func (m *TransferMutation) ResetTransferLeaves() {
	m.transfer_leaves = nil
	m.clearedtransfer_leaves = false
	m.removedtransfer_leaves = nil
}

// SetPaymentIntentID sets the "payment_intent" edge to the PaymentIntent entity by id.
func (m *TransferMutation) SetPaymentIntentID(id uuid.UUID) {
	m.payment_intent = &id
}

// ClearPaymentIntent clears the "payment_intent" edge to the PaymentIntent entity.
func (m *TransferMutation) ClearPaymentIntent() {
	m.clearedpayment_intent = true
}

// PaymentIntentCleared reports if the "payment_intent" edge to the PaymentIntent entity was cleared.
func (m *TransferMutation) PaymentIntentCleared() bool {
	return m.clearedpayment_intent
}

// PaymentIntentID returns the "payment_intent" edge ID in the mutation.
func (m *TransferMutation) PaymentIntentID() (id uuid.UUID, exists bool) {
	if m.payment_intent != nil {
		return *m.payment_intent, true
	}
	return
}

// PaymentIntentIDs returns the "payment_intent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PaymentIntentID instead. It exists only for internal usage by the builders.
func (m *TransferMutation) PaymentIntentIDs() (ids []uuid.UUID) {
	if id := m.payment_intent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPaymentIntent resets all changes to the "payment_intent" edge.
func (m *TransferMutation) ResetPaymentIntent() {
	m.payment_intent = nil
	m.clearedpayment_intent = false
}

// ClearSparkInvoice clears the "spark_invoice" edge to the SparkInvoice entity.
func (m *TransferMutation) ClearSparkInvoice() {
	m.clearedspark_invoice = true
	m.clearedFields[transfer.FieldSparkInvoiceID] = struct{}{}
}

// SparkInvoiceCleared reports if the "spark_invoice" edge to the SparkInvoice entity was cleared.
func (m *TransferMutation) SparkInvoiceCleared() bool {
	return m.SparkInvoiceIDCleared() || m.clearedspark_invoice
}

// SparkInvoiceIDs returns the "spark_invoice" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SparkInvoiceID instead. It exists only for internal usage by the builders.
func (m *TransferMutation) SparkInvoiceIDs() (ids []uuid.UUID) {
	if id := m.spark_invoice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSparkInvoice resets all changes to the "spark_invoice" edge.
func (m *TransferMutation) ResetSparkInvoice() {
	m.spark_invoice = nil
	m.clearedspark_invoice = false
}

// AddCounterSwapTransferIDs adds the "counter_swap_transfer" edge to the Transfer entity by ids.
func (m *TransferMutation) AddCounterSwapTransferIDs(ids ...uuid.UUID) {
	if m.counter_swap_transfer == nil {
		m.counter_swap_transfer = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.counter_swap_transfer[ids[i]] = struct{}{}
	}
}

// ClearCounterSwapTransfer clears the "counter_swap_transfer" edge to the Transfer entity.
func (m *TransferMutation) ClearCounterSwapTransfer() {
	m.clearedcounter_swap_transfer = true
}

// CounterSwapTransferCleared reports if the "counter_swap_transfer" edge to the Transfer entity was cleared.
func (m *TransferMutation) CounterSwapTransferCleared() bool {
	return m.clearedcounter_swap_transfer
}

// RemoveCounterSwapTransferIDs removes the "counter_swap_transfer" edge to the Transfer entity by IDs.
func (m *TransferMutation) RemoveCounterSwapTransferIDs(ids ...uuid.UUID) {
	if m.removedcounter_swap_transfer == nil {
		m.removedcounter_swap_transfer = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.counter_swap_transfer, ids[i])
		m.removedcounter_swap_transfer[ids[i]] = struct{}{}
	}
}

// RemovedCounterSwapTransfer returns the removed IDs of the "counter_swap_transfer" edge to the Transfer entity.
func (m *TransferMutation) RemovedCounterSwapTransferIDs() (ids []uuid.UUID) {
	for id := range m.removedcounter_swap_transfer {
		ids = append(ids, id)
	}
	return
}

// CounterSwapTransferIDs returns the "counter_swap_transfer" edge IDs in the mutation.
func (m *TransferMutation) CounterSwapTransferIDs() (ids []uuid.UUID) {
	for id := range m.counter_swap_transfer {
		ids = append(ids, id)
	}
	return
}

// ResetCounterSwapTransfer resets all changes to the "counter_swap_transfer" edge.
func (m *TransferMutation) ResetCounterSwapTransfer() {
	m.counter_swap_transfer = nil
	m.clearedcounter_swap_transfer = false
	m.removedcounter_swap_transfer = nil
}

// SetPrimarySwapTransferID sets the "primary_swap_transfer" edge to the Transfer entity by id.
func (m *TransferMutation) SetPrimarySwapTransferID(id uuid.UUID) {
	m.primary_swap_transfer = &id
}

// ClearPrimarySwapTransfer clears the "primary_swap_transfer" edge to the Transfer entity.
func (m *TransferMutation) ClearPrimarySwapTransfer() {
	m.clearedprimary_swap_transfer = true
}

// PrimarySwapTransferCleared reports if the "primary_swap_transfer" edge to the Transfer entity was cleared.
func (m *TransferMutation) PrimarySwapTransferCleared() bool {
	return m.clearedprimary_swap_transfer
}

// PrimarySwapTransferID returns the "primary_swap_transfer" edge ID in the mutation.
func (m *TransferMutation) PrimarySwapTransferID() (id uuid.UUID, exists bool) {
	if m.primary_swap_transfer != nil {
		return *m.primary_swap_transfer, true
	}
	return
}

// PrimarySwapTransferIDs returns the "primary_swap_transfer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrimarySwapTransferID instead. It exists only for internal usage by the builders.
func (m *TransferMutation) PrimarySwapTransferIDs() (ids []uuid.UUID) {
	if id := m.primary_swap_transfer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrimarySwapTransfer resets all changes to the "primary_swap_transfer" edge.
func (m *TransferMutation) ResetPrimarySwapTransfer() {
	m.primary_swap_transfer = nil
	m.clearedprimary_swap_transfer = false
}

// Where appends a list predicates to the TransferMutation builder.
func (m *TransferMutation) Where(ps ...predicate.Transfer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransferMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransferMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transfer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransferMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransferMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transfer).
func (m *TransferMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransferMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, transfer.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, transfer.FieldUpdateTime)
	}
	if m.sender_identity_pubkey != nil {
		fields = append(fields, transfer.FieldSenderIdentityPubkey)
	}
	if m.receiver_identity_pubkey != nil {
		fields = append(fields, transfer.FieldReceiverIdentityPubkey)
	}
	if m.total_value != nil {
		fields = append(fields, transfer.FieldTotalValue)
	}
	if m.status != nil {
		fields = append(fields, transfer.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, transfer.FieldType)
	}
	if m.expiry_time != nil {
		fields = append(fields, transfer.FieldExpiryTime)
	}
	if m.completion_time != nil {
		fields = append(fields, transfer.FieldCompletionTime)
	}
	if m.spark_invoice != nil {
		fields = append(fields, transfer.FieldSparkInvoiceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransferMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transfer.FieldCreateTime:
		return m.CreateTime()
	case transfer.FieldUpdateTime:
		return m.UpdateTime()
	case transfer.FieldSenderIdentityPubkey:
		return m.SenderIdentityPubkey()
	case transfer.FieldReceiverIdentityPubkey:
		return m.ReceiverIdentityPubkey()
	case transfer.FieldTotalValue:
		return m.TotalValue()
	case transfer.FieldStatus:
		return m.Status()
	case transfer.FieldType:
		return m.GetType()
	case transfer.FieldExpiryTime:
		return m.ExpiryTime()
	case transfer.FieldCompletionTime:
		return m.CompletionTime()
	case transfer.FieldSparkInvoiceID:
		return m.SparkInvoiceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransferMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transfer.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case transfer.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case transfer.FieldSenderIdentityPubkey:
		return m.OldSenderIdentityPubkey(ctx)
	case transfer.FieldReceiverIdentityPubkey:
		return m.OldReceiverIdentityPubkey(ctx)
	case transfer.FieldTotalValue:
		return m.OldTotalValue(ctx)
	case transfer.FieldStatus:
		return m.OldStatus(ctx)
	case transfer.FieldType:
		return m.OldType(ctx)
	case transfer.FieldExpiryTime:
		return m.OldExpiryTime(ctx)
	case transfer.FieldCompletionTime:
		return m.OldCompletionTime(ctx)
	case transfer.FieldSparkInvoiceID:
		return m.OldSparkInvoiceID(ctx)
	}
	return nil, fmt.Errorf("unknown Transfer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transfer.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case transfer.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case transfer.FieldSenderIdentityPubkey:
		v, ok := value.(keys.Public)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderIdentityPubkey(v)
		return nil
	case transfer.FieldReceiverIdentityPubkey:
		v, ok := value.(keys.Public)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverIdentityPubkey(v)
		return nil
	case transfer.FieldTotalValue:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalValue(v)
		return nil
	case transfer.FieldStatus:
		v, ok := value.(schematype.TransferStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case transfer.FieldType:
		v, ok := value.(schematype.TransferType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case transfer.FieldExpiryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiryTime(v)
		return nil
	case transfer.FieldCompletionTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionTime(v)
		return nil
	case transfer.FieldSparkInvoiceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSparkInvoiceID(v)
		return nil
	}
	return fmt.Errorf("unknown Transfer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransferMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_value != nil {
		fields = append(fields, transfer.FieldTotalValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransferMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transfer.FieldTotalValue:
		return m.AddedTotalValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transfer.FieldTotalValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalValue(v)
		return nil
	}
	return fmt.Errorf("unknown Transfer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransferMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transfer.FieldCompletionTime) {
		fields = append(fields, transfer.FieldCompletionTime)
	}
	if m.FieldCleared(transfer.FieldSparkInvoiceID) {
		fields = append(fields, transfer.FieldSparkInvoiceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransferMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransferMutation) ClearField(name string) error {
	switch name {
	case transfer.FieldCompletionTime:
		m.ClearCompletionTime()
		return nil
	case transfer.FieldSparkInvoiceID:
		m.ClearSparkInvoiceID()
		return nil
	}
	return fmt.Errorf("unknown Transfer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransferMutation) ResetField(name string) error {
	switch name {
	case transfer.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case transfer.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case transfer.FieldSenderIdentityPubkey:
		m.ResetSenderIdentityPubkey()
		return nil
	case transfer.FieldReceiverIdentityPubkey:
		m.ResetReceiverIdentityPubkey()
		return nil
	case transfer.FieldTotalValue:
		m.ResetTotalValue()
		return nil
	case transfer.FieldStatus:
		m.ResetStatus()
		return nil
	case transfer.FieldType:
		m.ResetType()
		return nil
	case transfer.FieldExpiryTime:
		m.ResetExpiryTime()
		return nil
	case transfer.FieldCompletionTime:
		m.ResetCompletionTime()
		return nil
	case transfer.FieldSparkInvoiceID:
		m.ResetSparkInvoiceID()
		return nil
	}
	return fmt.Errorf("unknown Transfer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransferMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.transfer_leaves != nil {
		edges = append(edges, transfer.EdgeTransferLeaves)
	}
	if m.payment_intent != nil {
		edges = append(edges, transfer.EdgePaymentIntent)
	}
	if m.spark_invoice != nil {
		edges = append(edges, transfer.EdgeSparkInvoice)
	}
	if m.counter_swap_transfer != nil {
		edges = append(edges, transfer.EdgeCounterSwapTransfer)
	}
	if m.primary_swap_transfer != nil {
		edges = append(edges, transfer.EdgePrimarySwapTransfer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransferMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transfer.EdgeTransferLeaves:
		ids := make([]ent.Value, 0, len(m.transfer_leaves))
		for id := range m.transfer_leaves {
			ids = append(ids, id)
		}
		return ids
	case transfer.EdgePaymentIntent:
		if id := m.payment_intent; id != nil {
			return []ent.Value{*id}
		}
	case transfer.EdgeSparkInvoice:
		if id := m.spark_invoice; id != nil {
			return []ent.Value{*id}
		}
	case transfer.EdgeCounterSwapTransfer:
		ids := make([]ent.Value, 0, len(m.counter_swap_transfer))
		for id := range m.counter_swap_transfer {
			ids = append(ids, id)
		}
		return ids
	case transfer.EdgePrimarySwapTransfer:
		if id := m.primary_swap_transfer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransferMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtransfer_leaves != nil {
		edges = append(edges, transfer.EdgeTransferLeaves)
	}
	if m.removedcounter_swap_transfer != nil {
		edges = append(edges, transfer.EdgeCounterSwapTransfer)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransferMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transfer.EdgeTransferLeaves:
		ids := make([]ent.Value, 0, len(m.removedtransfer_leaves))
		for id := range m.removedtransfer_leaves {
			ids = append(ids, id)
		}
		return ids
	case transfer.EdgeCounterSwapTransfer:
		ids := make([]ent.Value, 0, len(m.removedcounter_swap_transfer))
		for id := range m.removedcounter_swap_transfer {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransferMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtransfer_leaves {
		edges = append(edges, transfer.EdgeTransferLeaves)
	}
	if m.clearedpayment_intent {
		edges = append(edges, transfer.EdgePaymentIntent)
	}
	if m.clearedspark_invoice {
		edges = append(edges, transfer.EdgeSparkInvoice)
	}
	if m.clearedcounter_swap_transfer {
		edges = append(edges, transfer.EdgeCounterSwapTransfer)
	}
	if m.clearedprimary_swap_transfer {
		edges = append(edges, transfer.EdgePrimarySwapTransfer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransferMutation) EdgeCleared(name string) bool {
	switch name {
	case transfer.EdgeTransferLeaves:
		return m.clearedtransfer_leaves
	case transfer.EdgePaymentIntent:
		return m.clearedpayment_intent
	case transfer.EdgeSparkInvoice:
		return m.clearedspark_invoice
	case transfer.EdgeCounterSwapTransfer:
		return m.clearedcounter_swap_transfer
	case transfer.EdgePrimarySwapTransfer:
		return m.clearedprimary_swap_transfer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransferMutation) ClearEdge(name string) error {
	switch name {
	case transfer.EdgePaymentIntent:
		m.ClearPaymentIntent()
		return nil
	case transfer.EdgeSparkInvoice:
		m.ClearSparkInvoice()
		return nil
	case transfer.EdgePrimarySwapTransfer:
		m.ClearPrimarySwapTransfer()
		return nil
	}
	return fmt.Errorf("unknown Transfer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransferMutation) ResetEdge(name string) error {
	switch name {
	case transfer.EdgeTransferLeaves:
		m.ResetTransferLeaves()
		return nil
	case transfer.EdgePaymentIntent:
		m.ResetPaymentIntent()
		return nil
	case transfer.EdgeSparkInvoice:
		m.ResetSparkInvoice()
		return nil
	case transfer.EdgeCounterSwapTransfer:
		m.ResetCounterSwapTransfer()
		return nil
	case transfer.EdgePrimarySwapTransfer:
		m.ResetPrimarySwapTransfer()
		return nil
	}
	return fmt.Errorf("unknown Transfer edge %s", name)
}

// TransferLeafMutation represents an operation that mutates the TransferLeaf nodes in the graph.
type TransferLeafMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *uuid.UUID
	create_time                             *time.Time
	update_time                             *time.Time
	secret_cipher                           *[]byte
	signature                               *[]byte
	previous_refund_tx                      *[]byte
	previous_direct_refund_tx               *[]byte
	previous_direct_from_cpfp_refund_tx     *[]byte
	intermediate_refund_tx                  *[]byte
	intermediate_direct_refund_tx           *[]byte
	intermediate_direct_from_cpfp_refund_tx *[]byte
	key_tweak                               *[]byte
	sender_key_tweak_proof                  *[]byte
	receiver_key_tweak                      *[]byte
	clearedFields                           map[string]struct{}
	transfer                                *uuid.UUID
	clearedtransfer                         bool
	leaf                                    *uuid.UUID
	clearedleaf                             bool
	done                                    bool
	oldValue                                func(context.Context) (*TransferLeaf, error)
	predicates                              []predicate.TransferLeaf
}

var _ ent.Mutation = (*TransferLeafMutation)(nil)

// transferleafOption allows management of the mutation configuration using functional options.
type transferleafOption func(*TransferLeafMutation)

// newTransferLeafMutation creates new mutation for the TransferLeaf entity.
func newTransferLeafMutation(c config, op Op, opts ...transferleafOption) *TransferLeafMutation {
	m := &TransferLeafMutation{
		config:        c,
		op:            op,
		typ:           TypeTransferLeaf,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransferLeafID sets the ID field of the mutation.
func withTransferLeafID(id uuid.UUID) transferleafOption {
	return func(m *TransferLeafMutation) {
		var (
			err   error
			once  sync.Once
			value *TransferLeaf
		)
		m.oldValue = func(ctx context.Context) (*TransferLeaf, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransferLeaf.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransferLeaf sets the old TransferLeaf of the mutation.
func withTransferLeaf(node *TransferLeaf) transferleafOption {
	return func(m *TransferLeafMutation) {
		m.oldValue = func(context.Context) (*TransferLeaf, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransferLeafMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransferLeafMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TransferLeaf entities.
func (m *TransferLeafMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransferLeafMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransferLeafMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TransferLeaf.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TransferLeafMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TransferLeafMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TransferLeafMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TransferLeafMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TransferLeafMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TransferLeafMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetSecretCipher sets the "secret_cipher" field.
func (m *TransferLeafMutation) SetSecretCipher(b []byte) {
	m.secret_cipher = &b
}

// SecretCipher returns the value of the "secret_cipher" field in the mutation.
func (m *TransferLeafMutation) SecretCipher() (r []byte, exists bool) {
	v := m.secret_cipher
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretCipher returns the old "secret_cipher" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldSecretCipher(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretCipher is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretCipher requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretCipher: %w", err)
	}
	return oldValue.SecretCipher, nil
}

// ClearSecretCipher clears the value of the "secret_cipher" field.
func (m *TransferLeafMutation) ClearSecretCipher() {
	m.secret_cipher = nil
	m.clearedFields[transferleaf.FieldSecretCipher] = struct{}{}
}

// SecretCipherCleared returns if the "secret_cipher" field was cleared in this mutation.
func (m *TransferLeafMutation) SecretCipherCleared() bool {
	_, ok := m.clearedFields[transferleaf.FieldSecretCipher]
	return ok
}

// ResetSecretCipher resets all changes to the "secret_cipher" field.
func (m *TransferLeafMutation) ResetSecretCipher() {
	m.secret_cipher = nil
	delete(m.clearedFields, transferleaf.FieldSecretCipher)
}

// SetSignature sets the "signature" field.
func (m *TransferLeafMutation) SetSignature(b []byte) {
	m.signature = &b
}

// Signature returns the value of the "signature" field in the mutation.
func (m *TransferLeafMutation) Signature() (r []byte, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *TransferLeafMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[transferleaf.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *TransferLeafMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[transferleaf.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *TransferLeafMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, transferleaf.FieldSignature)
}

// SetPreviousRefundTx sets the "previous_refund_tx" field.
func (m *TransferLeafMutation) SetPreviousRefundTx(b []byte) {
	m.previous_refund_tx = &b
}

// PreviousRefundTx returns the value of the "previous_refund_tx" field in the mutation.
func (m *TransferLeafMutation) PreviousRefundTx() (r []byte, exists bool) {
	v := m.previous_refund_tx
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviousRefundTx returns the old "previous_refund_tx" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldPreviousRefundTx(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviousRefundTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviousRefundTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviousRefundTx: %w", err)
	}
	return oldValue.PreviousRefundTx, nil
}

// ResetPreviousRefundTx resets all changes to the "previous_refund_tx" field.
func (m *TransferLeafMutation) ResetPreviousRefundTx() {
	m.previous_refund_tx = nil
}

// SetPreviousDirectRefundTx sets the "previous_direct_refund_tx" field.
func (m *TransferLeafMutation) SetPreviousDirectRefundTx(b []byte) {
	m.previous_direct_refund_tx = &b
}

// PreviousDirectRefundTx returns the value of the "previous_direct_refund_tx" field in the mutation.
func (m *TransferLeafMutation) PreviousDirectRefundTx() (r []byte, exists bool) {
	v := m.previous_direct_refund_tx
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviousDirectRefundTx returns the old "previous_direct_refund_tx" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldPreviousDirectRefundTx(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviousDirectRefundTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviousDirectRefundTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviousDirectRefundTx: %w", err)
	}
	return oldValue.PreviousDirectRefundTx, nil
}

// ClearPreviousDirectRefundTx clears the value of the "previous_direct_refund_tx" field.
func (m *TransferLeafMutation) ClearPreviousDirectRefundTx() {
	m.previous_direct_refund_tx = nil
	m.clearedFields[transferleaf.FieldPreviousDirectRefundTx] = struct{}{}
}

// PreviousDirectRefundTxCleared returns if the "previous_direct_refund_tx" field was cleared in this mutation.
func (m *TransferLeafMutation) PreviousDirectRefundTxCleared() bool {
	_, ok := m.clearedFields[transferleaf.FieldPreviousDirectRefundTx]
	return ok
}

// ResetPreviousDirectRefundTx resets all changes to the "previous_direct_refund_tx" field.
func (m *TransferLeafMutation) ResetPreviousDirectRefundTx() {
	m.previous_direct_refund_tx = nil
	delete(m.clearedFields, transferleaf.FieldPreviousDirectRefundTx)
}

// SetPreviousDirectFromCpfpRefundTx sets the "previous_direct_from_cpfp_refund_tx" field.
func (m *TransferLeafMutation) SetPreviousDirectFromCpfpRefundTx(b []byte) {
	m.previous_direct_from_cpfp_refund_tx = &b
}

// PreviousDirectFromCpfpRefundTx returns the value of the "previous_direct_from_cpfp_refund_tx" field in the mutation.
func (m *TransferLeafMutation) PreviousDirectFromCpfpRefundTx() (r []byte, exists bool) {
	v := m.previous_direct_from_cpfp_refund_tx
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviousDirectFromCpfpRefundTx returns the old "previous_direct_from_cpfp_refund_tx" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldPreviousDirectFromCpfpRefundTx(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviousDirectFromCpfpRefundTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviousDirectFromCpfpRefundTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviousDirectFromCpfpRefundTx: %w", err)
	}
	return oldValue.PreviousDirectFromCpfpRefundTx, nil
}

// ClearPreviousDirectFromCpfpRefundTx clears the value of the "previous_direct_from_cpfp_refund_tx" field.
func (m *TransferLeafMutation) ClearPreviousDirectFromCpfpRefundTx() {
	m.previous_direct_from_cpfp_refund_tx = nil
	m.clearedFields[transferleaf.FieldPreviousDirectFromCpfpRefundTx] = struct{}{}
}

// PreviousDirectFromCpfpRefundTxCleared returns if the "previous_direct_from_cpfp_refund_tx" field was cleared in this mutation.
func (m *TransferLeafMutation) PreviousDirectFromCpfpRefundTxCleared() bool {
	_, ok := m.clearedFields[transferleaf.FieldPreviousDirectFromCpfpRefundTx]
	return ok
}

// ResetPreviousDirectFromCpfpRefundTx resets all changes to the "previous_direct_from_cpfp_refund_tx" field.
func (m *TransferLeafMutation) ResetPreviousDirectFromCpfpRefundTx() {
	m.previous_direct_from_cpfp_refund_tx = nil
	delete(m.clearedFields, transferleaf.FieldPreviousDirectFromCpfpRefundTx)
}

// SetIntermediateRefundTx sets the "intermediate_refund_tx" field.
func (m *TransferLeafMutation) SetIntermediateRefundTx(b []byte) {
	m.intermediate_refund_tx = &b
}

// IntermediateRefundTx returns the value of the "intermediate_refund_tx" field in the mutation.
func (m *TransferLeafMutation) IntermediateRefundTx() (r []byte, exists bool) {
	v := m.intermediate_refund_tx
	if v == nil {
		return
	}
	return *v, true
}

// OldIntermediateRefundTx returns the old "intermediate_refund_tx" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldIntermediateRefundTx(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntermediateRefundTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntermediateRefundTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntermediateRefundTx: %w", err)
	}
	return oldValue.IntermediateRefundTx, nil
}

// ResetIntermediateRefundTx resets all changes to the "intermediate_refund_tx" field.
func (m *TransferLeafMutation) ResetIntermediateRefundTx() {
	m.intermediate_refund_tx = nil
}

// SetIntermediateDirectRefundTx sets the "intermediate_direct_refund_tx" field.
func (m *TransferLeafMutation) SetIntermediateDirectRefundTx(b []byte) {
	m.intermediate_direct_refund_tx = &b
}

// IntermediateDirectRefundTx returns the value of the "intermediate_direct_refund_tx" field in the mutation.
func (m *TransferLeafMutation) IntermediateDirectRefundTx() (r []byte, exists bool) {
	v := m.intermediate_direct_refund_tx
	if v == nil {
		return
	}
	return *v, true
}

// OldIntermediateDirectRefundTx returns the old "intermediate_direct_refund_tx" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldIntermediateDirectRefundTx(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntermediateDirectRefundTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntermediateDirectRefundTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntermediateDirectRefundTx: %w", err)
	}
	return oldValue.IntermediateDirectRefundTx, nil
}

// ClearIntermediateDirectRefundTx clears the value of the "intermediate_direct_refund_tx" field.
func (m *TransferLeafMutation) ClearIntermediateDirectRefundTx() {
	m.intermediate_direct_refund_tx = nil
	m.clearedFields[transferleaf.FieldIntermediateDirectRefundTx] = struct{}{}
}

// IntermediateDirectRefundTxCleared returns if the "intermediate_direct_refund_tx" field was cleared in this mutation.
func (m *TransferLeafMutation) IntermediateDirectRefundTxCleared() bool {
	_, ok := m.clearedFields[transferleaf.FieldIntermediateDirectRefundTx]
	return ok
}

// ResetIntermediateDirectRefundTx resets all changes to the "intermediate_direct_refund_tx" field.
func (m *TransferLeafMutation) ResetIntermediateDirectRefundTx() {
	m.intermediate_direct_refund_tx = nil
	delete(m.clearedFields, transferleaf.FieldIntermediateDirectRefundTx)
}

// SetIntermediateDirectFromCpfpRefundTx sets the "intermediate_direct_from_cpfp_refund_tx" field.
func (m *TransferLeafMutation) SetIntermediateDirectFromCpfpRefundTx(b []byte) {
	m.intermediate_direct_from_cpfp_refund_tx = &b
}

// IntermediateDirectFromCpfpRefundTx returns the value of the "intermediate_direct_from_cpfp_refund_tx" field in the mutation.
func (m *TransferLeafMutation) IntermediateDirectFromCpfpRefundTx() (r []byte, exists bool) {
	v := m.intermediate_direct_from_cpfp_refund_tx
	if v == nil {
		return
	}
	return *v, true
}

// OldIntermediateDirectFromCpfpRefundTx returns the old "intermediate_direct_from_cpfp_refund_tx" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldIntermediateDirectFromCpfpRefundTx(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntermediateDirectFromCpfpRefundTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntermediateDirectFromCpfpRefundTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntermediateDirectFromCpfpRefundTx: %w", err)
	}
	return oldValue.IntermediateDirectFromCpfpRefundTx, nil
}

// ClearIntermediateDirectFromCpfpRefundTx clears the value of the "intermediate_direct_from_cpfp_refund_tx" field.
func (m *TransferLeafMutation) ClearIntermediateDirectFromCpfpRefundTx() {
	m.intermediate_direct_from_cpfp_refund_tx = nil
	m.clearedFields[transferleaf.FieldIntermediateDirectFromCpfpRefundTx] = struct{}{}
}

// IntermediateDirectFromCpfpRefundTxCleared returns if the "intermediate_direct_from_cpfp_refund_tx" field was cleared in this mutation.
func (m *TransferLeafMutation) IntermediateDirectFromCpfpRefundTxCleared() bool {
	_, ok := m.clearedFields[transferleaf.FieldIntermediateDirectFromCpfpRefundTx]
	return ok
}

// ResetIntermediateDirectFromCpfpRefundTx resets all changes to the "intermediate_direct_from_cpfp_refund_tx" field.
func (m *TransferLeafMutation) ResetIntermediateDirectFromCpfpRefundTx() {
	m.intermediate_direct_from_cpfp_refund_tx = nil
	delete(m.clearedFields, transferleaf.FieldIntermediateDirectFromCpfpRefundTx)
}

// SetKeyTweak sets the "key_tweak" field.
func (m *TransferLeafMutation) SetKeyTweak(b []byte) {
	m.key_tweak = &b
}

// KeyTweak returns the value of the "key_tweak" field in the mutation.
func (m *TransferLeafMutation) KeyTweak() (r []byte, exists bool) {
	v := m.key_tweak
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyTweak returns the old "key_tweak" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldKeyTweak(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyTweak is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyTweak requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyTweak: %w", err)
	}
	return oldValue.KeyTweak, nil
}

// ClearKeyTweak clears the value of the "key_tweak" field.
func (m *TransferLeafMutation) ClearKeyTweak() {
	m.key_tweak = nil
	m.clearedFields[transferleaf.FieldKeyTweak] = struct{}{}
}

// KeyTweakCleared returns if the "key_tweak" field was cleared in this mutation.
func (m *TransferLeafMutation) KeyTweakCleared() bool {
	_, ok := m.clearedFields[transferleaf.FieldKeyTweak]
	return ok
}

// ResetKeyTweak resets all changes to the "key_tweak" field.
func (m *TransferLeafMutation) ResetKeyTweak() {
	m.key_tweak = nil
	delete(m.clearedFields, transferleaf.FieldKeyTweak)
}

// SetSenderKeyTweakProof sets the "sender_key_tweak_proof" field.
func (m *TransferLeafMutation) SetSenderKeyTweakProof(b []byte) {
	m.sender_key_tweak_proof = &b
}

// SenderKeyTweakProof returns the value of the "sender_key_tweak_proof" field in the mutation.
func (m *TransferLeafMutation) SenderKeyTweakProof() (r []byte, exists bool) {
	v := m.sender_key_tweak_proof
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderKeyTweakProof returns the old "sender_key_tweak_proof" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldSenderKeyTweakProof(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderKeyTweakProof is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderKeyTweakProof requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderKeyTweakProof: %w", err)
	}
	return oldValue.SenderKeyTweakProof, nil
}

// ClearSenderKeyTweakProof clears the value of the "sender_key_tweak_proof" field.
func (m *TransferLeafMutation) ClearSenderKeyTweakProof() {
	m.sender_key_tweak_proof = nil
	m.clearedFields[transferleaf.FieldSenderKeyTweakProof] = struct{}{}
}

// SenderKeyTweakProofCleared returns if the "sender_key_tweak_proof" field was cleared in this mutation.
func (m *TransferLeafMutation) SenderKeyTweakProofCleared() bool {
	_, ok := m.clearedFields[transferleaf.FieldSenderKeyTweakProof]
	return ok
}

// ResetSenderKeyTweakProof resets all changes to the "sender_key_tweak_proof" field.
func (m *TransferLeafMutation) ResetSenderKeyTweakProof() {
	m.sender_key_tweak_proof = nil
	delete(m.clearedFields, transferleaf.FieldSenderKeyTweakProof)
}

// SetReceiverKeyTweak sets the "receiver_key_tweak" field.
func (m *TransferLeafMutation) SetReceiverKeyTweak(b []byte) {
	m.receiver_key_tweak = &b
}

// ReceiverKeyTweak returns the value of the "receiver_key_tweak" field in the mutation.
func (m *TransferLeafMutation) ReceiverKeyTweak() (r []byte, exists bool) {
	v := m.receiver_key_tweak
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverKeyTweak returns the old "receiver_key_tweak" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldReceiverKeyTweak(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverKeyTweak is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverKeyTweak requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverKeyTweak: %w", err)
	}
	return oldValue.ReceiverKeyTweak, nil
}

// ClearReceiverKeyTweak clears the value of the "receiver_key_tweak" field.
func (m *TransferLeafMutation) ClearReceiverKeyTweak() {
	m.receiver_key_tweak = nil
	m.clearedFields[transferleaf.FieldReceiverKeyTweak] = struct{}{}
}

// ReceiverKeyTweakCleared returns if the "receiver_key_tweak" field was cleared in this mutation.
func (m *TransferLeafMutation) ReceiverKeyTweakCleared() bool {
	_, ok := m.clearedFields[transferleaf.FieldReceiverKeyTweak]
	return ok
}

// ResetReceiverKeyTweak resets all changes to the "receiver_key_tweak" field.
func (m *TransferLeafMutation) ResetReceiverKeyTweak() {
	m.receiver_key_tweak = nil
	delete(m.clearedFields, transferleaf.FieldReceiverKeyTweak)
}

// SetTransferID sets the "transfer" edge to the Transfer entity by id.
func (m *TransferLeafMutation) SetTransferID(id uuid.UUID) {
	m.transfer = &id
}

// ClearTransfer clears the "transfer" edge to the Transfer entity.
func (m *TransferLeafMutation) ClearTransfer() {
	m.clearedtransfer = true
}

// TransferCleared reports if the "transfer" edge to the Transfer entity was cleared.
func (m *TransferLeafMutation) TransferCleared() bool {
	return m.clearedtransfer
}

// TransferID returns the "transfer" edge ID in the mutation.
func (m *TransferLeafMutation) TransferID() (id uuid.UUID, exists bool) {
	if m.transfer != nil {
		return *m.transfer, true
	}
	return
}

// TransferIDs returns the "transfer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransferID instead. It exists only for internal usage by the builders.
func (m *TransferLeafMutation) TransferIDs() (ids []uuid.UUID) {
	if id := m.transfer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransfer resets all changes to the "transfer" edge.
func (m *TransferLeafMutation) ResetTransfer() {
	m.transfer = nil
	m.clearedtransfer = false
}

// SetLeafID sets the "leaf" edge to the TreeNode entity by id.
func (m *TransferLeafMutation) SetLeafID(id uuid.UUID) {
	m.leaf = &id
}

// ClearLeaf clears the "leaf" edge to the TreeNode entity.
func (m *TransferLeafMutation) ClearLeaf() {
	m.clearedleaf = true
}

// LeafCleared reports if the "leaf" edge to the TreeNode entity was cleared.
func (m *TransferLeafMutation) LeafCleared() bool {
	return m.clearedleaf
}

// LeafID returns the "leaf" edge ID in the mutation.
func (m *TransferLeafMutation) LeafID() (id uuid.UUID, exists bool) {
	if m.leaf != nil {
		return *m.leaf, true
	}
	return
}

// LeafIDs returns the "leaf" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeafID instead. It exists only for internal usage by the builders.
func (m *TransferLeafMutation) LeafIDs() (ids []uuid.UUID) {
	if id := m.leaf; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeaf resets all changes to the "leaf" edge.
func (m *TransferLeafMutation) ResetLeaf() {
	m.leaf = nil
	m.clearedleaf = false
}

// Where appends a list predicates to the TransferLeafMutation builder.
func (m *TransferLeafMutation) Where(ps ...predicate.TransferLeaf) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransferLeafMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransferLeafMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TransferLeaf, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransferLeafMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransferLeafMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TransferLeaf).
func (m *TransferLeafMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransferLeafMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.create_time != nil {
		fields = append(fields, transferleaf.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, transferleaf.FieldUpdateTime)
	}
	if m.secret_cipher != nil {
		fields = append(fields, transferleaf.FieldSecretCipher)
	}
	if m.signature != nil {
		fields = append(fields, transferleaf.FieldSignature)
	}
	if m.previous_refund_tx != nil {
		fields = append(fields, transferleaf.FieldPreviousRefundTx)
	}
	if m.previous_direct_refund_tx != nil {
		fields = append(fields, transferleaf.FieldPreviousDirectRefundTx)
	}
	if m.previous_direct_from_cpfp_refund_tx != nil {
		fields = append(fields, transferleaf.FieldPreviousDirectFromCpfpRefundTx)
	}
	if m.intermediate_refund_tx != nil {
		fields = append(fields, transferleaf.FieldIntermediateRefundTx)
	}
	if m.intermediate_direct_refund_tx != nil {
		fields = append(fields, transferleaf.FieldIntermediateDirectRefundTx)
	}
	if m.intermediate_direct_from_cpfp_refund_tx != nil {
		fields = append(fields, transferleaf.FieldIntermediateDirectFromCpfpRefundTx)
	}
	if m.key_tweak != nil {
		fields = append(fields, transferleaf.FieldKeyTweak)
	}
	if m.sender_key_tweak_proof != nil {
		fields = append(fields, transferleaf.FieldSenderKeyTweakProof)
	}
	if m.receiver_key_tweak != nil {
		fields = append(fields, transferleaf.FieldReceiverKeyTweak)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransferLeafMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transferleaf.FieldCreateTime:
		return m.CreateTime()
	case transferleaf.FieldUpdateTime:
		return m.UpdateTime()
	case transferleaf.FieldSecretCipher:
		return m.SecretCipher()
	case transferleaf.FieldSignature:
		return m.Signature()
	case transferleaf.FieldPreviousRefundTx:
		return m.PreviousRefundTx()
	case transferleaf.FieldPreviousDirectRefundTx:
		return m.PreviousDirectRefundTx()
	case transferleaf.FieldPreviousDirectFromCpfpRefundTx:
		return m.PreviousDirectFromCpfpRefundTx()
	case transferleaf.FieldIntermediateRefundTx:
		return m.IntermediateRefundTx()
	case transferleaf.FieldIntermediateDirectRefundTx:
		return m.IntermediateDirectRefundTx()
	case transferleaf.FieldIntermediateDirectFromCpfpRefundTx:
		return m.IntermediateDirectFromCpfpRefundTx()
	case transferleaf.FieldKeyTweak:
		return m.KeyTweak()
	case transferleaf.FieldSenderKeyTweakProof:
		return m.SenderKeyTweakProof()
	case transferleaf.FieldReceiverKeyTweak:
		return m.ReceiverKeyTweak()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransferLeafMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transferleaf.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case transferleaf.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case transferleaf.FieldSecretCipher:
		return m.OldSecretCipher(ctx)
	case transferleaf.FieldSignature:
		return m.OldSignature(ctx)
	case transferleaf.FieldPreviousRefundTx:
		return m.OldPreviousRefundTx(ctx)
	case transferleaf.FieldPreviousDirectRefundTx:
		return m.OldPreviousDirectRefundTx(ctx)
	case transferleaf.FieldPreviousDirectFromCpfpRefundTx:
		return m.OldPreviousDirectFromCpfpRefundTx(ctx)
	case transferleaf.FieldIntermediateRefundTx:
		return m.OldIntermediateRefundTx(ctx)
	case transferleaf.FieldIntermediateDirectRefundTx:
		return m.OldIntermediateDirectRefundTx(ctx)
	case transferleaf.FieldIntermediateDirectFromCpfpRefundTx:
		return m.OldIntermediateDirectFromCpfpRefundTx(ctx)
	case transferleaf.FieldKeyTweak:
		return m.OldKeyTweak(ctx)
	case transferleaf.FieldSenderKeyTweakProof:
		return m.OldSenderKeyTweakProof(ctx)
	case transferleaf.FieldReceiverKeyTweak:
		return m.OldReceiverKeyTweak(ctx)
	}
	return nil, fmt.Errorf("unknown TransferLeaf field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferLeafMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transferleaf.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case transferleaf.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case transferleaf.FieldSecretCipher:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretCipher(v)
		return nil
	case transferleaf.FieldSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case transferleaf.FieldPreviousRefundTx:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviousRefundTx(v)
		return nil
	case transferleaf.FieldPreviousDirectRefundTx:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviousDirectRefundTx(v)
		return nil
	case transferleaf.FieldPreviousDirectFromCpfpRefundTx:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviousDirectFromCpfpRefundTx(v)
		return nil
	case transferleaf.FieldIntermediateRefundTx:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntermediateRefundTx(v)
		return nil
	case transferleaf.FieldIntermediateDirectRefundTx:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntermediateDirectRefundTx(v)
		return nil
	case transferleaf.FieldIntermediateDirectFromCpfpRefundTx:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntermediateDirectFromCpfpRefundTx(v)
		return nil
	case transferleaf.FieldKeyTweak:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyTweak(v)
		return nil
	case transferleaf.FieldSenderKeyTweakProof:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderKeyTweakProof(v)
		return nil
	case transferleaf.FieldReceiverKeyTweak:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverKeyTweak(v)
		return nil
	}
	return fmt.Errorf("unknown TransferLeaf field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransferLeafMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransferLeafMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferLeafMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TransferLeaf numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransferLeafMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transferleaf.FieldSecretCipher) {
		fields = append(fields, transferleaf.FieldSecretCipher)
	}
	if m.FieldCleared(transferleaf.FieldSignature) {
		fields = append(fields, transferleaf.FieldSignature)
	}
	if m.FieldCleared(transferleaf.FieldPreviousDirectRefundTx) {
		fields = append(fields, transferleaf.FieldPreviousDirectRefundTx)
	}
	if m.FieldCleared(transferleaf.FieldPreviousDirectFromCpfpRefundTx) {
		fields = append(fields, transferleaf.FieldPreviousDirectFromCpfpRefundTx)
	}
	if m.FieldCleared(transferleaf.FieldIntermediateDirectRefundTx) {
		fields = append(fields, transferleaf.FieldIntermediateDirectRefundTx)
	}
	if m.FieldCleared(transferleaf.FieldIntermediateDirectFromCpfpRefundTx) {
		fields = append(fields, transferleaf.FieldIntermediateDirectFromCpfpRefundTx)
	}
	if m.FieldCleared(transferleaf.FieldKeyTweak) {
		fields = append(fields, transferleaf.FieldKeyTweak)
	}
	if m.FieldCleared(transferleaf.FieldSenderKeyTweakProof) {
		fields = append(fields, transferleaf.FieldSenderKeyTweakProof)
	}
	if m.FieldCleared(transferleaf.FieldReceiverKeyTweak) {
		fields = append(fields, transferleaf.FieldReceiverKeyTweak)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransferLeafMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransferLeafMutation) ClearField(name string) error {
	switch name {
	case transferleaf.FieldSecretCipher:
		m.ClearSecretCipher()
		return nil
	case transferleaf.FieldSignature:
		m.ClearSignature()
		return nil
	case transferleaf.FieldPreviousDirectRefundTx:
		m.ClearPreviousDirectRefundTx()
		return nil
	case transferleaf.FieldPreviousDirectFromCpfpRefundTx:
		m.ClearPreviousDirectFromCpfpRefundTx()
		return nil
	case transferleaf.FieldIntermediateDirectRefundTx:
		m.ClearIntermediateDirectRefundTx()
		return nil
	case transferleaf.FieldIntermediateDirectFromCpfpRefundTx:
		m.ClearIntermediateDirectFromCpfpRefundTx()
		return nil
	case transferleaf.FieldKeyTweak:
		m.ClearKeyTweak()
		return nil
	case transferleaf.FieldSenderKeyTweakProof:
		m.ClearSenderKeyTweakProof()
		return nil
	case transferleaf.FieldReceiverKeyTweak:
		m.ClearReceiverKeyTweak()
		return nil
	}
	return fmt.Errorf("unknown TransferLeaf nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransferLeafMutation) ResetField(name string) error {
	switch name {
	case transferleaf.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case transferleaf.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case transferleaf.FieldSecretCipher:
		m.ResetSecretCipher()
		return nil
	case transferleaf.FieldSignature:
		m.ResetSignature()
		return nil
	case transferleaf.FieldPreviousRefundTx:
		m.ResetPreviousRefundTx()
		return nil
	case transferleaf.FieldPreviousDirectRefundTx:
		m.ResetPreviousDirectRefundTx()
		return nil
	case transferleaf.FieldPreviousDirectFromCpfpRefundTx:
		m.ResetPreviousDirectFromCpfpRefundTx()
		return nil
	case transferleaf.FieldIntermediateRefundTx:
		m.ResetIntermediateRefundTx()
		return nil
	case transferleaf.FieldIntermediateDirectRefundTx:
		m.ResetIntermediateDirectRefundTx()
		return nil
	case transferleaf.FieldIntermediateDirectFromCpfpRefundTx:
		m.ResetIntermediateDirectFromCpfpRefundTx()
		return nil
	case transferleaf.FieldKeyTweak:
		m.ResetKeyTweak()
		return nil
	case transferleaf.FieldSenderKeyTweakProof:
		m.ResetSenderKeyTweakProof()
		return nil
	case transferleaf.FieldReceiverKeyTweak:
		m.ResetReceiverKeyTweak()
		return nil
	}
	return fmt.Errorf("unknown TransferLeaf field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransferLeafMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.transfer != nil {
		edges = append(edges, transferleaf.EdgeTransfer)
	}
	if m.leaf != nil {
		edges = append(edges, transferleaf.EdgeLeaf)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransferLeafMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transferleaf.EdgeTransfer:
		if id := m.transfer; id != nil {
			return []ent.Value{*id}
		}
	case transferleaf.EdgeLeaf:
		if id := m.leaf; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransferLeafMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransferLeafMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransferLeafMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtransfer {
		edges = append(edges, transferleaf.EdgeTransfer)
	}
	if m.clearedleaf {
		edges = append(edges, transferleaf.EdgeLeaf)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransferLeafMutation) EdgeCleared(name string) bool {
	switch name {
	case transferleaf.EdgeTransfer:
		return m.clearedtransfer
	case transferleaf.EdgeLeaf:
		return m.clearedleaf
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransferLeafMutation) ClearEdge(name string) error {
	switch name {
	case transferleaf.EdgeTransfer:
		m.ClearTransfer()
		return nil
	case transferleaf.EdgeLeaf:
		m.ClearLeaf()
		return nil
	}
	return fmt.Errorf("unknown TransferLeaf unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransferLeafMutation) ResetEdge(name string) error {
	switch name {
	case transferleaf.EdgeTransfer:
		m.ResetTransfer()
		return nil
	case transferleaf.EdgeLeaf:
		m.ResetLeaf()
		return nil
	}
	return fmt.Errorf("unknown TransferLeaf edge %s", name)
}

// TreeMutation represents an operation that mutates the Tree nodes in the graph.
type TreeMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	create_time            *time.Time
	update_time            *time.Time
	owner_identity_pubkey  *keys.Public
	status                 *schematype.TreeStatus
	network                *schematype.Network
	base_txid              *[]byte
	vout                   *int16
	addvout                *int16
	clearedFields          map[string]struct{}
	root                   *uuid.UUID
	clearedroot            bool
	nodes                  map[uuid.UUID]struct{}
	removednodes           map[uuid.UUID]struct{}
	clearednodes           bool
	deposit_address        *uuid.UUID
	cleareddeposit_address bool
	done                   bool
	oldValue               func(context.Context) (*Tree, error)
	predicates             []predicate.Tree
}

var _ ent.Mutation = (*TreeMutation)(nil)

// treeOption allows management of the mutation configuration using functional options.
type treeOption func(*TreeMutation)

// newTreeMutation creates new mutation for the Tree entity.
func newTreeMutation(c config, op Op, opts ...treeOption) *TreeMutation {
	m := &TreeMutation{
		config:        c,
		op:            op,
		typ:           TypeTree,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreeID sets the ID field of the mutation.
func withTreeID(id uuid.UUID) treeOption {
	return func(m *TreeMutation) {
		var (
			err   error
			once  sync.Once
			value *Tree
		)
		m.oldValue = func(ctx context.Context) (*Tree, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tree.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTree sets the old Tree of the mutation.
func withTree(node *Tree) treeOption {
	return func(m *TreeMutation) {
		m.oldValue = func(context.Context) (*Tree, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tree entities.
func (m *TreeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TreeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TreeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tree.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TreeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TreeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Tree entity.
// If the Tree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TreeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TreeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TreeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Tree entity.
// If the Tree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TreeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetOwnerIdentityPubkey sets the "owner_identity_pubkey" field.
func (m *TreeMutation) SetOwnerIdentityPubkey(k keys.Public) {
	m.owner_identity_pubkey = &k
}

// OwnerIdentityPubkey returns the value of the "owner_identity_pubkey" field in the mutation.
func (m *TreeMutation) OwnerIdentityPubkey() (r keys.Public, exists bool) {
	v := m.owner_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerIdentityPubkey returns the old "owner_identity_pubkey" field's value of the Tree entity.
// If the Tree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeMutation) OldOwnerIdentityPubkey(ctx context.Context) (v keys.Public, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerIdentityPubkey: %w", err)
	}
	return oldValue.OwnerIdentityPubkey, nil
}

// ResetOwnerIdentityPubkey resets all changes to the "owner_identity_pubkey" field.
func (m *TreeMutation) ResetOwnerIdentityPubkey() {
	m.owner_identity_pubkey = nil
}

// SetStatus sets the "status" field.
func (m *TreeMutation) SetStatus(ss schematype.TreeStatus) {
	m.status = &ss
}

// Status returns the value of the "status" field in the mutation.
func (m *TreeMutation) Status() (r schematype.TreeStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Tree entity.
// If the Tree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeMutation) OldStatus(ctx context.Context) (v schematype.TreeStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TreeMutation) ResetStatus() {
	m.status = nil
}

// SetNetwork sets the "network" field.
func (m *TreeMutation) SetNetwork(s schematype.Network) {
	m.network = &s
}

// Network returns the value of the "network" field in the mutation.
func (m *TreeMutation) Network() (r schematype.Network, exists bool) {
	v := m.network
	if v == nil {
		return
	}
	return *v, true
}

// OldNetwork returns the old "network" field's value of the Tree entity.
// If the Tree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeMutation) OldNetwork(ctx context.Context) (v schematype.Network, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetwork is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetwork requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetwork: %w", err)
	}
	return oldValue.Network, nil
}

// ResetNetwork resets all changes to the "network" field.
func (m *TreeMutation) ResetNetwork() {
	m.network = nil
}

// SetBaseTxid sets the "base_txid" field.
func (m *TreeMutation) SetBaseTxid(b []byte) {
	m.base_txid = &b
}

// BaseTxid returns the value of the "base_txid" field in the mutation.
func (m *TreeMutation) BaseTxid() (r []byte, exists bool) {
	v := m.base_txid
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseTxid returns the old "base_txid" field's value of the Tree entity.
// If the Tree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeMutation) OldBaseTxid(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseTxid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseTxid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseTxid: %w", err)
	}
	return oldValue.BaseTxid, nil
}

// ResetBaseTxid resets all changes to the "base_txid" field.
func (m *TreeMutation) ResetBaseTxid() {
	m.base_txid = nil
}

// SetVout sets the "vout" field.
func (m *TreeMutation) SetVout(i int16) {
	m.vout = &i
	m.addvout = nil
}

// Vout returns the value of the "vout" field in the mutation.
func (m *TreeMutation) Vout() (r int16, exists bool) {
	v := m.vout
	if v == nil {
		return
	}
	return *v, true
}

// OldVout returns the old "vout" field's value of the Tree entity.
// If the Tree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeMutation) OldVout(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVout: %w", err)
	}
	return oldValue.Vout, nil
}

// AddVout adds i to the "vout" field.
func (m *TreeMutation) AddVout(i int16) {
	if m.addvout != nil {
		*m.addvout += i
	} else {
		m.addvout = &i
	}
}

// AddedVout returns the value that was added to the "vout" field in this mutation.
func (m *TreeMutation) AddedVout() (r int16, exists bool) {
	v := m.addvout
	if v == nil {
		return
	}
	return *v, true
}

// ResetVout resets all changes to the "vout" field.
func (m *TreeMutation) ResetVout() {
	m.vout = nil
	m.addvout = nil
}

// SetRootID sets the "root" edge to the TreeNode entity by id.
func (m *TreeMutation) SetRootID(id uuid.UUID) {
	m.root = &id
}

// ClearRoot clears the "root" edge to the TreeNode entity.
func (m *TreeMutation) ClearRoot() {
	m.clearedroot = true
}

// RootCleared reports if the "root" edge to the TreeNode entity was cleared.
func (m *TreeMutation) RootCleared() bool {
	return m.clearedroot
}

// RootID returns the "root" edge ID in the mutation.
func (m *TreeMutation) RootID() (id uuid.UUID, exists bool) {
	if m.root != nil {
		return *m.root, true
	}
	return
}

// RootIDs returns the "root" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RootID instead. It exists only for internal usage by the builders.
func (m *TreeMutation) RootIDs() (ids []uuid.UUID) {
	if id := m.root; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoot resets all changes to the "root" edge.
func (m *TreeMutation) ResetRoot() {
	m.root = nil
	m.clearedroot = false
}

// AddNodeIDs adds the "nodes" edge to the TreeNode entity by ids.
func (m *TreeMutation) AddNodeIDs(ids ...uuid.UUID) {
	if m.nodes == nil {
		m.nodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the TreeNode entity.
func (m *TreeMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the TreeNode entity was cleared.
func (m *TreeMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the TreeNode entity by IDs.
func (m *TreeMutation) RemoveNodeIDs(ids ...uuid.UUID) {
	if m.removednodes == nil {
		m.removednodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the TreeNode entity.
func (m *TreeMutation) RemovedNodesIDs() (ids []uuid.UUID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *TreeMutation) NodesIDs() (ids []uuid.UUID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *TreeMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// SetDepositAddressID sets the "deposit_address" edge to the DepositAddress entity by id.
func (m *TreeMutation) SetDepositAddressID(id uuid.UUID) {
	m.deposit_address = &id
}

// ClearDepositAddress clears the "deposit_address" edge to the DepositAddress entity.
func (m *TreeMutation) ClearDepositAddress() {
	m.cleareddeposit_address = true
}

// DepositAddressCleared reports if the "deposit_address" edge to the DepositAddress entity was cleared.
func (m *TreeMutation) DepositAddressCleared() bool {
	return m.cleareddeposit_address
}

// DepositAddressID returns the "deposit_address" edge ID in the mutation.
func (m *TreeMutation) DepositAddressID() (id uuid.UUID, exists bool) {
	if m.deposit_address != nil {
		return *m.deposit_address, true
	}
	return
}

// DepositAddressIDs returns the "deposit_address" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepositAddressID instead. It exists only for internal usage by the builders.
func (m *TreeMutation) DepositAddressIDs() (ids []uuid.UUID) {
	if id := m.deposit_address; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepositAddress resets all changes to the "deposit_address" edge.
func (m *TreeMutation) ResetDepositAddress() {
	m.deposit_address = nil
	m.cleareddeposit_address = false
}

// Where appends a list predicates to the TreeMutation builder.
func (m *TreeMutation) Where(ps ...predicate.Tree) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TreeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TreeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tree, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TreeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TreeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tree).
func (m *TreeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TreeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, tree.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, tree.FieldUpdateTime)
	}
	if m.owner_identity_pubkey != nil {
		fields = append(fields, tree.FieldOwnerIdentityPubkey)
	}
	if m.status != nil {
		fields = append(fields, tree.FieldStatus)
	}
	if m.network != nil {
		fields = append(fields, tree.FieldNetwork)
	}
	if m.base_txid != nil {
		fields = append(fields, tree.FieldBaseTxid)
	}
	if m.vout != nil {
		fields = append(fields, tree.FieldVout)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TreeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tree.FieldCreateTime:
		return m.CreateTime()
	case tree.FieldUpdateTime:
		return m.UpdateTime()
	case tree.FieldOwnerIdentityPubkey:
		return m.OwnerIdentityPubkey()
	case tree.FieldStatus:
		return m.Status()
	case tree.FieldNetwork:
		return m.Network()
	case tree.FieldBaseTxid:
		return m.BaseTxid()
	case tree.FieldVout:
		return m.Vout()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TreeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tree.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case tree.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case tree.FieldOwnerIdentityPubkey:
		return m.OldOwnerIdentityPubkey(ctx)
	case tree.FieldStatus:
		return m.OldStatus(ctx)
	case tree.FieldNetwork:
		return m.OldNetwork(ctx)
	case tree.FieldBaseTxid:
		return m.OldBaseTxid(ctx)
	case tree.FieldVout:
		return m.OldVout(ctx)
	}
	return nil, fmt.Errorf("unknown Tree field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tree.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case tree.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case tree.FieldOwnerIdentityPubkey:
		v, ok := value.(keys.Public)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerIdentityPubkey(v)
		return nil
	case tree.FieldStatus:
		v, ok := value.(schematype.TreeStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tree.FieldNetwork:
		v, ok := value.(schematype.Network)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetwork(v)
		return nil
	case tree.FieldBaseTxid:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseTxid(v)
		return nil
	case tree.FieldVout:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVout(v)
		return nil
	}
	return fmt.Errorf("unknown Tree field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TreeMutation) AddedFields() []string {
	var fields []string
	if m.addvout != nil {
		fields = append(fields, tree.FieldVout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TreeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tree.FieldVout:
		return m.AddedVout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tree.FieldVout:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVout(v)
		return nil
	}
	return fmt.Errorf("unknown Tree numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TreeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TreeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tree nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TreeMutation) ResetField(name string) error {
	switch name {
	case tree.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case tree.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case tree.FieldOwnerIdentityPubkey:
		m.ResetOwnerIdentityPubkey()
		return nil
	case tree.FieldStatus:
		m.ResetStatus()
		return nil
	case tree.FieldNetwork:
		m.ResetNetwork()
		return nil
	case tree.FieldBaseTxid:
		m.ResetBaseTxid()
		return nil
	case tree.FieldVout:
		m.ResetVout()
		return nil
	}
	return fmt.Errorf("unknown Tree field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TreeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.root != nil {
		edges = append(edges, tree.EdgeRoot)
	}
	if m.nodes != nil {
		edges = append(edges, tree.EdgeNodes)
	}
	if m.deposit_address != nil {
		edges = append(edges, tree.EdgeDepositAddress)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TreeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tree.EdgeRoot:
		if id := m.root; id != nil {
			return []ent.Value{*id}
		}
	case tree.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	case tree.EdgeDepositAddress:
		if id := m.deposit_address; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TreeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removednodes != nil {
		edges = append(edges, tree.EdgeNodes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TreeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tree.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TreeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedroot {
		edges = append(edges, tree.EdgeRoot)
	}
	if m.clearednodes {
		edges = append(edges, tree.EdgeNodes)
	}
	if m.cleareddeposit_address {
		edges = append(edges, tree.EdgeDepositAddress)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TreeMutation) EdgeCleared(name string) bool {
	switch name {
	case tree.EdgeRoot:
		return m.clearedroot
	case tree.EdgeNodes:
		return m.clearednodes
	case tree.EdgeDepositAddress:
		return m.cleareddeposit_address
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TreeMutation) ClearEdge(name string) error {
	switch name {
	case tree.EdgeRoot:
		m.ClearRoot()
		return nil
	case tree.EdgeDepositAddress:
		m.ClearDepositAddress()
		return nil
	}
	return fmt.Errorf("unknown Tree unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TreeMutation) ResetEdge(name string) error {
	switch name {
	case tree.EdgeRoot:
		m.ResetRoot()
		return nil
	case tree.EdgeNodes:
		m.ResetNodes()
		return nil
	case tree.EdgeDepositAddress:
		m.ResetDepositAddress()
		return nil
	}
	return fmt.Errorf("unknown Tree edge %s", name)
}

// TreeNodeMutation represents an operation that mutates the TreeNode nodes in the graph.
type TreeNodeMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	create_time                   *time.Time
	update_time                   *time.Time
	value                         *uint64
	addvalue                      *int64
	status                        *schematype.TreeNodeStatus
	verifying_pubkey              *keys.Public
	owner_identity_pubkey         *keys.Public
	owner_signing_pubkey          *keys.Public
	vout                          *int16
	addvout                       *int16
	node_confirmation_height      *uint64
	addnode_confirmation_height   *int64
	refund_confirmation_height    *uint64
	addrefund_confirmation_height *int64
	raw_tx                        *[]byte
	direct_tx                     *[]byte
	direct_from_cpfp_refund_tx    *[]byte
	raw_txid                      *[]byte
	direct_txid                   *[]byte
	direct_from_cpfp_refund_txid  *[]byte
	raw_refund_tx                 *[]byte
	direct_refund_tx              *[]byte
	raw_refund_txid               *[]byte
	direct_refund_txid            *[]byte
	clearedFields                 map[string]struct{}
	tree                          *uuid.UUID
	clearedtree                   bool
	parent                        *uuid.UUID
	clearedparent                 bool
	signing_keyshare              *uuid.UUID
	clearedsigning_keyshare       bool
	children                      map[uuid.UUID]struct{}
	removedchildren               map[uuid.UUID]struct{}
	clearedchildren               bool
	done                          bool
	oldValue                      func(context.Context) (*TreeNode, error)
	predicates                    []predicate.TreeNode
}

var _ ent.Mutation = (*TreeNodeMutation)(nil)

// treenodeOption allows management of the mutation configuration using functional options.
type treenodeOption func(*TreeNodeMutation)

// newTreeNodeMutation creates new mutation for the TreeNode entity.
func newTreeNodeMutation(c config, op Op, opts ...treenodeOption) *TreeNodeMutation {
	m := &TreeNodeMutation{
		config:        c,
		op:            op,
		typ:           TypeTreeNode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreeNodeID sets the ID field of the mutation.
func withTreeNodeID(id uuid.UUID) treenodeOption {
	return func(m *TreeNodeMutation) {
		var (
			err   error
			once  sync.Once
			value *TreeNode
		)
		m.oldValue = func(ctx context.Context) (*TreeNode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TreeNode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTreeNode sets the old TreeNode of the mutation.
func withTreeNode(node *TreeNode) treenodeOption {
	return func(m *TreeNodeMutation) {
		m.oldValue = func(context.Context) (*TreeNode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreeNodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreeNodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TreeNode entities.
func (m *TreeNodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TreeNodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TreeNodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TreeNode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TreeNodeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TreeNodeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TreeNodeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TreeNodeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TreeNodeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TreeNodeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetValue sets the "value" field.
func (m *TreeNodeMutation) SetValue(u uint64) {
	m.value = &u
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *TreeNodeMutation) Value() (r uint64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldValue(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds u to the "value" field.
func (m *TreeNodeMutation) AddValue(u int64) {
	if m.addvalue != nil {
		*m.addvalue += u
	} else {
		m.addvalue = &u
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *TreeNodeMutation) AddedValue() (r int64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *TreeNodeMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetStatus sets the "status" field.
func (m *TreeNodeMutation) SetStatus(sns schematype.TreeNodeStatus) {
	m.status = &sns
}

// Status returns the value of the "status" field in the mutation.
func (m *TreeNodeMutation) Status() (r schematype.TreeNodeStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldStatus(ctx context.Context) (v schematype.TreeNodeStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TreeNodeMutation) ResetStatus() {
	m.status = nil
}

// SetVerifyingPubkey sets the "verifying_pubkey" field.
func (m *TreeNodeMutation) SetVerifyingPubkey(k keys.Public) {
	m.verifying_pubkey = &k
}

// VerifyingPubkey returns the value of the "verifying_pubkey" field in the mutation.
func (m *TreeNodeMutation) VerifyingPubkey() (r keys.Public, exists bool) {
	v := m.verifying_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifyingPubkey returns the old "verifying_pubkey" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldVerifyingPubkey(ctx context.Context) (v keys.Public, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifyingPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifyingPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifyingPubkey: %w", err)
	}
	return oldValue.VerifyingPubkey, nil
}

// ResetVerifyingPubkey resets all changes to the "verifying_pubkey" field.
func (m *TreeNodeMutation) ResetVerifyingPubkey() {
	m.verifying_pubkey = nil
}

// SetOwnerIdentityPubkey sets the "owner_identity_pubkey" field.
func (m *TreeNodeMutation) SetOwnerIdentityPubkey(k keys.Public) {
	m.owner_identity_pubkey = &k
}

// OwnerIdentityPubkey returns the value of the "owner_identity_pubkey" field in the mutation.
func (m *TreeNodeMutation) OwnerIdentityPubkey() (r keys.Public, exists bool) {
	v := m.owner_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerIdentityPubkey returns the old "owner_identity_pubkey" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldOwnerIdentityPubkey(ctx context.Context) (v keys.Public, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerIdentityPubkey: %w", err)
	}
	return oldValue.OwnerIdentityPubkey, nil
}

// ResetOwnerIdentityPubkey resets all changes to the "owner_identity_pubkey" field.
func (m *TreeNodeMutation) ResetOwnerIdentityPubkey() {
	m.owner_identity_pubkey = nil
}

// SetOwnerSigningPubkey sets the "owner_signing_pubkey" field.
func (m *TreeNodeMutation) SetOwnerSigningPubkey(k keys.Public) {
	m.owner_signing_pubkey = &k
}

// OwnerSigningPubkey returns the value of the "owner_signing_pubkey" field in the mutation.
func (m *TreeNodeMutation) OwnerSigningPubkey() (r keys.Public, exists bool) {
	v := m.owner_signing_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerSigningPubkey returns the old "owner_signing_pubkey" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldOwnerSigningPubkey(ctx context.Context) (v keys.Public, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerSigningPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerSigningPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerSigningPubkey: %w", err)
	}
	return oldValue.OwnerSigningPubkey, nil
}

// ResetOwnerSigningPubkey resets all changes to the "owner_signing_pubkey" field.
func (m *TreeNodeMutation) ResetOwnerSigningPubkey() {
	m.owner_signing_pubkey = nil
}

// SetVout sets the "vout" field.
func (m *TreeNodeMutation) SetVout(i int16) {
	m.vout = &i
	m.addvout = nil
}

// Vout returns the value of the "vout" field in the mutation.
func (m *TreeNodeMutation) Vout() (r int16, exists bool) {
	v := m.vout
	if v == nil {
		return
	}
	return *v, true
}

// OldVout returns the old "vout" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldVout(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVout: %w", err)
	}
	return oldValue.Vout, nil
}

// AddVout adds i to the "vout" field.
func (m *TreeNodeMutation) AddVout(i int16) {
	if m.addvout != nil {
		*m.addvout += i
	} else {
		m.addvout = &i
	}
}

// AddedVout returns the value that was added to the "vout" field in this mutation.
func (m *TreeNodeMutation) AddedVout() (r int16, exists bool) {
	v := m.addvout
	if v == nil {
		return
	}
	return *v, true
}

// ResetVout resets all changes to the "vout" field.
func (m *TreeNodeMutation) ResetVout() {
	m.vout = nil
	m.addvout = nil
}

// SetNodeConfirmationHeight sets the "node_confirmation_height" field.
func (m *TreeNodeMutation) SetNodeConfirmationHeight(u uint64) {
	m.node_confirmation_height = &u
	m.addnode_confirmation_height = nil
}

// NodeConfirmationHeight returns the value of the "node_confirmation_height" field in the mutation.
func (m *TreeNodeMutation) NodeConfirmationHeight() (r uint64, exists bool) {
	v := m.node_confirmation_height
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeConfirmationHeight returns the old "node_confirmation_height" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldNodeConfirmationHeight(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeConfirmationHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeConfirmationHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeConfirmationHeight: %w", err)
	}
	return oldValue.NodeConfirmationHeight, nil
}

// AddNodeConfirmationHeight adds u to the "node_confirmation_height" field.
func (m *TreeNodeMutation) AddNodeConfirmationHeight(u int64) {
	if m.addnode_confirmation_height != nil {
		*m.addnode_confirmation_height += u
	} else {
		m.addnode_confirmation_height = &u
	}
}

// AddedNodeConfirmationHeight returns the value that was added to the "node_confirmation_height" field in this mutation.
func (m *TreeNodeMutation) AddedNodeConfirmationHeight() (r int64, exists bool) {
	v := m.addnode_confirmation_height
	if v == nil {
		return
	}
	return *v, true
}

// ClearNodeConfirmationHeight clears the value of the "node_confirmation_height" field.
func (m *TreeNodeMutation) ClearNodeConfirmationHeight() {
	m.node_confirmation_height = nil
	m.addnode_confirmation_height = nil
	m.clearedFields[treenode.FieldNodeConfirmationHeight] = struct{}{}
}

// NodeConfirmationHeightCleared returns if the "node_confirmation_height" field was cleared in this mutation.
func (m *TreeNodeMutation) NodeConfirmationHeightCleared() bool {
	_, ok := m.clearedFields[treenode.FieldNodeConfirmationHeight]
	return ok
}

// ResetNodeConfirmationHeight resets all changes to the "node_confirmation_height" field.
func (m *TreeNodeMutation) ResetNodeConfirmationHeight() {
	m.node_confirmation_height = nil
	m.addnode_confirmation_height = nil
	delete(m.clearedFields, treenode.FieldNodeConfirmationHeight)
}

// SetRefundConfirmationHeight sets the "refund_confirmation_height" field.
func (m *TreeNodeMutation) SetRefundConfirmationHeight(u uint64) {
	m.refund_confirmation_height = &u
	m.addrefund_confirmation_height = nil
}

// RefundConfirmationHeight returns the value of the "refund_confirmation_height" field in the mutation.
func (m *TreeNodeMutation) RefundConfirmationHeight() (r uint64, exists bool) {
	v := m.refund_confirmation_height
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundConfirmationHeight returns the old "refund_confirmation_height" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldRefundConfirmationHeight(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundConfirmationHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundConfirmationHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundConfirmationHeight: %w", err)
	}
	return oldValue.RefundConfirmationHeight, nil
}

// AddRefundConfirmationHeight adds u to the "refund_confirmation_height" field.
func (m *TreeNodeMutation) AddRefundConfirmationHeight(u int64) {
	if m.addrefund_confirmation_height != nil {
		*m.addrefund_confirmation_height += u
	} else {
		m.addrefund_confirmation_height = &u
	}
}

// AddedRefundConfirmationHeight returns the value that was added to the "refund_confirmation_height" field in this mutation.
func (m *TreeNodeMutation) AddedRefundConfirmationHeight() (r int64, exists bool) {
	v := m.addrefund_confirmation_height
	if v == nil {
		return
	}
	return *v, true
}

// ClearRefundConfirmationHeight clears the value of the "refund_confirmation_height" field.
func (m *TreeNodeMutation) ClearRefundConfirmationHeight() {
	m.refund_confirmation_height = nil
	m.addrefund_confirmation_height = nil
	m.clearedFields[treenode.FieldRefundConfirmationHeight] = struct{}{}
}

// RefundConfirmationHeightCleared returns if the "refund_confirmation_height" field was cleared in this mutation.
func (m *TreeNodeMutation) RefundConfirmationHeightCleared() bool {
	_, ok := m.clearedFields[treenode.FieldRefundConfirmationHeight]
	return ok
}

// ResetRefundConfirmationHeight resets all changes to the "refund_confirmation_height" field.
func (m *TreeNodeMutation) ResetRefundConfirmationHeight() {
	m.refund_confirmation_height = nil
	m.addrefund_confirmation_height = nil
	delete(m.clearedFields, treenode.FieldRefundConfirmationHeight)
}

// SetRawTx sets the "raw_tx" field.
func (m *TreeNodeMutation) SetRawTx(b []byte) {
	m.raw_tx = &b
}

// RawTx returns the value of the "raw_tx" field in the mutation.
func (m *TreeNodeMutation) RawTx() (r []byte, exists bool) {
	v := m.raw_tx
	if v == nil {
		return
	}
	return *v, true
}

// OldRawTx returns the old "raw_tx" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldRawTx(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawTx: %w", err)
	}
	return oldValue.RawTx, nil
}

// ResetRawTx resets all changes to the "raw_tx" field.
func (m *TreeNodeMutation) ResetRawTx() {
	m.raw_tx = nil
}

// SetDirectTx sets the "direct_tx" field.
func (m *TreeNodeMutation) SetDirectTx(b []byte) {
	m.direct_tx = &b
}

// DirectTx returns the value of the "direct_tx" field in the mutation.
func (m *TreeNodeMutation) DirectTx() (r []byte, exists bool) {
	v := m.direct_tx
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectTx returns the old "direct_tx" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldDirectTx(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectTx: %w", err)
	}
	return oldValue.DirectTx, nil
}

// ClearDirectTx clears the value of the "direct_tx" field.
func (m *TreeNodeMutation) ClearDirectTx() {
	m.direct_tx = nil
	m.clearedFields[treenode.FieldDirectTx] = struct{}{}
}

// DirectTxCleared returns if the "direct_tx" field was cleared in this mutation.
func (m *TreeNodeMutation) DirectTxCleared() bool {
	_, ok := m.clearedFields[treenode.FieldDirectTx]
	return ok
}

// ResetDirectTx resets all changes to the "direct_tx" field.
func (m *TreeNodeMutation) ResetDirectTx() {
	m.direct_tx = nil
	delete(m.clearedFields, treenode.FieldDirectTx)
}

// SetDirectFromCpfpRefundTx sets the "direct_from_cpfp_refund_tx" field.
func (m *TreeNodeMutation) SetDirectFromCpfpRefundTx(b []byte) {
	m.direct_from_cpfp_refund_tx = &b
}

// DirectFromCpfpRefundTx returns the value of the "direct_from_cpfp_refund_tx" field in the mutation.
func (m *TreeNodeMutation) DirectFromCpfpRefundTx() (r []byte, exists bool) {
	v := m.direct_from_cpfp_refund_tx
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectFromCpfpRefundTx returns the old "direct_from_cpfp_refund_tx" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldDirectFromCpfpRefundTx(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectFromCpfpRefundTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectFromCpfpRefundTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectFromCpfpRefundTx: %w", err)
	}
	return oldValue.DirectFromCpfpRefundTx, nil
}

// ClearDirectFromCpfpRefundTx clears the value of the "direct_from_cpfp_refund_tx" field.
func (m *TreeNodeMutation) ClearDirectFromCpfpRefundTx() {
	m.direct_from_cpfp_refund_tx = nil
	m.clearedFields[treenode.FieldDirectFromCpfpRefundTx] = struct{}{}
}

// DirectFromCpfpRefundTxCleared returns if the "direct_from_cpfp_refund_tx" field was cleared in this mutation.
func (m *TreeNodeMutation) DirectFromCpfpRefundTxCleared() bool {
	_, ok := m.clearedFields[treenode.FieldDirectFromCpfpRefundTx]
	return ok
}

// ResetDirectFromCpfpRefundTx resets all changes to the "direct_from_cpfp_refund_tx" field.
func (m *TreeNodeMutation) ResetDirectFromCpfpRefundTx() {
	m.direct_from_cpfp_refund_tx = nil
	delete(m.clearedFields, treenode.FieldDirectFromCpfpRefundTx)
}

// SetRawTxid sets the "raw_txid" field.
func (m *TreeNodeMutation) SetRawTxid(b []byte) {
	m.raw_txid = &b
}

// RawTxid returns the value of the "raw_txid" field in the mutation.
func (m *TreeNodeMutation) RawTxid() (r []byte, exists bool) {
	v := m.raw_txid
	if v == nil {
		return
	}
	return *v, true
}

// OldRawTxid returns the old "raw_txid" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldRawTxid(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawTxid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawTxid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawTxid: %w", err)
	}
	return oldValue.RawTxid, nil
}

// ClearRawTxid clears the value of the "raw_txid" field.
func (m *TreeNodeMutation) ClearRawTxid() {
	m.raw_txid = nil
	m.clearedFields[treenode.FieldRawTxid] = struct{}{}
}

// RawTxidCleared returns if the "raw_txid" field was cleared in this mutation.
func (m *TreeNodeMutation) RawTxidCleared() bool {
	_, ok := m.clearedFields[treenode.FieldRawTxid]
	return ok
}

// ResetRawTxid resets all changes to the "raw_txid" field.
func (m *TreeNodeMutation) ResetRawTxid() {
	m.raw_txid = nil
	delete(m.clearedFields, treenode.FieldRawTxid)
}

// SetDirectTxid sets the "direct_txid" field.
func (m *TreeNodeMutation) SetDirectTxid(b []byte) {
	m.direct_txid = &b
}

// DirectTxid returns the value of the "direct_txid" field in the mutation.
func (m *TreeNodeMutation) DirectTxid() (r []byte, exists bool) {
	v := m.direct_txid
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectTxid returns the old "direct_txid" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldDirectTxid(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectTxid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectTxid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectTxid: %w", err)
	}
	return oldValue.DirectTxid, nil
}

// ClearDirectTxid clears the value of the "direct_txid" field.
func (m *TreeNodeMutation) ClearDirectTxid() {
	m.direct_txid = nil
	m.clearedFields[treenode.FieldDirectTxid] = struct{}{}
}

// DirectTxidCleared returns if the "direct_txid" field was cleared in this mutation.
func (m *TreeNodeMutation) DirectTxidCleared() bool {
	_, ok := m.clearedFields[treenode.FieldDirectTxid]
	return ok
}

// ResetDirectTxid resets all changes to the "direct_txid" field.
func (m *TreeNodeMutation) ResetDirectTxid() {
	m.direct_txid = nil
	delete(m.clearedFields, treenode.FieldDirectTxid)
}

// SetDirectFromCpfpRefundTxid sets the "direct_from_cpfp_refund_txid" field.
func (m *TreeNodeMutation) SetDirectFromCpfpRefundTxid(b []byte) {
	m.direct_from_cpfp_refund_txid = &b
}

// DirectFromCpfpRefundTxid returns the value of the "direct_from_cpfp_refund_txid" field in the mutation.
func (m *TreeNodeMutation) DirectFromCpfpRefundTxid() (r []byte, exists bool) {
	v := m.direct_from_cpfp_refund_txid
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectFromCpfpRefundTxid returns the old "direct_from_cpfp_refund_txid" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldDirectFromCpfpRefundTxid(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectFromCpfpRefundTxid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectFromCpfpRefundTxid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectFromCpfpRefundTxid: %w", err)
	}
	return oldValue.DirectFromCpfpRefundTxid, nil
}

// ClearDirectFromCpfpRefundTxid clears the value of the "direct_from_cpfp_refund_txid" field.
func (m *TreeNodeMutation) ClearDirectFromCpfpRefundTxid() {
	m.direct_from_cpfp_refund_txid = nil
	m.clearedFields[treenode.FieldDirectFromCpfpRefundTxid] = struct{}{}
}

// DirectFromCpfpRefundTxidCleared returns if the "direct_from_cpfp_refund_txid" field was cleared in this mutation.
func (m *TreeNodeMutation) DirectFromCpfpRefundTxidCleared() bool {
	_, ok := m.clearedFields[treenode.FieldDirectFromCpfpRefundTxid]
	return ok
}

// ResetDirectFromCpfpRefundTxid resets all changes to the "direct_from_cpfp_refund_txid" field.
func (m *TreeNodeMutation) ResetDirectFromCpfpRefundTxid() {
	m.direct_from_cpfp_refund_txid = nil
	delete(m.clearedFields, treenode.FieldDirectFromCpfpRefundTxid)
}

// SetRawRefundTx sets the "raw_refund_tx" field.
func (m *TreeNodeMutation) SetRawRefundTx(b []byte) {
	m.raw_refund_tx = &b
}

// RawRefundTx returns the value of the "raw_refund_tx" field in the mutation.
func (m *TreeNodeMutation) RawRefundTx() (r []byte, exists bool) {
	v := m.raw_refund_tx
	if v == nil {
		return
	}
	return *v, true
}

// OldRawRefundTx returns the old "raw_refund_tx" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldRawRefundTx(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawRefundTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawRefundTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawRefundTx: %w", err)
	}
	return oldValue.RawRefundTx, nil
}

// ClearRawRefundTx clears the value of the "raw_refund_tx" field.
func (m *TreeNodeMutation) ClearRawRefundTx() {
	m.raw_refund_tx = nil
	m.clearedFields[treenode.FieldRawRefundTx] = struct{}{}
}

// RawRefundTxCleared returns if the "raw_refund_tx" field was cleared in this mutation.
func (m *TreeNodeMutation) RawRefundTxCleared() bool {
	_, ok := m.clearedFields[treenode.FieldRawRefundTx]
	return ok
}

// ResetRawRefundTx resets all changes to the "raw_refund_tx" field.
func (m *TreeNodeMutation) ResetRawRefundTx() {
	m.raw_refund_tx = nil
	delete(m.clearedFields, treenode.FieldRawRefundTx)
}

// SetDirectRefundTx sets the "direct_refund_tx" field.
func (m *TreeNodeMutation) SetDirectRefundTx(b []byte) {
	m.direct_refund_tx = &b
}

// DirectRefundTx returns the value of the "direct_refund_tx" field in the mutation.
func (m *TreeNodeMutation) DirectRefundTx() (r []byte, exists bool) {
	v := m.direct_refund_tx
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectRefundTx returns the old "direct_refund_tx" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldDirectRefundTx(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectRefundTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectRefundTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectRefundTx: %w", err)
	}
	return oldValue.DirectRefundTx, nil
}

// ClearDirectRefundTx clears the value of the "direct_refund_tx" field.
func (m *TreeNodeMutation) ClearDirectRefundTx() {
	m.direct_refund_tx = nil
	m.clearedFields[treenode.FieldDirectRefundTx] = struct{}{}
}

// DirectRefundTxCleared returns if the "direct_refund_tx" field was cleared in this mutation.
func (m *TreeNodeMutation) DirectRefundTxCleared() bool {
	_, ok := m.clearedFields[treenode.FieldDirectRefundTx]
	return ok
}

// ResetDirectRefundTx resets all changes to the "direct_refund_tx" field.
func (m *TreeNodeMutation) ResetDirectRefundTx() {
	m.direct_refund_tx = nil
	delete(m.clearedFields, treenode.FieldDirectRefundTx)
}

// SetRawRefundTxid sets the "raw_refund_txid" field.
func (m *TreeNodeMutation) SetRawRefundTxid(b []byte) {
	m.raw_refund_txid = &b
}

// RawRefundTxid returns the value of the "raw_refund_txid" field in the mutation.
func (m *TreeNodeMutation) RawRefundTxid() (r []byte, exists bool) {
	v := m.raw_refund_txid
	if v == nil {
		return
	}
	return *v, true
}

// OldRawRefundTxid returns the old "raw_refund_txid" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldRawRefundTxid(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawRefundTxid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawRefundTxid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawRefundTxid: %w", err)
	}
	return oldValue.RawRefundTxid, nil
}

// ClearRawRefundTxid clears the value of the "raw_refund_txid" field.
func (m *TreeNodeMutation) ClearRawRefundTxid() {
	m.raw_refund_txid = nil
	m.clearedFields[treenode.FieldRawRefundTxid] = struct{}{}
}

// RawRefundTxidCleared returns if the "raw_refund_txid" field was cleared in this mutation.
func (m *TreeNodeMutation) RawRefundTxidCleared() bool {
	_, ok := m.clearedFields[treenode.FieldRawRefundTxid]
	return ok
}

// ResetRawRefundTxid resets all changes to the "raw_refund_txid" field.
func (m *TreeNodeMutation) ResetRawRefundTxid() {
	m.raw_refund_txid = nil
	delete(m.clearedFields, treenode.FieldRawRefundTxid)
}

// SetDirectRefundTxid sets the "direct_refund_txid" field.
func (m *TreeNodeMutation) SetDirectRefundTxid(b []byte) {
	m.direct_refund_txid = &b
}

// DirectRefundTxid returns the value of the "direct_refund_txid" field in the mutation.
func (m *TreeNodeMutation) DirectRefundTxid() (r []byte, exists bool) {
	v := m.direct_refund_txid
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectRefundTxid returns the old "direct_refund_txid" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldDirectRefundTxid(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectRefundTxid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectRefundTxid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectRefundTxid: %w", err)
	}
	return oldValue.DirectRefundTxid, nil
}

// ClearDirectRefundTxid clears the value of the "direct_refund_txid" field.
func (m *TreeNodeMutation) ClearDirectRefundTxid() {
	m.direct_refund_txid = nil
	m.clearedFields[treenode.FieldDirectRefundTxid] = struct{}{}
}

// DirectRefundTxidCleared returns if the "direct_refund_txid" field was cleared in this mutation.
func (m *TreeNodeMutation) DirectRefundTxidCleared() bool {
	_, ok := m.clearedFields[treenode.FieldDirectRefundTxid]
	return ok
}

// ResetDirectRefundTxid resets all changes to the "direct_refund_txid" field.
func (m *TreeNodeMutation) ResetDirectRefundTxid() {
	m.direct_refund_txid = nil
	delete(m.clearedFields, treenode.FieldDirectRefundTxid)
}

// SetTreeID sets the "tree" edge to the Tree entity by id.
func (m *TreeNodeMutation) SetTreeID(id uuid.UUID) {
	m.tree = &id
}

// ClearTree clears the "tree" edge to the Tree entity.
func (m *TreeNodeMutation) ClearTree() {
	m.clearedtree = true
}

// TreeCleared reports if the "tree" edge to the Tree entity was cleared.
func (m *TreeNodeMutation) TreeCleared() bool {
	return m.clearedtree
}

// TreeID returns the "tree" edge ID in the mutation.
func (m *TreeNodeMutation) TreeID() (id uuid.UUID, exists bool) {
	if m.tree != nil {
		return *m.tree, true
	}
	return
}

// TreeIDs returns the "tree" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TreeID instead. It exists only for internal usage by the builders.
func (m *TreeNodeMutation) TreeIDs() (ids []uuid.UUID) {
	if id := m.tree; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTree resets all changes to the "tree" edge.
func (m *TreeNodeMutation) ResetTree() {
	m.tree = nil
	m.clearedtree = false
}

// SetParentID sets the "parent" edge to the TreeNode entity by id.
func (m *TreeNodeMutation) SetParentID(id uuid.UUID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the TreeNode entity.
func (m *TreeNodeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the TreeNode entity was cleared.
func (m *TreeNodeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *TreeNodeMutation) ParentID() (id uuid.UUID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *TreeNodeMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *TreeNodeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// SetSigningKeyshareID sets the "signing_keyshare" edge to the SigningKeyshare entity by id.
func (m *TreeNodeMutation) SetSigningKeyshareID(id uuid.UUID) {
	m.signing_keyshare = &id
}

// ClearSigningKeyshare clears the "signing_keyshare" edge to the SigningKeyshare entity.
func (m *TreeNodeMutation) ClearSigningKeyshare() {
	m.clearedsigning_keyshare = true
}

// SigningKeyshareCleared reports if the "signing_keyshare" edge to the SigningKeyshare entity was cleared.
func (m *TreeNodeMutation) SigningKeyshareCleared() bool {
	return m.clearedsigning_keyshare
}

// SigningKeyshareID returns the "signing_keyshare" edge ID in the mutation.
func (m *TreeNodeMutation) SigningKeyshareID() (id uuid.UUID, exists bool) {
	if m.signing_keyshare != nil {
		return *m.signing_keyshare, true
	}
	return
}

// SigningKeyshareIDs returns the "signing_keyshare" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SigningKeyshareID instead. It exists only for internal usage by the builders.
func (m *TreeNodeMutation) SigningKeyshareIDs() (ids []uuid.UUID) {
	if id := m.signing_keyshare; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSigningKeyshare resets all changes to the "signing_keyshare" edge.
func (m *TreeNodeMutation) ResetSigningKeyshare() {
	m.signing_keyshare = nil
	m.clearedsigning_keyshare = false
}

// AddChildIDs adds the "children" edge to the TreeNode entity by ids.
func (m *TreeNodeMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the TreeNode entity.
func (m *TreeNodeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the TreeNode entity was cleared.
func (m *TreeNodeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the TreeNode entity by IDs.
func (m *TreeNodeMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the TreeNode entity.
func (m *TreeNodeMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *TreeNodeMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *TreeNodeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the TreeNodeMutation builder.
func (m *TreeNodeMutation) Where(ps ...predicate.TreeNode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TreeNodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TreeNodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TreeNode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TreeNodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TreeNodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TreeNode).
func (m *TreeNodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TreeNodeMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.create_time != nil {
		fields = append(fields, treenode.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, treenode.FieldUpdateTime)
	}
	if m.value != nil {
		fields = append(fields, treenode.FieldValue)
	}
	if m.status != nil {
		fields = append(fields, treenode.FieldStatus)
	}
	if m.verifying_pubkey != nil {
		fields = append(fields, treenode.FieldVerifyingPubkey)
	}
	if m.owner_identity_pubkey != nil {
		fields = append(fields, treenode.FieldOwnerIdentityPubkey)
	}
	if m.owner_signing_pubkey != nil {
		fields = append(fields, treenode.FieldOwnerSigningPubkey)
	}
	if m.vout != nil {
		fields = append(fields, treenode.FieldVout)
	}
	if m.node_confirmation_height != nil {
		fields = append(fields, treenode.FieldNodeConfirmationHeight)
	}
	if m.refund_confirmation_height != nil {
		fields = append(fields, treenode.FieldRefundConfirmationHeight)
	}
	if m.raw_tx != nil {
		fields = append(fields, treenode.FieldRawTx)
	}
	if m.direct_tx != nil {
		fields = append(fields, treenode.FieldDirectTx)
	}
	if m.direct_from_cpfp_refund_tx != nil {
		fields = append(fields, treenode.FieldDirectFromCpfpRefundTx)
	}
	if m.raw_txid != nil {
		fields = append(fields, treenode.FieldRawTxid)
	}
	if m.direct_txid != nil {
		fields = append(fields, treenode.FieldDirectTxid)
	}
	if m.direct_from_cpfp_refund_txid != nil {
		fields = append(fields, treenode.FieldDirectFromCpfpRefundTxid)
	}
	if m.raw_refund_tx != nil {
		fields = append(fields, treenode.FieldRawRefundTx)
	}
	if m.direct_refund_tx != nil {
		fields = append(fields, treenode.FieldDirectRefundTx)
	}
	if m.raw_refund_txid != nil {
		fields = append(fields, treenode.FieldRawRefundTxid)
	}
	if m.direct_refund_txid != nil {
		fields = append(fields, treenode.FieldDirectRefundTxid)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TreeNodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case treenode.FieldCreateTime:
		return m.CreateTime()
	case treenode.FieldUpdateTime:
		return m.UpdateTime()
	case treenode.FieldValue:
		return m.Value()
	case treenode.FieldStatus:
		return m.Status()
	case treenode.FieldVerifyingPubkey:
		return m.VerifyingPubkey()
	case treenode.FieldOwnerIdentityPubkey:
		return m.OwnerIdentityPubkey()
	case treenode.FieldOwnerSigningPubkey:
		return m.OwnerSigningPubkey()
	case treenode.FieldVout:
		return m.Vout()
	case treenode.FieldNodeConfirmationHeight:
		return m.NodeConfirmationHeight()
	case treenode.FieldRefundConfirmationHeight:
		return m.RefundConfirmationHeight()
	case treenode.FieldRawTx:
		return m.RawTx()
	case treenode.FieldDirectTx:
		return m.DirectTx()
	case treenode.FieldDirectFromCpfpRefundTx:
		return m.DirectFromCpfpRefundTx()
	case treenode.FieldRawTxid:
		return m.RawTxid()
	case treenode.FieldDirectTxid:
		return m.DirectTxid()
	case treenode.FieldDirectFromCpfpRefundTxid:
		return m.DirectFromCpfpRefundTxid()
	case treenode.FieldRawRefundTx:
		return m.RawRefundTx()
	case treenode.FieldDirectRefundTx:
		return m.DirectRefundTx()
	case treenode.FieldRawRefundTxid:
		return m.RawRefundTxid()
	case treenode.FieldDirectRefundTxid:
		return m.DirectRefundTxid()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TreeNodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case treenode.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case treenode.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case treenode.FieldValue:
		return m.OldValue(ctx)
	case treenode.FieldStatus:
		return m.OldStatus(ctx)
	case treenode.FieldVerifyingPubkey:
		return m.OldVerifyingPubkey(ctx)
	case treenode.FieldOwnerIdentityPubkey:
		return m.OldOwnerIdentityPubkey(ctx)
	case treenode.FieldOwnerSigningPubkey:
		return m.OldOwnerSigningPubkey(ctx)
	case treenode.FieldVout:
		return m.OldVout(ctx)
	case treenode.FieldNodeConfirmationHeight:
		return m.OldNodeConfirmationHeight(ctx)
	case treenode.FieldRefundConfirmationHeight:
		return m.OldRefundConfirmationHeight(ctx)
	case treenode.FieldRawTx:
		return m.OldRawTx(ctx)
	case treenode.FieldDirectTx:
		return m.OldDirectTx(ctx)
	case treenode.FieldDirectFromCpfpRefundTx:
		return m.OldDirectFromCpfpRefundTx(ctx)
	case treenode.FieldRawTxid:
		return m.OldRawTxid(ctx)
	case treenode.FieldDirectTxid:
		return m.OldDirectTxid(ctx)
	case treenode.FieldDirectFromCpfpRefundTxid:
		return m.OldDirectFromCpfpRefundTxid(ctx)
	case treenode.FieldRawRefundTx:
		return m.OldRawRefundTx(ctx)
	case treenode.FieldDirectRefundTx:
		return m.OldDirectRefundTx(ctx)
	case treenode.FieldRawRefundTxid:
		return m.OldRawRefundTxid(ctx)
	case treenode.FieldDirectRefundTxid:
		return m.OldDirectRefundTxid(ctx)
	}
	return nil, fmt.Errorf("unknown TreeNode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreeNodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case treenode.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case treenode.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case treenode.FieldValue:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case treenode.FieldStatus:
		v, ok := value.(schematype.TreeNodeStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case treenode.FieldVerifyingPubkey:
		v, ok := value.(keys.Public)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifyingPubkey(v)
		return nil
	case treenode.FieldOwnerIdentityPubkey:
		v, ok := value.(keys.Public)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerIdentityPubkey(v)
		return nil
	case treenode.FieldOwnerSigningPubkey:
		v, ok := value.(keys.Public)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerSigningPubkey(v)
		return nil
	case treenode.FieldVout:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVout(v)
		return nil
	case treenode.FieldNodeConfirmationHeight:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeConfirmationHeight(v)
		return nil
	case treenode.FieldRefundConfirmationHeight:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundConfirmationHeight(v)
		return nil
	case treenode.FieldRawTx:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawTx(v)
		return nil
	case treenode.FieldDirectTx:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectTx(v)
		return nil
	case treenode.FieldDirectFromCpfpRefundTx:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectFromCpfpRefundTx(v)
		return nil
	case treenode.FieldRawTxid:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawTxid(v)
		return nil
	case treenode.FieldDirectTxid:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectTxid(v)
		return nil
	case treenode.FieldDirectFromCpfpRefundTxid:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectFromCpfpRefundTxid(v)
		return nil
	case treenode.FieldRawRefundTx:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawRefundTx(v)
		return nil
	case treenode.FieldDirectRefundTx:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectRefundTx(v)
		return nil
	case treenode.FieldRawRefundTxid:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawRefundTxid(v)
		return nil
	case treenode.FieldDirectRefundTxid:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectRefundTxid(v)
		return nil
	}
	return fmt.Errorf("unknown TreeNode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TreeNodeMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, treenode.FieldValue)
	}
	if m.addvout != nil {
		fields = append(fields, treenode.FieldVout)
	}
	if m.addnode_confirmation_height != nil {
		fields = append(fields, treenode.FieldNodeConfirmationHeight)
	}
	if m.addrefund_confirmation_height != nil {
		fields = append(fields, treenode.FieldRefundConfirmationHeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TreeNodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case treenode.FieldValue:
		return m.AddedValue()
	case treenode.FieldVout:
		return m.AddedVout()
	case treenode.FieldNodeConfirmationHeight:
		return m.AddedNodeConfirmationHeight()
	case treenode.FieldRefundConfirmationHeight:
		return m.AddedRefundConfirmationHeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreeNodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case treenode.FieldValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case treenode.FieldVout:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVout(v)
		return nil
	case treenode.FieldNodeConfirmationHeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNodeConfirmationHeight(v)
		return nil
	case treenode.FieldRefundConfirmationHeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRefundConfirmationHeight(v)
		return nil
	}
	return fmt.Errorf("unknown TreeNode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TreeNodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(treenode.FieldNodeConfirmationHeight) {
		fields = append(fields, treenode.FieldNodeConfirmationHeight)
	}
	if m.FieldCleared(treenode.FieldRefundConfirmationHeight) {
		fields = append(fields, treenode.FieldRefundConfirmationHeight)
	}
	if m.FieldCleared(treenode.FieldDirectTx) {
		fields = append(fields, treenode.FieldDirectTx)
	}
	if m.FieldCleared(treenode.FieldDirectFromCpfpRefundTx) {
		fields = append(fields, treenode.FieldDirectFromCpfpRefundTx)
	}
	if m.FieldCleared(treenode.FieldRawTxid) {
		fields = append(fields, treenode.FieldRawTxid)
	}
	if m.FieldCleared(treenode.FieldDirectTxid) {
		fields = append(fields, treenode.FieldDirectTxid)
	}
	if m.FieldCleared(treenode.FieldDirectFromCpfpRefundTxid) {
		fields = append(fields, treenode.FieldDirectFromCpfpRefundTxid)
	}
	if m.FieldCleared(treenode.FieldRawRefundTx) {
		fields = append(fields, treenode.FieldRawRefundTx)
	}
	if m.FieldCleared(treenode.FieldDirectRefundTx) {
		fields = append(fields, treenode.FieldDirectRefundTx)
	}
	if m.FieldCleared(treenode.FieldRawRefundTxid) {
		fields = append(fields, treenode.FieldRawRefundTxid)
	}
	if m.FieldCleared(treenode.FieldDirectRefundTxid) {
		fields = append(fields, treenode.FieldDirectRefundTxid)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TreeNodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreeNodeMutation) ClearField(name string) error {
	switch name {
	case treenode.FieldNodeConfirmationHeight:
		m.ClearNodeConfirmationHeight()
		return nil
	case treenode.FieldRefundConfirmationHeight:
		m.ClearRefundConfirmationHeight()
		return nil
	case treenode.FieldDirectTx:
		m.ClearDirectTx()
		return nil
	case treenode.FieldDirectFromCpfpRefundTx:
		m.ClearDirectFromCpfpRefundTx()
		return nil
	case treenode.FieldRawTxid:
		m.ClearRawTxid()
		return nil
	case treenode.FieldDirectTxid:
		m.ClearDirectTxid()
		return nil
	case treenode.FieldDirectFromCpfpRefundTxid:
		m.ClearDirectFromCpfpRefundTxid()
		return nil
	case treenode.FieldRawRefundTx:
		m.ClearRawRefundTx()
		return nil
	case treenode.FieldDirectRefundTx:
		m.ClearDirectRefundTx()
		return nil
	case treenode.FieldRawRefundTxid:
		m.ClearRawRefundTxid()
		return nil
	case treenode.FieldDirectRefundTxid:
		m.ClearDirectRefundTxid()
		return nil
	}
	return fmt.Errorf("unknown TreeNode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TreeNodeMutation) ResetField(name string) error {
	switch name {
	case treenode.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case treenode.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case treenode.FieldValue:
		m.ResetValue()
		return nil
	case treenode.FieldStatus:
		m.ResetStatus()
		return nil
	case treenode.FieldVerifyingPubkey:
		m.ResetVerifyingPubkey()
		return nil
	case treenode.FieldOwnerIdentityPubkey:
		m.ResetOwnerIdentityPubkey()
		return nil
	case treenode.FieldOwnerSigningPubkey:
		m.ResetOwnerSigningPubkey()
		return nil
	case treenode.FieldVout:
		m.ResetVout()
		return nil
	case treenode.FieldNodeConfirmationHeight:
		m.ResetNodeConfirmationHeight()
		return nil
	case treenode.FieldRefundConfirmationHeight:
		m.ResetRefundConfirmationHeight()
		return nil
	case treenode.FieldRawTx:
		m.ResetRawTx()
		return nil
	case treenode.FieldDirectTx:
		m.ResetDirectTx()
		return nil
	case treenode.FieldDirectFromCpfpRefundTx:
		m.ResetDirectFromCpfpRefundTx()
		return nil
	case treenode.FieldRawTxid:
		m.ResetRawTxid()
		return nil
	case treenode.FieldDirectTxid:
		m.ResetDirectTxid()
		return nil
	case treenode.FieldDirectFromCpfpRefundTxid:
		m.ResetDirectFromCpfpRefundTxid()
		return nil
	case treenode.FieldRawRefundTx:
		m.ResetRawRefundTx()
		return nil
	case treenode.FieldDirectRefundTx:
		m.ResetDirectRefundTx()
		return nil
	case treenode.FieldRawRefundTxid:
		m.ResetRawRefundTxid()
		return nil
	case treenode.FieldDirectRefundTxid:
		m.ResetDirectRefundTxid()
		return nil
	}
	return fmt.Errorf("unknown TreeNode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TreeNodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tree != nil {
		edges = append(edges, treenode.EdgeTree)
	}
	if m.parent != nil {
		edges = append(edges, treenode.EdgeParent)
	}
	if m.signing_keyshare != nil {
		edges = append(edges, treenode.EdgeSigningKeyshare)
	}
	if m.children != nil {
		edges = append(edges, treenode.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TreeNodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case treenode.EdgeTree:
		if id := m.tree; id != nil {
			return []ent.Value{*id}
		}
	case treenode.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case treenode.EdgeSigningKeyshare:
		if id := m.signing_keyshare; id != nil {
			return []ent.Value{*id}
		}
	case treenode.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TreeNodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, treenode.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TreeNodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case treenode.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TreeNodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtree {
		edges = append(edges, treenode.EdgeTree)
	}
	if m.clearedparent {
		edges = append(edges, treenode.EdgeParent)
	}
	if m.clearedsigning_keyshare {
		edges = append(edges, treenode.EdgeSigningKeyshare)
	}
	if m.clearedchildren {
		edges = append(edges, treenode.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TreeNodeMutation) EdgeCleared(name string) bool {
	switch name {
	case treenode.EdgeTree:
		return m.clearedtree
	case treenode.EdgeParent:
		return m.clearedparent
	case treenode.EdgeSigningKeyshare:
		return m.clearedsigning_keyshare
	case treenode.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TreeNodeMutation) ClearEdge(name string) error {
	switch name {
	case treenode.EdgeTree:
		m.ClearTree()
		return nil
	case treenode.EdgeParent:
		m.ClearParent()
		return nil
	case treenode.EdgeSigningKeyshare:
		m.ClearSigningKeyshare()
		return nil
	}
	return fmt.Errorf("unknown TreeNode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TreeNodeMutation) ResetEdge(name string) error {
	switch name {
	case treenode.EdgeTree:
		m.ResetTree()
		return nil
	case treenode.EdgeParent:
		m.ResetParent()
		return nil
	case treenode.EdgeSigningKeyshare:
		m.ResetSigningKeyshare()
		return nil
	case treenode.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown TreeNode edge %s", name)
}

// UserSignedTransactionMutation represents an operation that mutates the UserSignedTransaction nodes in the graph.
type UserSignedTransactionMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	create_time               *time.Time
	update_time               *time.Time
	transaction               *[]byte
	user_signature            *[]byte
	signing_commitments       *[]byte
	user_signature_commitment *[]byte
	clearedFields             map[string]struct{}
	tree_node                 *uuid.UUID
	clearedtree_node          bool
	preimage_request          *uuid.UUID
	clearedpreimage_request   bool
	done                      bool
	oldValue                  func(context.Context) (*UserSignedTransaction, error)
	predicates                []predicate.UserSignedTransaction
}

var _ ent.Mutation = (*UserSignedTransactionMutation)(nil)

// usersignedtransactionOption allows management of the mutation configuration using functional options.
type usersignedtransactionOption func(*UserSignedTransactionMutation)

// newUserSignedTransactionMutation creates new mutation for the UserSignedTransaction entity.
func newUserSignedTransactionMutation(c config, op Op, opts ...usersignedtransactionOption) *UserSignedTransactionMutation {
	m := &UserSignedTransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSignedTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSignedTransactionID sets the ID field of the mutation.
func withUserSignedTransactionID(id uuid.UUID) usersignedtransactionOption {
	return func(m *UserSignedTransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSignedTransaction
		)
		m.oldValue = func(ctx context.Context) (*UserSignedTransaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSignedTransaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSignedTransaction sets the old UserSignedTransaction of the mutation.
func withUserSignedTransaction(node *UserSignedTransaction) usersignedtransactionOption {
	return func(m *UserSignedTransactionMutation) {
		m.oldValue = func(context.Context) (*UserSignedTransaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSignedTransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSignedTransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserSignedTransaction entities.
func (m *UserSignedTransactionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSignedTransactionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSignedTransactionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSignedTransaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserSignedTransactionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserSignedTransactionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserSignedTransaction entity.
// If the UserSignedTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSignedTransactionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserSignedTransactionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserSignedTransactionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserSignedTransactionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserSignedTransaction entity.
// If the UserSignedTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSignedTransactionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserSignedTransactionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTransaction sets the "transaction" field.
func (m *UserSignedTransactionMutation) SetTransaction(b []byte) {
	m.transaction = &b
}

// Transaction returns the value of the "transaction" field in the mutation.
func (m *UserSignedTransactionMutation) Transaction() (r []byte, exists bool) {
	v := m.transaction
	if v == nil {
		return
	}
	return *v, true
}

// OldTransaction returns the old "transaction" field's value of the UserSignedTransaction entity.
// If the UserSignedTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSignedTransactionMutation) OldTransaction(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransaction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransaction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransaction: %w", err)
	}
	return oldValue.Transaction, nil
}

// ResetTransaction resets all changes to the "transaction" field.
func (m *UserSignedTransactionMutation) ResetTransaction() {
	m.transaction = nil
}

// SetUserSignature sets the "user_signature" field.
func (m *UserSignedTransactionMutation) SetUserSignature(b []byte) {
	m.user_signature = &b
}

// UserSignature returns the value of the "user_signature" field in the mutation.
func (m *UserSignedTransactionMutation) UserSignature() (r []byte, exists bool) {
	v := m.user_signature
	if v == nil {
		return
	}
	return *v, true
}

// OldUserSignature returns the old "user_signature" field's value of the UserSignedTransaction entity.
// If the UserSignedTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSignedTransactionMutation) OldUserSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserSignature: %w", err)
	}
	return oldValue.UserSignature, nil
}

// ResetUserSignature resets all changes to the "user_signature" field.
func (m *UserSignedTransactionMutation) ResetUserSignature() {
	m.user_signature = nil
}

// SetSigningCommitments sets the "signing_commitments" field.
func (m *UserSignedTransactionMutation) SetSigningCommitments(b []byte) {
	m.signing_commitments = &b
}

// SigningCommitments returns the value of the "signing_commitments" field in the mutation.
func (m *UserSignedTransactionMutation) SigningCommitments() (r []byte, exists bool) {
	v := m.signing_commitments
	if v == nil {
		return
	}
	return *v, true
}

// OldSigningCommitments returns the old "signing_commitments" field's value of the UserSignedTransaction entity.
// If the UserSignedTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSignedTransactionMutation) OldSigningCommitments(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSigningCommitments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSigningCommitments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigningCommitments: %w", err)
	}
	return oldValue.SigningCommitments, nil
}

// ResetSigningCommitments resets all changes to the "signing_commitments" field.
func (m *UserSignedTransactionMutation) ResetSigningCommitments() {
	m.signing_commitments = nil
}

// SetUserSignatureCommitment sets the "user_signature_commitment" field.
func (m *UserSignedTransactionMutation) SetUserSignatureCommitment(b []byte) {
	m.user_signature_commitment = &b
}

// UserSignatureCommitment returns the value of the "user_signature_commitment" field in the mutation.
func (m *UserSignedTransactionMutation) UserSignatureCommitment() (r []byte, exists bool) {
	v := m.user_signature_commitment
	if v == nil {
		return
	}
	return *v, true
}

// OldUserSignatureCommitment returns the old "user_signature_commitment" field's value of the UserSignedTransaction entity.
// If the UserSignedTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSignedTransactionMutation) OldUserSignatureCommitment(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserSignatureCommitment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserSignatureCommitment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserSignatureCommitment: %w", err)
	}
	return oldValue.UserSignatureCommitment, nil
}

// ResetUserSignatureCommitment resets all changes to the "user_signature_commitment" field.
func (m *UserSignedTransactionMutation) ResetUserSignatureCommitment() {
	m.user_signature_commitment = nil
}

// SetTreeNodeID sets the "tree_node" edge to the TreeNode entity by id.
func (m *UserSignedTransactionMutation) SetTreeNodeID(id uuid.UUID) {
	m.tree_node = &id
}

// ClearTreeNode clears the "tree_node" edge to the TreeNode entity.
func (m *UserSignedTransactionMutation) ClearTreeNode() {
	m.clearedtree_node = true
}

// TreeNodeCleared reports if the "tree_node" edge to the TreeNode entity was cleared.
func (m *UserSignedTransactionMutation) TreeNodeCleared() bool {
	return m.clearedtree_node
}

// TreeNodeID returns the "tree_node" edge ID in the mutation.
func (m *UserSignedTransactionMutation) TreeNodeID() (id uuid.UUID, exists bool) {
	if m.tree_node != nil {
		return *m.tree_node, true
	}
	return
}

// TreeNodeIDs returns the "tree_node" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TreeNodeID instead. It exists only for internal usage by the builders.
func (m *UserSignedTransactionMutation) TreeNodeIDs() (ids []uuid.UUID) {
	if id := m.tree_node; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTreeNode resets all changes to the "tree_node" edge.
func (m *UserSignedTransactionMutation) ResetTreeNode() {
	m.tree_node = nil
	m.clearedtree_node = false
}

// SetPreimageRequestID sets the "preimage_request" edge to the PreimageRequest entity by id.
func (m *UserSignedTransactionMutation) SetPreimageRequestID(id uuid.UUID) {
	m.preimage_request = &id
}

// ClearPreimageRequest clears the "preimage_request" edge to the PreimageRequest entity.
func (m *UserSignedTransactionMutation) ClearPreimageRequest() {
	m.clearedpreimage_request = true
}

// PreimageRequestCleared reports if the "preimage_request" edge to the PreimageRequest entity was cleared.
func (m *UserSignedTransactionMutation) PreimageRequestCleared() bool {
	return m.clearedpreimage_request
}

// PreimageRequestID returns the "preimage_request" edge ID in the mutation.
func (m *UserSignedTransactionMutation) PreimageRequestID() (id uuid.UUID, exists bool) {
	if m.preimage_request != nil {
		return *m.preimage_request, true
	}
	return
}

// PreimageRequestIDs returns the "preimage_request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PreimageRequestID instead. It exists only for internal usage by the builders.
func (m *UserSignedTransactionMutation) PreimageRequestIDs() (ids []uuid.UUID) {
	if id := m.preimage_request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPreimageRequest resets all changes to the "preimage_request" edge.
func (m *UserSignedTransactionMutation) ResetPreimageRequest() {
	m.preimage_request = nil
	m.clearedpreimage_request = false
}

// Where appends a list predicates to the UserSignedTransactionMutation builder.
func (m *UserSignedTransactionMutation) Where(ps ...predicate.UserSignedTransaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSignedTransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSignedTransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSignedTransaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSignedTransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSignedTransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSignedTransaction).
func (m *UserSignedTransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSignedTransactionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, usersignedtransaction.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, usersignedtransaction.FieldUpdateTime)
	}
	if m.transaction != nil {
		fields = append(fields, usersignedtransaction.FieldTransaction)
	}
	if m.user_signature != nil {
		fields = append(fields, usersignedtransaction.FieldUserSignature)
	}
	if m.signing_commitments != nil {
		fields = append(fields, usersignedtransaction.FieldSigningCommitments)
	}
	if m.user_signature_commitment != nil {
		fields = append(fields, usersignedtransaction.FieldUserSignatureCommitment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSignedTransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersignedtransaction.FieldCreateTime:
		return m.CreateTime()
	case usersignedtransaction.FieldUpdateTime:
		return m.UpdateTime()
	case usersignedtransaction.FieldTransaction:
		return m.Transaction()
	case usersignedtransaction.FieldUserSignature:
		return m.UserSignature()
	case usersignedtransaction.FieldSigningCommitments:
		return m.SigningCommitments()
	case usersignedtransaction.FieldUserSignatureCommitment:
		return m.UserSignatureCommitment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSignedTransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersignedtransaction.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case usersignedtransaction.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case usersignedtransaction.FieldTransaction:
		return m.OldTransaction(ctx)
	case usersignedtransaction.FieldUserSignature:
		return m.OldUserSignature(ctx)
	case usersignedtransaction.FieldSigningCommitments:
		return m.OldSigningCommitments(ctx)
	case usersignedtransaction.FieldUserSignatureCommitment:
		return m.OldUserSignatureCommitment(ctx)
	}
	return nil, fmt.Errorf("unknown UserSignedTransaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSignedTransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersignedtransaction.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case usersignedtransaction.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case usersignedtransaction.FieldTransaction:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransaction(v)
		return nil
	case usersignedtransaction.FieldUserSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserSignature(v)
		return nil
	case usersignedtransaction.FieldSigningCommitments:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigningCommitments(v)
		return nil
	case usersignedtransaction.FieldUserSignatureCommitment:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserSignatureCommitment(v)
		return nil
	}
	return fmt.Errorf("unknown UserSignedTransaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSignedTransactionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSignedTransactionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSignedTransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserSignedTransaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSignedTransactionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSignedTransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSignedTransactionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserSignedTransaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSignedTransactionMutation) ResetField(name string) error {
	switch name {
	case usersignedtransaction.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case usersignedtransaction.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case usersignedtransaction.FieldTransaction:
		m.ResetTransaction()
		return nil
	case usersignedtransaction.FieldUserSignature:
		m.ResetUserSignature()
		return nil
	case usersignedtransaction.FieldSigningCommitments:
		m.ResetSigningCommitments()
		return nil
	case usersignedtransaction.FieldUserSignatureCommitment:
		m.ResetUserSignatureCommitment()
		return nil
	}
	return fmt.Errorf("unknown UserSignedTransaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSignedTransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tree_node != nil {
		edges = append(edges, usersignedtransaction.EdgeTreeNode)
	}
	if m.preimage_request != nil {
		edges = append(edges, usersignedtransaction.EdgePreimageRequest)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSignedTransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usersignedtransaction.EdgeTreeNode:
		if id := m.tree_node; id != nil {
			return []ent.Value{*id}
		}
	case usersignedtransaction.EdgePreimageRequest:
		if id := m.preimage_request; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSignedTransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSignedTransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSignedTransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtree_node {
		edges = append(edges, usersignedtransaction.EdgeTreeNode)
	}
	if m.clearedpreimage_request {
		edges = append(edges, usersignedtransaction.EdgePreimageRequest)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSignedTransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case usersignedtransaction.EdgeTreeNode:
		return m.clearedtree_node
	case usersignedtransaction.EdgePreimageRequest:
		return m.clearedpreimage_request
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSignedTransactionMutation) ClearEdge(name string) error {
	switch name {
	case usersignedtransaction.EdgeTreeNode:
		m.ClearTreeNode()
		return nil
	case usersignedtransaction.EdgePreimageRequest:
		m.ClearPreimageRequest()
		return nil
	}
	return fmt.Errorf("unknown UserSignedTransaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSignedTransactionMutation) ResetEdge(name string) error {
	switch name {
	case usersignedtransaction.EdgeTreeNode:
		m.ResetTreeNode()
		return nil
	case usersignedtransaction.EdgePreimageRequest:
		m.ResetPreimageRequest()
		return nil
	}
	return fmt.Errorf("unknown UserSignedTransaction edge %s", name)
}

// UtxoMutation represents an operation that mutates the Utxo nodes in the graph.
type UtxoMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	create_time            *time.Time
	update_time            *time.Time
	block_height           *int64
	addblock_height        *int64
	txid                   *[]byte
	vout                   *uint32
	addvout                *int32
	amount                 *uint64
	addamount              *int64
	network                *schematype.Network
	pk_script              *[]byte
	clearedFields          map[string]struct{}
	deposit_address        *uuid.UUID
	cleareddeposit_address bool
	done                   bool
	oldValue               func(context.Context) (*Utxo, error)
	predicates             []predicate.Utxo
}

var _ ent.Mutation = (*UtxoMutation)(nil)

// utxoOption allows management of the mutation configuration using functional options.
type utxoOption func(*UtxoMutation)

// newUtxoMutation creates new mutation for the Utxo entity.
func newUtxoMutation(c config, op Op, opts ...utxoOption) *UtxoMutation {
	m := &UtxoMutation{
		config:        c,
		op:            op,
		typ:           TypeUtxo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUtxoID sets the ID field of the mutation.
func withUtxoID(id uuid.UUID) utxoOption {
	return func(m *UtxoMutation) {
		var (
			err   error
			once  sync.Once
			value *Utxo
		)
		m.oldValue = func(ctx context.Context) (*Utxo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Utxo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUtxo sets the old Utxo of the mutation.
func withUtxo(node *Utxo) utxoOption {
	return func(m *UtxoMutation) {
		m.oldValue = func(context.Context) (*Utxo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UtxoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UtxoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Utxo entities.
func (m *UtxoMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UtxoMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UtxoMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Utxo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UtxoMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UtxoMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Utxo entity.
// If the Utxo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UtxoMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UtxoMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UtxoMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UtxoMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Utxo entity.
// If the Utxo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UtxoMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UtxoMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetBlockHeight sets the "block_height" field.
func (m *UtxoMutation) SetBlockHeight(i int64) {
	m.block_height = &i
	m.addblock_height = nil
}

// BlockHeight returns the value of the "block_height" field in the mutation.
func (m *UtxoMutation) BlockHeight() (r int64, exists bool) {
	v := m.block_height
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockHeight returns the old "block_height" field's value of the Utxo entity.
// If the Utxo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UtxoMutation) OldBlockHeight(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockHeight: %w", err)
	}
	return oldValue.BlockHeight, nil
}

// AddBlockHeight adds i to the "block_height" field.
func (m *UtxoMutation) AddBlockHeight(i int64) {
	if m.addblock_height != nil {
		*m.addblock_height += i
	} else {
		m.addblock_height = &i
	}
}

// AddedBlockHeight returns the value that was added to the "block_height" field in this mutation.
func (m *UtxoMutation) AddedBlockHeight() (r int64, exists bool) {
	v := m.addblock_height
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlockHeight resets all changes to the "block_height" field.
func (m *UtxoMutation) ResetBlockHeight() {
	m.block_height = nil
	m.addblock_height = nil
}

// SetTxid sets the "txid" field.
func (m *UtxoMutation) SetTxid(b []byte) {
	m.txid = &b
}

// Txid returns the value of the "txid" field in the mutation.
func (m *UtxoMutation) Txid() (r []byte, exists bool) {
	v := m.txid
	if v == nil {
		return
	}
	return *v, true
}

// OldTxid returns the old "txid" field's value of the Utxo entity.
// If the Utxo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UtxoMutation) OldTxid(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxid: %w", err)
	}
	return oldValue.Txid, nil
}

// ResetTxid resets all changes to the "txid" field.
func (m *UtxoMutation) ResetTxid() {
	m.txid = nil
}

// SetVout sets the "vout" field.
func (m *UtxoMutation) SetVout(u uint32) {
	m.vout = &u
	m.addvout = nil
}

// Vout returns the value of the "vout" field in the mutation.
func (m *UtxoMutation) Vout() (r uint32, exists bool) {
	v := m.vout
	if v == nil {
		return
	}
	return *v, true
}

// OldVout returns the old "vout" field's value of the Utxo entity.
// If the Utxo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UtxoMutation) OldVout(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVout: %w", err)
	}
	return oldValue.Vout, nil
}

// AddVout adds u to the "vout" field.
func (m *UtxoMutation) AddVout(u int32) {
	if m.addvout != nil {
		*m.addvout += u
	} else {
		m.addvout = &u
	}
}

// AddedVout returns the value that was added to the "vout" field in this mutation.
func (m *UtxoMutation) AddedVout() (r int32, exists bool) {
	v := m.addvout
	if v == nil {
		return
	}
	return *v, true
}

// ResetVout resets all changes to the "vout" field.
func (m *UtxoMutation) ResetVout() {
	m.vout = nil
	m.addvout = nil
}

// SetAmount sets the "amount" field.
func (m *UtxoMutation) SetAmount(u uint64) {
	m.amount = &u
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *UtxoMutation) Amount() (r uint64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Utxo entity.
// If the Utxo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UtxoMutation) OldAmount(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds u to the "amount" field.
func (m *UtxoMutation) AddAmount(u int64) {
	if m.addamount != nil {
		*m.addamount += u
	} else {
		m.addamount = &u
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *UtxoMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *UtxoMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetNetwork sets the "network" field.
func (m *UtxoMutation) SetNetwork(s schematype.Network) {
	m.network = &s
}

// Network returns the value of the "network" field in the mutation.
func (m *UtxoMutation) Network() (r schematype.Network, exists bool) {
	v := m.network
	if v == nil {
		return
	}
	return *v, true
}

// OldNetwork returns the old "network" field's value of the Utxo entity.
// If the Utxo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UtxoMutation) OldNetwork(ctx context.Context) (v schematype.Network, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetwork is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetwork requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetwork: %w", err)
	}
	return oldValue.Network, nil
}

// ResetNetwork resets all changes to the "network" field.
func (m *UtxoMutation) ResetNetwork() {
	m.network = nil
}

// SetPkScript sets the "pk_script" field.
func (m *UtxoMutation) SetPkScript(b []byte) {
	m.pk_script = &b
}

// PkScript returns the value of the "pk_script" field in the mutation.
func (m *UtxoMutation) PkScript() (r []byte, exists bool) {
	v := m.pk_script
	if v == nil {
		return
	}
	return *v, true
}

// OldPkScript returns the old "pk_script" field's value of the Utxo entity.
// If the Utxo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UtxoMutation) OldPkScript(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPkScript is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPkScript requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPkScript: %w", err)
	}
	return oldValue.PkScript, nil
}

// ResetPkScript resets all changes to the "pk_script" field.
func (m *UtxoMutation) ResetPkScript() {
	m.pk_script = nil
}

// SetDepositAddressID sets the "deposit_address" edge to the DepositAddress entity by id.
func (m *UtxoMutation) SetDepositAddressID(id uuid.UUID) {
	m.deposit_address = &id
}

// ClearDepositAddress clears the "deposit_address" edge to the DepositAddress entity.
func (m *UtxoMutation) ClearDepositAddress() {
	m.cleareddeposit_address = true
}

// DepositAddressCleared reports if the "deposit_address" edge to the DepositAddress entity was cleared.
func (m *UtxoMutation) DepositAddressCleared() bool {
	return m.cleareddeposit_address
}

// DepositAddressID returns the "deposit_address" edge ID in the mutation.
func (m *UtxoMutation) DepositAddressID() (id uuid.UUID, exists bool) {
	if m.deposit_address != nil {
		return *m.deposit_address, true
	}
	return
}

// DepositAddressIDs returns the "deposit_address" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepositAddressID instead. It exists only for internal usage by the builders.
func (m *UtxoMutation) DepositAddressIDs() (ids []uuid.UUID) {
	if id := m.deposit_address; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepositAddress resets all changes to the "deposit_address" edge.
func (m *UtxoMutation) ResetDepositAddress() {
	m.deposit_address = nil
	m.cleareddeposit_address = false
}

// Where appends a list predicates to the UtxoMutation builder.
func (m *UtxoMutation) Where(ps ...predicate.Utxo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UtxoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UtxoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Utxo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UtxoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UtxoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Utxo).
func (m *UtxoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UtxoMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, utxo.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, utxo.FieldUpdateTime)
	}
	if m.block_height != nil {
		fields = append(fields, utxo.FieldBlockHeight)
	}
	if m.txid != nil {
		fields = append(fields, utxo.FieldTxid)
	}
	if m.vout != nil {
		fields = append(fields, utxo.FieldVout)
	}
	if m.amount != nil {
		fields = append(fields, utxo.FieldAmount)
	}
	if m.network != nil {
		fields = append(fields, utxo.FieldNetwork)
	}
	if m.pk_script != nil {
		fields = append(fields, utxo.FieldPkScript)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UtxoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case utxo.FieldCreateTime:
		return m.CreateTime()
	case utxo.FieldUpdateTime:
		return m.UpdateTime()
	case utxo.FieldBlockHeight:
		return m.BlockHeight()
	case utxo.FieldTxid:
		return m.Txid()
	case utxo.FieldVout:
		return m.Vout()
	case utxo.FieldAmount:
		return m.Amount()
	case utxo.FieldNetwork:
		return m.Network()
	case utxo.FieldPkScript:
		return m.PkScript()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UtxoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case utxo.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case utxo.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case utxo.FieldBlockHeight:
		return m.OldBlockHeight(ctx)
	case utxo.FieldTxid:
		return m.OldTxid(ctx)
	case utxo.FieldVout:
		return m.OldVout(ctx)
	case utxo.FieldAmount:
		return m.OldAmount(ctx)
	case utxo.FieldNetwork:
		return m.OldNetwork(ctx)
	case utxo.FieldPkScript:
		return m.OldPkScript(ctx)
	}
	return nil, fmt.Errorf("unknown Utxo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UtxoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case utxo.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case utxo.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case utxo.FieldBlockHeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockHeight(v)
		return nil
	case utxo.FieldTxid:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxid(v)
		return nil
	case utxo.FieldVout:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVout(v)
		return nil
	case utxo.FieldAmount:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case utxo.FieldNetwork:
		v, ok := value.(schematype.Network)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetwork(v)
		return nil
	case utxo.FieldPkScript:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPkScript(v)
		return nil
	}
	return fmt.Errorf("unknown Utxo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UtxoMutation) AddedFields() []string {
	var fields []string
	if m.addblock_height != nil {
		fields = append(fields, utxo.FieldBlockHeight)
	}
	if m.addvout != nil {
		fields = append(fields, utxo.FieldVout)
	}
	if m.addamount != nil {
		fields = append(fields, utxo.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UtxoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case utxo.FieldBlockHeight:
		return m.AddedBlockHeight()
	case utxo.FieldVout:
		return m.AddedVout()
	case utxo.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UtxoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case utxo.FieldBlockHeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockHeight(v)
		return nil
	case utxo.FieldVout:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVout(v)
		return nil
	case utxo.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Utxo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UtxoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UtxoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UtxoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Utxo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UtxoMutation) ResetField(name string) error {
	switch name {
	case utxo.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case utxo.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case utxo.FieldBlockHeight:
		m.ResetBlockHeight()
		return nil
	case utxo.FieldTxid:
		m.ResetTxid()
		return nil
	case utxo.FieldVout:
		m.ResetVout()
		return nil
	case utxo.FieldAmount:
		m.ResetAmount()
		return nil
	case utxo.FieldNetwork:
		m.ResetNetwork()
		return nil
	case utxo.FieldPkScript:
		m.ResetPkScript()
		return nil
	}
	return fmt.Errorf("unknown Utxo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UtxoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.deposit_address != nil {
		edges = append(edges, utxo.EdgeDepositAddress)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UtxoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case utxo.EdgeDepositAddress:
		if id := m.deposit_address; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UtxoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UtxoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UtxoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddeposit_address {
		edges = append(edges, utxo.EdgeDepositAddress)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UtxoMutation) EdgeCleared(name string) bool {
	switch name {
	case utxo.EdgeDepositAddress:
		return m.cleareddeposit_address
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UtxoMutation) ClearEdge(name string) error {
	switch name {
	case utxo.EdgeDepositAddress:
		m.ClearDepositAddress()
		return nil
	}
	return fmt.Errorf("unknown Utxo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UtxoMutation) ResetEdge(name string) error {
	switch name {
	case utxo.EdgeDepositAddress:
		m.ResetDepositAddress()
		return nil
	}
	return fmt.Errorf("unknown Utxo edge %s", name)
}

// UtxoSwapMutation represents an operation that mutates the UtxoSwap nodes in the graph.
type UtxoSwapMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	create_time                     *time.Time
	update_time                     *time.Time
	status                          *schematype.UtxoSwapStatus
	request_type                    *schematype.UtxoSwapRequestType
	credit_amount_sats              *uint64
	addcredit_amount_sats           *int64
	max_fee_sats                    *uint64
	addmax_fee_sats                 *int64
	ssp_signature                   *[]byte
	ssp_identity_public_key         *[]byte
	user_signature                  *[]byte
	user_identity_public_key        *[]byte
	coordinator_identity_public_key *[]byte
	requested_transfer_id           *uuid.UUID
	spend_tx_signing_result         *[]byte
	clearedFields                   map[string]struct{}
	utxo                            *uuid.UUID
	clearedutxo                     bool
	transfer                        *uuid.UUID
	clearedtransfer                 bool
	done                            bool
	oldValue                        func(context.Context) (*UtxoSwap, error)
	predicates                      []predicate.UtxoSwap
}

var _ ent.Mutation = (*UtxoSwapMutation)(nil)

// utxoswapOption allows management of the mutation configuration using functional options.
type utxoswapOption func(*UtxoSwapMutation)

// newUtxoSwapMutation creates new mutation for the UtxoSwap entity.
func newUtxoSwapMutation(c config, op Op, opts ...utxoswapOption) *UtxoSwapMutation {
	m := &UtxoSwapMutation{
		config:        c,
		op:            op,
		typ:           TypeUtxoSwap,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUtxoSwapID sets the ID field of the mutation.
func withUtxoSwapID(id uuid.UUID) utxoswapOption {
	return func(m *UtxoSwapMutation) {
		var (
			err   error
			once  sync.Once
			value *UtxoSwap
		)
		m.oldValue = func(ctx context.Context) (*UtxoSwap, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UtxoSwap.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUtxoSwap sets the old UtxoSwap of the mutation.
func withUtxoSwap(node *UtxoSwap) utxoswapOption {
	return func(m *UtxoSwapMutation) {
		m.oldValue = func(context.Context) (*UtxoSwap, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UtxoSwapMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UtxoSwapMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UtxoSwap entities.
func (m *UtxoSwapMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UtxoSwapMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UtxoSwapMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UtxoSwap.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UtxoSwapMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UtxoSwapMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UtxoSwap entity.
// If the UtxoSwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UtxoSwapMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UtxoSwapMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UtxoSwapMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UtxoSwapMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UtxoSwap entity.
// If the UtxoSwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UtxoSwapMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UtxoSwapMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the "status" field.
func (m *UtxoSwapMutation) SetStatus(sss schematype.UtxoSwapStatus) {
	m.status = &sss
}

// Status returns the value of the "status" field in the mutation.
func (m *UtxoSwapMutation) Status() (r schematype.UtxoSwapStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UtxoSwap entity.
// If the UtxoSwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UtxoSwapMutation) OldStatus(ctx context.Context) (v schematype.UtxoSwapStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UtxoSwapMutation) ResetStatus() {
	m.status = nil
}

// SetRequestType sets the "request_type" field.
func (m *UtxoSwapMutation) SetRequestType(ssrt schematype.UtxoSwapRequestType) {
	m.request_type = &ssrt
}

// RequestType returns the value of the "request_type" field in the mutation.
func (m *UtxoSwapMutation) RequestType() (r schematype.UtxoSwapRequestType, exists bool) {
	v := m.request_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestType returns the old "request_type" field's value of the UtxoSwap entity.
// If the UtxoSwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UtxoSwapMutation) OldRequestType(ctx context.Context) (v schematype.UtxoSwapRequestType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestType: %w", err)
	}
	return oldValue.RequestType, nil
}

// ResetRequestType resets all changes to the "request_type" field.
func (m *UtxoSwapMutation) ResetRequestType() {
	m.request_type = nil
}

// SetCreditAmountSats sets the "credit_amount_sats" field.
func (m *UtxoSwapMutation) SetCreditAmountSats(u uint64) {
	m.credit_amount_sats = &u
	m.addcredit_amount_sats = nil
}

// CreditAmountSats returns the value of the "credit_amount_sats" field in the mutation.
func (m *UtxoSwapMutation) CreditAmountSats() (r uint64, exists bool) {
	v := m.credit_amount_sats
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditAmountSats returns the old "credit_amount_sats" field's value of the UtxoSwap entity.
// If the UtxoSwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UtxoSwapMutation) OldCreditAmountSats(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditAmountSats is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditAmountSats requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditAmountSats: %w", err)
	}
	return oldValue.CreditAmountSats, nil
}

// AddCreditAmountSats adds u to the "credit_amount_sats" field.
func (m *UtxoSwapMutation) AddCreditAmountSats(u int64) {
	if m.addcredit_amount_sats != nil {
		*m.addcredit_amount_sats += u
	} else {
		m.addcredit_amount_sats = &u
	}
}

// AddedCreditAmountSats returns the value that was added to the "credit_amount_sats" field in this mutation.
func (m *UtxoSwapMutation) AddedCreditAmountSats() (r int64, exists bool) {
	v := m.addcredit_amount_sats
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreditAmountSats clears the value of the "credit_amount_sats" field.
func (m *UtxoSwapMutation) ClearCreditAmountSats() {
	m.credit_amount_sats = nil
	m.addcredit_amount_sats = nil
	m.clearedFields[utxoswap.FieldCreditAmountSats] = struct{}{}
}

// CreditAmountSatsCleared returns if the "credit_amount_sats" field was cleared in this mutation.
func (m *UtxoSwapMutation) CreditAmountSatsCleared() bool {
	_, ok := m.clearedFields[utxoswap.FieldCreditAmountSats]
	return ok
}

// ResetCreditAmountSats resets all changes to the "credit_amount_sats" field.
func (m *UtxoSwapMutation) ResetCreditAmountSats() {
	m.credit_amount_sats = nil
	m.addcredit_amount_sats = nil
	delete(m.clearedFields, utxoswap.FieldCreditAmountSats)
}

// SetMaxFeeSats sets the "max_fee_sats" field.
func (m *UtxoSwapMutation) SetMaxFeeSats(u uint64) {
	m.max_fee_sats = &u
	m.addmax_fee_sats = nil
}

// MaxFeeSats returns the value of the "max_fee_sats" field in the mutation.
func (m *UtxoSwapMutation) MaxFeeSats() (r uint64, exists bool) {
	v := m.max_fee_sats
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxFeeSats returns the old "max_fee_sats" field's value of the UtxoSwap entity.
// If the UtxoSwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UtxoSwapMutation) OldMaxFeeSats(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxFeeSats is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxFeeSats requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxFeeSats: %w", err)
	}
	return oldValue.MaxFeeSats, nil
}

// AddMaxFeeSats adds u to the "max_fee_sats" field.
func (m *UtxoSwapMutation) AddMaxFeeSats(u int64) {
	if m.addmax_fee_sats != nil {
		*m.addmax_fee_sats += u
	} else {
		m.addmax_fee_sats = &u
	}
}

// AddedMaxFeeSats returns the value that was added to the "max_fee_sats" field in this mutation.
func (m *UtxoSwapMutation) AddedMaxFeeSats() (r int64, exists bool) {
	v := m.addmax_fee_sats
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxFeeSats clears the value of the "max_fee_sats" field.
func (m *UtxoSwapMutation) ClearMaxFeeSats() {
	m.max_fee_sats = nil
	m.addmax_fee_sats = nil
	m.clearedFields[utxoswap.FieldMaxFeeSats] = struct{}{}
}

// MaxFeeSatsCleared returns if the "max_fee_sats" field was cleared in this mutation.
func (m *UtxoSwapMutation) MaxFeeSatsCleared() bool {
	_, ok := m.clearedFields[utxoswap.FieldMaxFeeSats]
	return ok
}

// ResetMaxFeeSats resets all changes to the "max_fee_sats" field.
func (m *UtxoSwapMutation) ResetMaxFeeSats() {
	m.max_fee_sats = nil
	m.addmax_fee_sats = nil
	delete(m.clearedFields, utxoswap.FieldMaxFeeSats)
}

// SetSspSignature sets the "ssp_signature" field.
func (m *UtxoSwapMutation) SetSspSignature(b []byte) {
	m.ssp_signature = &b
}

// SspSignature returns the value of the "ssp_signature" field in the mutation.
func (m *UtxoSwapMutation) SspSignature() (r []byte, exists bool) {
	v := m.ssp_signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSspSignature returns the old "ssp_signature" field's value of the UtxoSwap entity.
// If the UtxoSwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UtxoSwapMutation) OldSspSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSspSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSspSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSspSignature: %w", err)
	}
	return oldValue.SspSignature, nil
}

// ClearSspSignature clears the value of the "ssp_signature" field.
func (m *UtxoSwapMutation) ClearSspSignature() {
	m.ssp_signature = nil
	m.clearedFields[utxoswap.FieldSspSignature] = struct{}{}
}

// SspSignatureCleared returns if the "ssp_signature" field was cleared in this mutation.
func (m *UtxoSwapMutation) SspSignatureCleared() bool {
	_, ok := m.clearedFields[utxoswap.FieldSspSignature]
	return ok
}

// ResetSspSignature resets all changes to the "ssp_signature" field.
func (m *UtxoSwapMutation) ResetSspSignature() {
	m.ssp_signature = nil
	delete(m.clearedFields, utxoswap.FieldSspSignature)
}

// SetSspIdentityPublicKey sets the "ssp_identity_public_key" field.
func (m *UtxoSwapMutation) SetSspIdentityPublicKey(b []byte) {
	m.ssp_identity_public_key = &b
}

// SspIdentityPublicKey returns the value of the "ssp_identity_public_key" field in the mutation.
func (m *UtxoSwapMutation) SspIdentityPublicKey() (r []byte, exists bool) {
	v := m.ssp_identity_public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSspIdentityPublicKey returns the old "ssp_identity_public_key" field's value of the UtxoSwap entity.
// If the UtxoSwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UtxoSwapMutation) OldSspIdentityPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSspIdentityPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSspIdentityPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSspIdentityPublicKey: %w", err)
	}
	return oldValue.SspIdentityPublicKey, nil
}

// ClearSspIdentityPublicKey clears the value of the "ssp_identity_public_key" field.
func (m *UtxoSwapMutation) ClearSspIdentityPublicKey() {
	m.ssp_identity_public_key = nil
	m.clearedFields[utxoswap.FieldSspIdentityPublicKey] = struct{}{}
}

// SspIdentityPublicKeyCleared returns if the "ssp_identity_public_key" field was cleared in this mutation.
func (m *UtxoSwapMutation) SspIdentityPublicKeyCleared() bool {
	_, ok := m.clearedFields[utxoswap.FieldSspIdentityPublicKey]
	return ok
}

// ResetSspIdentityPublicKey resets all changes to the "ssp_identity_public_key" field.
func (m *UtxoSwapMutation) ResetSspIdentityPublicKey() {
	m.ssp_identity_public_key = nil
	delete(m.clearedFields, utxoswap.FieldSspIdentityPublicKey)
}

// SetUserSignature sets the "user_signature" field.
func (m *UtxoSwapMutation) SetUserSignature(b []byte) {
	m.user_signature = &b
}

// UserSignature returns the value of the "user_signature" field in the mutation.
func (m *UtxoSwapMutation) UserSignature() (r []byte, exists bool) {
	v := m.user_signature
	if v == nil {
		return
	}
	return *v, true
}

// OldUserSignature returns the old "user_signature" field's value of the UtxoSwap entity.
// If the UtxoSwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UtxoSwapMutation) OldUserSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserSignature: %w", err)
	}
	return oldValue.UserSignature, nil
}

// ClearUserSignature clears the value of the "user_signature" field.
func (m *UtxoSwapMutation) ClearUserSignature() {
	m.user_signature = nil
	m.clearedFields[utxoswap.FieldUserSignature] = struct{}{}
}

// UserSignatureCleared returns if the "user_signature" field was cleared in this mutation.
func (m *UtxoSwapMutation) UserSignatureCleared() bool {
	_, ok := m.clearedFields[utxoswap.FieldUserSignature]
	return ok
}

// ResetUserSignature resets all changes to the "user_signature" field.
func (m *UtxoSwapMutation) ResetUserSignature() {
	m.user_signature = nil
	delete(m.clearedFields, utxoswap.FieldUserSignature)
}

// SetUserIdentityPublicKey sets the "user_identity_public_key" field.
func (m *UtxoSwapMutation) SetUserIdentityPublicKey(b []byte) {
	m.user_identity_public_key = &b
}

// UserIdentityPublicKey returns the value of the "user_identity_public_key" field in the mutation.
func (m *UtxoSwapMutation) UserIdentityPublicKey() (r []byte, exists bool) {
	v := m.user_identity_public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldUserIdentityPublicKey returns the old "user_identity_public_key" field's value of the UtxoSwap entity.
// If the UtxoSwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UtxoSwapMutation) OldUserIdentityPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserIdentityPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserIdentityPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserIdentityPublicKey: %w", err)
	}
	return oldValue.UserIdentityPublicKey, nil
}

// ClearUserIdentityPublicKey clears the value of the "user_identity_public_key" field.
func (m *UtxoSwapMutation) ClearUserIdentityPublicKey() {
	m.user_identity_public_key = nil
	m.clearedFields[utxoswap.FieldUserIdentityPublicKey] = struct{}{}
}

// UserIdentityPublicKeyCleared returns if the "user_identity_public_key" field was cleared in this mutation.
func (m *UtxoSwapMutation) UserIdentityPublicKeyCleared() bool {
	_, ok := m.clearedFields[utxoswap.FieldUserIdentityPublicKey]
	return ok
}

// ResetUserIdentityPublicKey resets all changes to the "user_identity_public_key" field.
func (m *UtxoSwapMutation) ResetUserIdentityPublicKey() {
	m.user_identity_public_key = nil
	delete(m.clearedFields, utxoswap.FieldUserIdentityPublicKey)
}

// SetCoordinatorIdentityPublicKey sets the "coordinator_identity_public_key" field.
func (m *UtxoSwapMutation) SetCoordinatorIdentityPublicKey(b []byte) {
	m.coordinator_identity_public_key = &b
}

// CoordinatorIdentityPublicKey returns the value of the "coordinator_identity_public_key" field in the mutation.
func (m *UtxoSwapMutation) CoordinatorIdentityPublicKey() (r []byte, exists bool) {
	v := m.coordinator_identity_public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldCoordinatorIdentityPublicKey returns the old "coordinator_identity_public_key" field's value of the UtxoSwap entity.
// If the UtxoSwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UtxoSwapMutation) OldCoordinatorIdentityPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoordinatorIdentityPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoordinatorIdentityPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoordinatorIdentityPublicKey: %w", err)
	}
	return oldValue.CoordinatorIdentityPublicKey, nil
}

// ResetCoordinatorIdentityPublicKey resets all changes to the "coordinator_identity_public_key" field.
func (m *UtxoSwapMutation) ResetCoordinatorIdentityPublicKey() {
	m.coordinator_identity_public_key = nil
}

// SetRequestedTransferID sets the "requested_transfer_id" field.
func (m *UtxoSwapMutation) SetRequestedTransferID(u uuid.UUID) {
	m.requested_transfer_id = &u
}

// RequestedTransferID returns the value of the "requested_transfer_id" field in the mutation.
func (m *UtxoSwapMutation) RequestedTransferID() (r uuid.UUID, exists bool) {
	v := m.requested_transfer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestedTransferID returns the old "requested_transfer_id" field's value of the UtxoSwap entity.
// If the UtxoSwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UtxoSwapMutation) OldRequestedTransferID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestedTransferID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestedTransferID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestedTransferID: %w", err)
	}
	return oldValue.RequestedTransferID, nil
}

// ClearRequestedTransferID clears the value of the "requested_transfer_id" field.
func (m *UtxoSwapMutation) ClearRequestedTransferID() {
	m.requested_transfer_id = nil
	m.clearedFields[utxoswap.FieldRequestedTransferID] = struct{}{}
}

// RequestedTransferIDCleared returns if the "requested_transfer_id" field was cleared in this mutation.
func (m *UtxoSwapMutation) RequestedTransferIDCleared() bool {
	_, ok := m.clearedFields[utxoswap.FieldRequestedTransferID]
	return ok
}

// ResetRequestedTransferID resets all changes to the "requested_transfer_id" field.
func (m *UtxoSwapMutation) ResetRequestedTransferID() {
	m.requested_transfer_id = nil
	delete(m.clearedFields, utxoswap.FieldRequestedTransferID)
}

// SetSpendTxSigningResult sets the "spend_tx_signing_result" field.
func (m *UtxoSwapMutation) SetSpendTxSigningResult(b []byte) {
	m.spend_tx_signing_result = &b
}

// SpendTxSigningResult returns the value of the "spend_tx_signing_result" field in the mutation.
func (m *UtxoSwapMutation) SpendTxSigningResult() (r []byte, exists bool) {
	v := m.spend_tx_signing_result
	if v == nil {
		return
	}
	return *v, true
}

// OldSpendTxSigningResult returns the old "spend_tx_signing_result" field's value of the UtxoSwap entity.
// If the UtxoSwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UtxoSwapMutation) OldSpendTxSigningResult(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpendTxSigningResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpendTxSigningResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpendTxSigningResult: %w", err)
	}
	return oldValue.SpendTxSigningResult, nil
}

// ClearSpendTxSigningResult clears the value of the "spend_tx_signing_result" field.
func (m *UtxoSwapMutation) ClearSpendTxSigningResult() {
	m.spend_tx_signing_result = nil
	m.clearedFields[utxoswap.FieldSpendTxSigningResult] = struct{}{}
}

// SpendTxSigningResultCleared returns if the "spend_tx_signing_result" field was cleared in this mutation.
func (m *UtxoSwapMutation) SpendTxSigningResultCleared() bool {
	_, ok := m.clearedFields[utxoswap.FieldSpendTxSigningResult]
	return ok
}

// ResetSpendTxSigningResult resets all changes to the "spend_tx_signing_result" field.
func (m *UtxoSwapMutation) ResetSpendTxSigningResult() {
	m.spend_tx_signing_result = nil
	delete(m.clearedFields, utxoswap.FieldSpendTxSigningResult)
}

// SetUtxoID sets the "utxo" edge to the Utxo entity by id.
func (m *UtxoSwapMutation) SetUtxoID(id uuid.UUID) {
	m.utxo = &id
}

// ClearUtxo clears the "utxo" edge to the Utxo entity.
func (m *UtxoSwapMutation) ClearUtxo() {
	m.clearedutxo = true
}

// UtxoCleared reports if the "utxo" edge to the Utxo entity was cleared.
func (m *UtxoSwapMutation) UtxoCleared() bool {
	return m.clearedutxo
}

// UtxoID returns the "utxo" edge ID in the mutation.
func (m *UtxoSwapMutation) UtxoID() (id uuid.UUID, exists bool) {
	if m.utxo != nil {
		return *m.utxo, true
	}
	return
}

// UtxoIDs returns the "utxo" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UtxoID instead. It exists only for internal usage by the builders.
func (m *UtxoSwapMutation) UtxoIDs() (ids []uuid.UUID) {
	if id := m.utxo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUtxo resets all changes to the "utxo" edge.
func (m *UtxoSwapMutation) ResetUtxo() {
	m.utxo = nil
	m.clearedutxo = false
}

// SetTransferID sets the "transfer" edge to the Transfer entity by id.
func (m *UtxoSwapMutation) SetTransferID(id uuid.UUID) {
	m.transfer = &id
}

// ClearTransfer clears the "transfer" edge to the Transfer entity.
func (m *UtxoSwapMutation) ClearTransfer() {
	m.clearedtransfer = true
}

// TransferCleared reports if the "transfer" edge to the Transfer entity was cleared.
func (m *UtxoSwapMutation) TransferCleared() bool {
	return m.clearedtransfer
}

// TransferID returns the "transfer" edge ID in the mutation.
func (m *UtxoSwapMutation) TransferID() (id uuid.UUID, exists bool) {
	if m.transfer != nil {
		return *m.transfer, true
	}
	return
}

// TransferIDs returns the "transfer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransferID instead. It exists only for internal usage by the builders.
func (m *UtxoSwapMutation) TransferIDs() (ids []uuid.UUID) {
	if id := m.transfer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransfer resets all changes to the "transfer" edge.
func (m *UtxoSwapMutation) ResetTransfer() {
	m.transfer = nil
	m.clearedtransfer = false
}

// Where appends a list predicates to the UtxoSwapMutation builder.
func (m *UtxoSwapMutation) Where(ps ...predicate.UtxoSwap) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UtxoSwapMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UtxoSwapMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UtxoSwap, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UtxoSwapMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UtxoSwapMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UtxoSwap).
func (m *UtxoSwapMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UtxoSwapMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.create_time != nil {
		fields = append(fields, utxoswap.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, utxoswap.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, utxoswap.FieldStatus)
	}
	if m.request_type != nil {
		fields = append(fields, utxoswap.FieldRequestType)
	}
	if m.credit_amount_sats != nil {
		fields = append(fields, utxoswap.FieldCreditAmountSats)
	}
	if m.max_fee_sats != nil {
		fields = append(fields, utxoswap.FieldMaxFeeSats)
	}
	if m.ssp_signature != nil {
		fields = append(fields, utxoswap.FieldSspSignature)
	}
	if m.ssp_identity_public_key != nil {
		fields = append(fields, utxoswap.FieldSspIdentityPublicKey)
	}
	if m.user_signature != nil {
		fields = append(fields, utxoswap.FieldUserSignature)
	}
	if m.user_identity_public_key != nil {
		fields = append(fields, utxoswap.FieldUserIdentityPublicKey)
	}
	if m.coordinator_identity_public_key != nil {
		fields = append(fields, utxoswap.FieldCoordinatorIdentityPublicKey)
	}
	if m.requested_transfer_id != nil {
		fields = append(fields, utxoswap.FieldRequestedTransferID)
	}
	if m.spend_tx_signing_result != nil {
		fields = append(fields, utxoswap.FieldSpendTxSigningResult)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UtxoSwapMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case utxoswap.FieldCreateTime:
		return m.CreateTime()
	case utxoswap.FieldUpdateTime:
		return m.UpdateTime()
	case utxoswap.FieldStatus:
		return m.Status()
	case utxoswap.FieldRequestType:
		return m.RequestType()
	case utxoswap.FieldCreditAmountSats:
		return m.CreditAmountSats()
	case utxoswap.FieldMaxFeeSats:
		return m.MaxFeeSats()
	case utxoswap.FieldSspSignature:
		return m.SspSignature()
	case utxoswap.FieldSspIdentityPublicKey:
		return m.SspIdentityPublicKey()
	case utxoswap.FieldUserSignature:
		return m.UserSignature()
	case utxoswap.FieldUserIdentityPublicKey:
		return m.UserIdentityPublicKey()
	case utxoswap.FieldCoordinatorIdentityPublicKey:
		return m.CoordinatorIdentityPublicKey()
	case utxoswap.FieldRequestedTransferID:
		return m.RequestedTransferID()
	case utxoswap.FieldSpendTxSigningResult:
		return m.SpendTxSigningResult()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UtxoSwapMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case utxoswap.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case utxoswap.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case utxoswap.FieldStatus:
		return m.OldStatus(ctx)
	case utxoswap.FieldRequestType:
		return m.OldRequestType(ctx)
	case utxoswap.FieldCreditAmountSats:
		return m.OldCreditAmountSats(ctx)
	case utxoswap.FieldMaxFeeSats:
		return m.OldMaxFeeSats(ctx)
	case utxoswap.FieldSspSignature:
		return m.OldSspSignature(ctx)
	case utxoswap.FieldSspIdentityPublicKey:
		return m.OldSspIdentityPublicKey(ctx)
	case utxoswap.FieldUserSignature:
		return m.OldUserSignature(ctx)
	case utxoswap.FieldUserIdentityPublicKey:
		return m.OldUserIdentityPublicKey(ctx)
	case utxoswap.FieldCoordinatorIdentityPublicKey:
		return m.OldCoordinatorIdentityPublicKey(ctx)
	case utxoswap.FieldRequestedTransferID:
		return m.OldRequestedTransferID(ctx)
	case utxoswap.FieldSpendTxSigningResult:
		return m.OldSpendTxSigningResult(ctx)
	}
	return nil, fmt.Errorf("unknown UtxoSwap field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UtxoSwapMutation) SetField(name string, value ent.Value) error {
	switch name {
	case utxoswap.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case utxoswap.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case utxoswap.FieldStatus:
		v, ok := value.(schematype.UtxoSwapStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case utxoswap.FieldRequestType:
		v, ok := value.(schematype.UtxoSwapRequestType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestType(v)
		return nil
	case utxoswap.FieldCreditAmountSats:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditAmountSats(v)
		return nil
	case utxoswap.FieldMaxFeeSats:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxFeeSats(v)
		return nil
	case utxoswap.FieldSspSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSspSignature(v)
		return nil
	case utxoswap.FieldSspIdentityPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSspIdentityPublicKey(v)
		return nil
	case utxoswap.FieldUserSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserSignature(v)
		return nil
	case utxoswap.FieldUserIdentityPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserIdentityPublicKey(v)
		return nil
	case utxoswap.FieldCoordinatorIdentityPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoordinatorIdentityPublicKey(v)
		return nil
	case utxoswap.FieldRequestedTransferID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestedTransferID(v)
		return nil
	case utxoswap.FieldSpendTxSigningResult:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpendTxSigningResult(v)
		return nil
	}
	return fmt.Errorf("unknown UtxoSwap field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UtxoSwapMutation) AddedFields() []string {
	var fields []string
	if m.addcredit_amount_sats != nil {
		fields = append(fields, utxoswap.FieldCreditAmountSats)
	}
	if m.addmax_fee_sats != nil {
		fields = append(fields, utxoswap.FieldMaxFeeSats)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UtxoSwapMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case utxoswap.FieldCreditAmountSats:
		return m.AddedCreditAmountSats()
	case utxoswap.FieldMaxFeeSats:
		return m.AddedMaxFeeSats()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UtxoSwapMutation) AddField(name string, value ent.Value) error {
	switch name {
	case utxoswap.FieldCreditAmountSats:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreditAmountSats(v)
		return nil
	case utxoswap.FieldMaxFeeSats:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxFeeSats(v)
		return nil
	}
	return fmt.Errorf("unknown UtxoSwap numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UtxoSwapMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(utxoswap.FieldCreditAmountSats) {
		fields = append(fields, utxoswap.FieldCreditAmountSats)
	}
	if m.FieldCleared(utxoswap.FieldMaxFeeSats) {
		fields = append(fields, utxoswap.FieldMaxFeeSats)
	}
	if m.FieldCleared(utxoswap.FieldSspSignature) {
		fields = append(fields, utxoswap.FieldSspSignature)
	}
	if m.FieldCleared(utxoswap.FieldSspIdentityPublicKey) {
		fields = append(fields, utxoswap.FieldSspIdentityPublicKey)
	}
	if m.FieldCleared(utxoswap.FieldUserSignature) {
		fields = append(fields, utxoswap.FieldUserSignature)
	}
	if m.FieldCleared(utxoswap.FieldUserIdentityPublicKey) {
		fields = append(fields, utxoswap.FieldUserIdentityPublicKey)
	}
	if m.FieldCleared(utxoswap.FieldRequestedTransferID) {
		fields = append(fields, utxoswap.FieldRequestedTransferID)
	}
	if m.FieldCleared(utxoswap.FieldSpendTxSigningResult) {
		fields = append(fields, utxoswap.FieldSpendTxSigningResult)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UtxoSwapMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UtxoSwapMutation) ClearField(name string) error {
	switch name {
	case utxoswap.FieldCreditAmountSats:
		m.ClearCreditAmountSats()
		return nil
	case utxoswap.FieldMaxFeeSats:
		m.ClearMaxFeeSats()
		return nil
	case utxoswap.FieldSspSignature:
		m.ClearSspSignature()
		return nil
	case utxoswap.FieldSspIdentityPublicKey:
		m.ClearSspIdentityPublicKey()
		return nil
	case utxoswap.FieldUserSignature:
		m.ClearUserSignature()
		return nil
	case utxoswap.FieldUserIdentityPublicKey:
		m.ClearUserIdentityPublicKey()
		return nil
	case utxoswap.FieldRequestedTransferID:
		m.ClearRequestedTransferID()
		return nil
	case utxoswap.FieldSpendTxSigningResult:
		m.ClearSpendTxSigningResult()
		return nil
	}
	return fmt.Errorf("unknown UtxoSwap nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UtxoSwapMutation) ResetField(name string) error {
	switch name {
	case utxoswap.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case utxoswap.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case utxoswap.FieldStatus:
		m.ResetStatus()
		return nil
	case utxoswap.FieldRequestType:
		m.ResetRequestType()
		return nil
	case utxoswap.FieldCreditAmountSats:
		m.ResetCreditAmountSats()
		return nil
	case utxoswap.FieldMaxFeeSats:
		m.ResetMaxFeeSats()
		return nil
	case utxoswap.FieldSspSignature:
		m.ResetSspSignature()
		return nil
	case utxoswap.FieldSspIdentityPublicKey:
		m.ResetSspIdentityPublicKey()
		return nil
	case utxoswap.FieldUserSignature:
		m.ResetUserSignature()
		return nil
	case utxoswap.FieldUserIdentityPublicKey:
		m.ResetUserIdentityPublicKey()
		return nil
	case utxoswap.FieldCoordinatorIdentityPublicKey:
		m.ResetCoordinatorIdentityPublicKey()
		return nil
	case utxoswap.FieldRequestedTransferID:
		m.ResetRequestedTransferID()
		return nil
	case utxoswap.FieldSpendTxSigningResult:
		m.ResetSpendTxSigningResult()
		return nil
	}
	return fmt.Errorf("unknown UtxoSwap field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UtxoSwapMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.utxo != nil {
		edges = append(edges, utxoswap.EdgeUtxo)
	}
	if m.transfer != nil {
		edges = append(edges, utxoswap.EdgeTransfer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UtxoSwapMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case utxoswap.EdgeUtxo:
		if id := m.utxo; id != nil {
			return []ent.Value{*id}
		}
	case utxoswap.EdgeTransfer:
		if id := m.transfer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UtxoSwapMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UtxoSwapMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UtxoSwapMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedutxo {
		edges = append(edges, utxoswap.EdgeUtxo)
	}
	if m.clearedtransfer {
		edges = append(edges, utxoswap.EdgeTransfer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UtxoSwapMutation) EdgeCleared(name string) bool {
	switch name {
	case utxoswap.EdgeUtxo:
		return m.clearedutxo
	case utxoswap.EdgeTransfer:
		return m.clearedtransfer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UtxoSwapMutation) ClearEdge(name string) error {
	switch name {
	case utxoswap.EdgeUtxo:
		m.ClearUtxo()
		return nil
	case utxoswap.EdgeTransfer:
		m.ClearTransfer()
		return nil
	}
	return fmt.Errorf("unknown UtxoSwap unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UtxoSwapMutation) ResetEdge(name string) error {
	switch name {
	case utxoswap.EdgeUtxo:
		m.ResetUtxo()
		return nil
	case utxoswap.EdgeTransfer:
		m.ResetTransfer()
		return nil
	}
	return fmt.Errorf("unknown UtxoSwap edge %s", name)
}
